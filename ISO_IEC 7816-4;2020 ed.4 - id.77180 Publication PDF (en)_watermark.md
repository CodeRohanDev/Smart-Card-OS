## Identification cards — Integrated

## circuit cards —

## Part 4:

## Organization, security and commands

## for interchange

#### Cartes d'identification — Cartes à circuit intégré —

#### Partie 4: Organisation, sécurité et commandes pour les échanges

# INTERNATIONAL

# STANDAR D

# ISO/IEC

# 7816-

```
Reference number
ISO/IEC 7816-4:2020(E)
```
```
Fourth edition
2020-
```
##### © ISO/IEC 2020


#### ii © ISO/IEC 2020 – All rights reserved

### COPYRIGHT PROTECTED DOCUMENT

© ISO/IEC 2020
All rights reserved. Unless otherwise specified, or required in the context of its implementation, no part of this publication may
be reproduced or utilized otherwise in any form or by any means, electronic or mechanical, including photocopying, or posting
on the internet or an intranet, without prior written permission. Permission can be requested from either ISO at the address
below or ISO’s member body in the country of the requester.
ISO copyright office
CP 401 • Ch. de Blandonnet 8
CH-1214 Vernier, Geneva
Phone: +41 22 749 01 11
Fax: +41 22 749 09 47
Email: copyright@iso.org
Website: [http://www.iso.org](http://www.iso.org)
Published in Switzerland


## Foreword ...................................................................................................................................................................................................................................... vii

#### © ISO/IEC 2020 – All rights reserved iii




- 1 Scope Introduction viii
- 2 Normative references
- 3 Terms and definitions
- 4 Symbols and abbreviated terms
- 5 Command-response pairs
   - 5.1 Conditions of operation
   - 5.2 Syntax
   - 5.3 Chaining procedures
      - 5.3.1 General...................................................................................................................................................................................
      - 5.3.2 Payload fragmentation
      - 5.3.3 Command chaining
      - 5.3.4 Response chaining
   - 5.4 Class byte
      - 5.4.1 Coding
      - 5.4.2 Logical channels
   - 5.5 Instruction byte
   - 5.6 Status bytes
- 6 Data objects
   - 6.1 General
   - 6.2 SIMPLE-TLV data objects............................................................................................................................................................
   - 6.3 BER-TLV data objects
   - 6.4 Constructed DOs versus primitive DOs
- 7 Structures for applications and data
   - 7.1 Available structures
   - 7.2 Validity area
      - 7.2.1 Definitions and attributes
      - 7.2.2 Basic rules for VA handling and use
   - 7.3 Structure selection
      - 7.3.1 Structure selection methods
      - 7.3.2 File reference data element and DO
      - 7.3.3 General reference data element and DO
      - 7.3.4 Data referencing methods in elementary files
   - 7.4 File and data control information
      - 7.4.1 File control information retrieval...................................................................................................................
      - 7.4.2 Data control information retrieval
      - 7.4.3 Control parameters
      - 7.4.4 Short EF identifier
      - 7.4.5 File descriptor byte
      - 7.4.6 Profile indicator
      - 7.4.7 Data descriptor byte
      - 7.4.8 DF and EF list data elements
      - 7.4.9 Instance number data element
      - 7.4.10 Life cycle status
      - 7.4.11 Indirect referencing by short EF identifier using DO'A2'
      - 7.4.12 Interface and life cycle status dependent security attribute template
- 8 Specific use of DOs and related concepts
   - 8.1 ber-tlv payloads and padding..............................................................................................................................................
      - 8.1.1 General...................................................................................................................................................................................
      - 8.1.2 Padding conditions
      - 8.1.3 Padding procedure
   - 8.2 Template referenced by curConstructedDO and data object generations
      - 8.2.1 Template referenced by curConstructedDO and DO referenced by curDO
      - 8.2.2 Template extension
      - 8.2.3 Data object pruned-tree
      - 8.2.4 Data object life cycle
   - 8.3 Identification of data elements and data objects
      - 8.3.1 Principles
      - 8.3.2 Tag interpretation in command and response data fields or payloads
      - 8.3.3 Tag allocation
      - 8.3.4 Standard tag allocation scheme
      - 8.3.5 Compatible tag allocation scheme
      - 8.3.6 Coexistent tag allocation scheme
      - 8.3.7 Avoidance of independent tag allocation schemes
   - 8.4 Referencing and retrieval of DOs and data elements
      - 8.4.1 General...................................................................................................................................................................................
      - 8.4.2 Element list
      - 8.4.3 Tag list
      - 8.4.4 Header list
      - 8.4.5 Extended header and extended header list
      - 8.4.6 Resolving an extended header
      - 8.4.7 Resolving an extended header list
      - 8.4.8 Wrapper
      - 8.4.9 Tagged wrapper
- 9 Security architecture
   - 9.1 General
   - 9.2 Cryptographic mechanism identifier template
   - 9.3 Security attributes
      - 9.3.1 General...................................................................................................................................................................................
      - 9.3.2 Security attributes targets
      - 9.3.3 Compact format
      - 9.3.4 Expanded format
      - 9.3.5 Access rule references
      - 9.3.6 Security attributes for data objects
      - 9.3.7 Security parameters template
      - 9.3.8 Security attributes for logical channels.....................................................................................................
   - 9.4 Security support data elements
- 10 Secure messaging
   - 10.1 General
   - 10.2 SM fields and SM DOs
      - 10.2.1 SM protection of command payloads
      - 10.2.2 SM protection of chained commands and responses
      - 10.2.3 SM DOs
   - 10.3 Basic SM DOs
      - 10.3.1 SM DOs for encapsulating plain values
      - 10.3.2 SM DOs for confidentiality
      - 10.3.3 SM DOs for authentication
   - 10.4 Auxiliary SM DOs
      - 10.4.1 General...................................................................................................................................................................................
      - 10.4.2 Control reference templates
      - 10.4.3 Control reference DOs in control reference templates
      - 10.4.4 Security environments.............................................................................................................................................
      - 10.4.5 Response descriptor template
   - 10.5 SM impact on command-response pairs
- 11 Commands for interchange
   - 11.1 General
   - 11.2 Selection.....................................................................................................................................................................................................
      - 11.2.1 General...................................................................................................................................................................................
      - 11.2.2 select command
      - 11.2.3 manage channel command
   - 11.3 Data unit handling
      - 11.3.1 Data units
      - 11.3.2 General...................................................................................................................................................................................
      - 11.3.3 read binary command
      - 11.3.4 write binary command
      - 11.3.5 update binary command
      - 11.3.6 search binary command
      - 11.3.7 erase binary command
      - 11.3.8 compare binary function
   - 11.4 Record handling
      - 11.4.1 Records
      - 11.4.2 General...................................................................................................................................................................................
      - 11.4.3 read record (s) command
      - 11.4.4 write record command
      - 11.4.5 update record command
      - 11.4.6 append record command
      - 11.4.7 search record command
      - 11.4.8 erase record (s) command
      - 11.4.9 activate record (s) command
      - 11.4.10 deactivate record (s) command
      - 11.4.11 compare record function
   - 11.5 Data object handling
      - 11.5.1 General...................................................................................................................................................................................
      - 11.5.2 select data command
      - 11.5.3 get data/get next data commands — even INS codes
      - 11.5.4 get data/get next data commands — odd INS codes
      - 11.5.5 General properties of put data/put next data/update data commands
      - 11.5.6 put data command
      - 11.5.7 put next data command
      - 11.5.8 update data command
      - 11.5.9 compare data function
   - 11.6 Basic security handling
      - 11.6.1 General................................................................................................................................................................................
      - 11.6.2 internal authenticate command
      - 11.6.3 get challenge command
      - 11.6.4 external authenticate command
      - 11.6.5 general authenticate command
      - 11.6.6 verify command
      - 11.6.7 change reference data command
      - 11.6.8 enable verification requirement command
      - 11.6.9 disable verification requirement command
      - 11.6.10 reset retry counter command
      - 11.6.11 manage security environment command
   - 11.7 Miscellaneous
      - 11.7.1 compare command
      - 11.7.2 get attribute command
   - 11.8 Transmission handling
      - 11.8.1 get response command
      - 11.8.2 envelope command
- 12 Application-independent card services
   - 12.1 General
   - 12.2 Card identification
      - 12.2.1 General................................................................................................................................................................................
      - 12.2.2 Historical bytes
      - 12.2.3 Initial data string recovery
      - 12.2.4 Waiting time management
   - 12.3 Application identification and selection
      - 12.3.1 General................................................................................................................................................................................
      - 12.3.2 EF.DIR
      - 12.3.3 EF .ATR/ INFO
      - 12.3.4 Application identifier
      - 12.3.5 Application template and related data elements
      - 12.3.6 Application selection
   - 12.4 Selection by path
   - 12.5 Data retrieval
   - 12.6 Card-originated byte string
      - 12.6.1 General................................................................................................................................................................................
      - 12.6.2 Triggering by the card
      - 12.6.3 Queries and replies
      - 12.6.4 Formats
   - 12.7 General feature management
      - 12.7.1 General................................................................................................................................................................................
      - 12.7.2 On-card services
      - 12.7.3 Interface services
      - 12.7.4 Profile services
      - 12.7.5 Provision of additional information
   - 12.8 APDU management
      - 12.8.1 Extended length information
      - 12.8.2 List of supported INS codes
- Annex A (informative) Examples of object identifiers and tag allocation schemes
- Annex B (informative) Examples of secure messaging
   - commands Annex C (informative) Examples of authenticate functions by general authenticate
- Annex D (informative) Application identifiers using issuer identification numbers
- Annex E (informative) BER encoding rules
- Annex F (informative) ber-tlv data object handling
- Annex G (informative) Template extension by tagged wrapper
- Annex H (informative) Parsing an extended header against its target DO
   - waiting time procedure Annex I (informative) Use case of WTX (waiting time extension) procedure and application
- Bibliography


## Foreword

#### ISO (the International Organization for Standardization) and IEC (the International Electrotechnical

#### Commission) form the specialized system for worldwide standardization. National bodies that

#### are members of ISO or IEC participate in the development of International Standards through

#### technical committees established by the respective organization to deal with particular fields of

#### technical activity. ISO and IEC technical committees collaborate in fields of mutual interest. Other

#### international organizations, governmental and non-governmental, in liaison with ISO and IEC, also

#### take part in the work.

#### The procedures used to develop this document and those intended for its further maintenance are

#### described in the ISO/IEC Directives, Part 1. In particular, the different approval criteria needed for

#### the different types of document should be noted. This document was drafted in accordance with the

#### editorial rules of the ISO/IEC Directives, Part 2 (see www .iso .org/ directives).

#### Attention is drawn to the possibility that some of the elements of this document may be the subject

#### of patent rights. ISO and IEC shall not be held responsible for identifying any or all such patent

#### rights. Details of any patent rights identified during the development of the document will be in the

#### Introduction and/or on the ISO list of patent declarations received (see www .iso .org/ patents) or the IEC

#### list of patent declarations received (see h t t p : // patents .iec .ch).

#### Any trade name used in this document is information given for the convenience of users and does not

#### constitute an endorsement.

#### For an explanation of the voluntary nature of standards, the meaning of ISO specific terms and

#### expressions related to conformity assessment, as well as information about ISO's adherence to the

#### World Trade Organization (WTO) principles in the Technical Barriers to Trade (TBT) see www .iso .org/

#### iso/ foreword .html.

#### This document was prepared by Joint Technical Committee ISO/IEC JTC 1, Information technology ,

#### Subcommittee SC 17, Cards and security devices for personal identification.

#### This fourth edition cancels and replaces the third edition (ISO/IEC 7816-4:2013), which has been

#### technically revised. It also incorporates the Amendments ISO/IEC 7816-4:2013/Amd.1:2018 and

#### ISO/IEC 7816-4:2013/Amd.2:2018 and the Corrigendum ISO/IEC 7816-4:2013/Cor.1:2014.

#### The main changes compared to the previous edition are as follows:

#### — incorporation with the amendments and the corrigendum;

#### — revision of unclear portions and correction of editorial mistakes.

#### A list of all parts in the ISO/IEC 7816 series can be found on the ISO website.

#### Any feedback or questions on this document should be directed to the user’s national standards body. A

#### complete listing of these bodies can be found at www .iso .org/ members .html.

#### © ISO/IEC 2020 – All rights reserved vii


## Introduction

#### ISO/IEC 7816 (all parts)[4] is a series of standards specifying integrated circuit cards and the use of

#### such cards for interchange. These cards are identification cards intended for information exchange

#### negotiated between the outside world and the integrated circuit in the card. As a result of an information

#### exchange, the card delivers information (computation result, stored data) and/or modifies its content

#### (data storage, event memorization).

#### — Five parts are specific to cards with galvanic contacts and three of them specify electrical interfaces.

#### — ISO/IEC 7816-1 specifies physical characteristics for cards with contacts.

#### — ISO/IEC 7816-2 specifies dimensions and location of the contacts.

#### — ISO/IEC 7816-3 specifies electrical interface and transmission protocols for asynchronous cards.

#### — ISO/IEC 7816-10 specifies electrical interface and answer to reset for synchronous cards.

#### — ISO/IEC 7816-12 specifies electrical interface and operating procedures for USB cards.

#### — All the other parts are independent from the physical interface technology. They apply to cards

#### accessed by contacts and/or by radio frequency.

#### — ISO/IEC 7816-4 specifies organization, security and commands for interchange.

#### — ISO/IEC 7816-5 specifies registration of application providers.

#### — ISO/IEC 7816-6 specifies interindustry data elements for interchange.

#### — ISO/IEC 7816-7 specifies commands for structured card query language.

#### — ISO/IEC 7816-8 specifies commands for security operations.

#### — ISO/IEC 7816-9 specifies commands for card management.

#### — ISO/IEC 7816-11 specifies personal verification through biometric methods.

#### — ISO/IEC 7816-13 specifies commands for handling the life cycle of applications.

#### — ISO/IEC 7816-15 specifies cryptographic information application.

#### ISO/IEC 10536 (all parts)[11] specifies access by close coupling. ISO/IEC 14443 (all parts)[14] and

#### ISO/IEC 15693 (all parts)[16] specify access by radio frequency. Such cards are also known as

#### contactless cards.

#### The International Organization for Standardization (ISO) and International Electrotechnical

#### Commission (IEC) draw attention to the fact that it is claimed that compliance with this document may

#### involve the use of a patent.

#### ISO and IEC take no position concerning the evidence, validity and scope of this patent right.

#### The holder of this patent right has assured ISO and IEC that he/she is willing to negotiate licences —

#### reasonable and non-discriminatory terms and conditions with applicants throughout the world. In this

#### respect, the statement of the holder of this patent right is registered with ISO and IEC. Information may

#### be obtained from the patent database available at www .iso .org/ patents.

#### Attention is drawn to the possibility that some of the elements of this document may be the subject

#### of patent rights other than those in the patent database. ISO and IEC shall not be held responsible for

#### identifying any or all such patent rights.

#### viii © ISO/IEC 2020 – All rights reserved


**Identification cards — Integrated circuit cards —**

Part 4:

**Organization, security and commands for interchange**

**1 Scope**

#### This document is intended to be used in any sector of activity. It specifies:

#### — contents of command-response pairs exchanged at the interface,

#### — means of retrieval of data elements and data objects in the card,

#### — structures and contents of historical bytes to describe operating characteristics of the card,

#### — structures for applications and data in the card, as seen at the interface when processing commands,

#### — access methods to files and data in the card,

#### — a security architecture defining access rights to files and data in the card,

#### — means and mechanisms for identifying and addressing applications in the card,

#### — methods for secure messaging,

#### — access methods to the algorithms processed by the card. It does not describe these algorithms.

#### It does not cover the internal implementation within the card or the outside world.

#### This document is independent from the physical interface technology. It applies to cards accessed by

#### one or more of the following methods: contacts, close coupling and radio frequency. If the card supports

#### simultaneous use of more than one physical interface, the relationship between what happens on

#### different physical interfaces is out of the scope of this document.

## 2 Normative references

#### The following documents are referred to in the text in such a way that some or all of their content

#### constitutes requirements of this document. For dated references, only the edition cited applies. For

#### undated references, the latest edition of the referenced document (including any amendments) applies.

#### ISO/IEC 7816-3, Identification cards — Integrated circuit cards — Part 3: Cards with contacts — Electrical

#### interface and transmission protocols

#### ISO/IEC 7816-6, Identification cards — Integrated circuit cards — Part 6: Interindustry data elements for

#### interchange

#### ISO/IEC 8825-1, Information technology — ASN.1 encoding rules: Specification of Basic Encoding Rules

#### (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER) — Part 1:

## 3 Terms and definitions

#### For the purposes of this document, the following terms and definitions apply.

### INTERNATIONAL STANDARD ISO/IEC 7816-4:2020(E)


#### ISO and IEC maintain terminological databases for use in standardization at the following addresses:

#### — ISO Online browsing platform: available at h t t p s : // www .iso .org/ obp

#### — IEC Electropedia: available at h t t p : // www .electropedia .org/

#### 3.

#### access rule

#### data element ( 3.15) containing an access mode referring to an action and security conditions to fulfil

#### before acting

#### 3.

#### Answer-to-Reset file

#### information file

#### EF .ATR/ INFO

#### optional EF (3.22) indicating operating characteristics of the card

#### 3.

#### application

#### structures (3.55), data elements (3.15) and program modules needed for performing a specific

#### functionality

#### 3.

#### application DF

#### dedicated file ( DF (3.18)) hosting an application (3.3) in a card

#### 3.

#### application identifier

#### AID

#### data element (3.15) (up to sixteen bytes) that identifies an application (3.3)

#### 3.

#### application label

#### data element (3.15) for use at the man-machine interface

#### 3.

#### application provider

#### entity providing the components that make up an application (3.3) in the card

#### 3.

#### application template

#### set of application-relevant data objects (3.16) including one application identifier (3.5) data object (3.16)

#### 3.

#### asymmetric cryptographic technique

#### cryptographic technique that uses two related operations: a public operation defined by public numbers

#### or by a public key (3.41) and a private operation defined by private numbers or by a private key (3.39)

Note 1 to entry: The two operations have the property that, given the public operation, it is computationally
infeasible to derive the private operation.

#### 3.

#### base template

#### value field of constructed data object (3.16) excluding DOs resulting from resolution of indirect

#### referencing

#### 3.

#### certificate

#### digital signature (3.20) binding a particular person or object (3.32) and its associated public key (3.41)

Note 1 to entry: The entity issuing the certificate also acts as tag allocation authority with respect to the data
elements in the certificate.


#### 3.

#### command-response pair

#### C-RP

#### set of two messages at the interface: a command APDU followed by a response APDU in the opposite

#### direction

#### 3.

#### command chaining

#### means used by the outside world to tell the card that the command data of a sequence of successive

#### command-response pairs (3.12) shall be processed together

#### 3.

#### context-specific class

#### class of a tag with its first or only byte from '80' to 'BF'

#### 3.

#### data element

#### item of information seen at the interface for which are specified a name, a description of logical content,

#### a format and a coding

#### 3.

#### data object

#### information seen at the interface consisting of the concatenation of a mandatory tag field, a mandatory

#### length field and a conditional value field

#### 3.

#### data unit

#### smallest set of bits that can be unambiguously referenced within an EF (3.22) supporting data units

#### 3.

#### dedicated file

#### DF

#### structure (3.55) containing file control information and, optionally, memory available for allocation

#### 3.

#### DF name

#### data element (3.15) (up to sixteen bytes) that uniquely identifies a DF (3.18) in the card

#### 3.

#### digital signature

#### data appended to, or cryptographic transformation of, a data string that proves the origin and the

#### integrity of the data string and protects against forgery, e.g. by the recipient of the data string

#### 3.

#### directory file

#### EF.DIR

#### optional EF (3.22) containing a list of applications (3.3) supported by the card and optional related data

#### elements (3.15)

#### 3.

#### elementary file

#### EF

#### set of data units (3.17) or records (3.42) or data objects (3.16) sharing the same file identifier (3.26)

#### 3.

#### extended header

#### data element (3.15) referencing one or several DOs in a constructed DO

#### 3.

#### extended header list

#### concatenation of extended headers (3.23)


#### 3.

#### file

#### structure (3.55) for application (3.3) and/or data in the card, as seen at the interface when processing

#### commands

#### 3.

#### file identifier

#### data element (3.15) (two bytes) used to address a file (3.25)

#### 3.

#### header list

#### concatenation of pairs of tag field and length field without delimiter

#### 3.

#### interindustry

#### items specified in the ISO/IEC 7816[4] series

#### 3.

#### internal EF

#### EF (3.22) for storing data interpreted by the card

#### 3.

#### key

#### sequence of symbols controlling a cryptographic operation

EXAMPLE Encipherment, decipherment, a private or a public operation in a dynamic authentication,
signature generation, signature verification.

#### 3.

#### master file

#### MF

#### unique DF (3.18) representing the root in a card using a hierarchy of DFs (3.18)

#### 3.

#### object

#### structure (3.55) plus security object (3.52)

#### 3.

#### offset

#### number sequentially referencing a data unit (3.17) in an EF (3.22) supporting data units (3.17), or a byte

#### in a record (3.42)

#### 3.

#### oversize payload

#### payload (3.38) which exceeds the current size constraints of the APDU

#### 3.

#### parent file

#### DF (3.18) immediately preceding a given file (3.25) within a hierarchy of DFs (3.18)

#### 3.

#### password

#### data that may be required by the application (3.3) to be presented to the card by its user (3.63) for

#### authentication purpose

#### 3.

#### path

#### concatenation of file identifiers (3.26) without delimiter

#### 3.

#### payload

#### data of arbitrary length, to be sent to the card or by the card, in order to be processed together


#### 3.

#### private key

#### key (3.30) of an entity's asymmetric key pair which should only be used by that entity

#### 3.

#### provider

#### authority who has or who obtained the right to create a DF (3.18) in the card

#### 3.

#### public key

#### key (3.30) of an entity's asymmetric key pair that can be made public

#### 3.

#### record

#### string of bytes referenced and handled by the card within an EF (3.22) supporting records

#### 3.

#### record identifier

#### number used to reference one or more records (3.42) within an EF (3.22) supporting records

#### 3.

#### record number

#### sequential number that uniquely identifies each records (3.42) within an EF (3.22) supporting records

#### 3.

#### registered application provider identifier

#### RID

#### data element (3.15) (five bytes) that uniquely identifies an application provider (3.7)

#### 3.

#### resetting code

#### data to be presented to a card in order to modify the value of a counter

#### 3.

#### response chaining

#### means used by the card to tell the outside world that the response data of any command-response pair

#### (3.12) followed by the response data of a sequence of get response command-response pairs should be

#### processed together

#### 3.

#### secret key

#### key (3.30) used with symmetric cryptographic techniques (3.56) by a set of specified entities

#### 3.

#### secure messaging

#### SM

#### set of means for cryptographic protection of (parts of) command-response pairs (3.12)

#### 3.

#### security attribute

#### condition of use of objects (3.32) in the card including stored data and data processing functions,

#### expressed as a data element (3.15) containing one or more access rules (3.1)

#### 3.

#### security environment

#### SE

#### set of components required by an application (3.3) in the card for secure messaging (3.49) or for security

#### operations


#### 3.

#### security object

#### standalone object nested in an EF (3.22), a record (3.42), a data object (3.16), a DataString or a

#### combination thereof that endorses security handling according to this document

EXAMPLE Password, password type, reference data including biometric, reference data type, _certificate_
(3.11), certificate type or _key_ (3.30).

#### 3.

#### self-controlled DO

#### constructed DO which nests at least a DO'62' nesting security attributes (3.50)

#### 3.

#### short EF identifier

#### data element (3.15) (five bits) used to address an elementary file

#### 3.

#### structure

#### DF (3.18), EF (3.22), record (3.42), DataString or DO

#### 3.

#### symmetric cryptographic technique

#### cryptographic technique using the same secret key (3.48) for both the originator's and the recipient's

#### operation (without the secret key, it is computationally infeasible to compute either operation)

#### 3.

#### tag list

#### concatenation of tag fields without delimiter

#### 3.

#### tagged wrapper

#### wrapper (3.67) which provides a tag for local addressing of the DO it references

#### 3.

#### template

#### concatenation of ber-tlv data objects (3.16), forming the value field of a constructed ber-tlv data

#### object (3.16)

#### 3.

#### template extension

#### part of the value field of a constructed DO resulting from automatic resolution of indirect referencing

#### 3.

#### transient selection

#### structure (3.55) selection needed when performing a C-RP (3.12), the success of which will not modify

#### the current validity area (3.64)

#### 3.

#### transient VA

#### validity area (3.64) set transiently during execution of a command which handles DOs

#### 3.

#### user

#### user of the card, also known as cardholder

#### 3.

#### validity area

#### VA

#### result of all successful selections performed on a logical channel


#### 3.

#### virtual root DO

#### virtual constructed DO'7F70' made current by the selection of a file (3.25), a record (3.42) or a

#### DataString supporting DO handling

#### 3.

#### working EF

#### EF (3.22) for storing data not interpreted by the card

#### 3.

#### wrapper

#### concatenation of DOs referencing a DO

## 4 Symbols and abbreviated terms

#### AID application identifier

#### AMB access mode byte

#### AMF access mode field

#### APDU application protocol data unit

#### ARR access rule reference

#### ASN.1 abstract syntax notation one (see ISO/IEC 8825-1)

#### AT control reference template for authentication

#### ATR Answer-to-Reset

#### BER basic encoding rules of ASN.1 (see ISO/IEC 8825-1)

#### CC cryptographic checksum

#### CCT control reference template for cryptographic checksum

#### CG cryptogram

#### CLA class byte

#### CL A* * CLA with SM indication (bits b8, b7 and b6 set to 000 and bits b4 and b3 set to 11)

#### CRT control reference template

#### CT control reference template for confidentiality

#### CP control parameter (file control parameter or data object control parameter)

#### CP DO control parameter ber-tlv data object

#### C-RP command-response pair

#### DF dedicated file

#### DIR directory

#### DO ber-tlv data object

#### DO'...' ber-tlv data object, the tag of which is a hexadecimal value given between simple quotes

#### DS digital signature

#### DST control reference template for digital signature

#### EF elementary file

#### EF. A R R access rule reference file

#### EF. AT R / INFO Answer-to-Reset file or Information file

#### EF. DIR directory file

#### FCI file control information

#### FCP file control parameter

#### FMD file management data


#### HT control reference template for hash-code

#### ICC integrated circuit card

#### INS instruction byte

#### K AT control reference template for key agreement

#### Lc field length field for coding the number N c

#### LCS Life cycle status

#### Le field length field for coding the number N e

#### MF master file

#### MSE manage security environment

#### N c number of bytes in the command data field

#### N e maximum number of bytes expected in the response data field

#### N r number of bytes in the response data field

#### OID object identifier, as defined by ISO/IEC 8825-

#### PCI padding-content indicator byte

#### PIX proprietary application identifier extension

#### PSO perform security operation

#### P1-P2 parameter bytes (inserted for clarity, the dash is not significant)

#### RFU reserved for future use by ISO/IEC JTC 1/SC 17

#### RID registered application provider identifier

#### SC security condition

#### SCB security condition byte

#### SCQL structured card query language

#### SE security environment

#### SEID security environment identifier

#### SM secure messaging

#### SMC security module card

#### SPT security parameter template

#### SW1-SW2 status bytes (inserted for clarity, the dash is not significant)

#### TLV tag, length, value

#### { T-L -V } data object (inserted for clarity, the dashes and curly brackets are not significant)

#### USC user card

#### VA validity area

#### 'XY'

#### notation where any upper case letter from G to Z stands for a hexadecimal digit from '0'

#### to '9' or 'A' to 'F', equal to XY to the base 16. Identical letters do not state that the most

#### and least significant quartets are identical.

## 5 Command-response pairs

### 5.1 Conditions of operation

#### A physical interface between the card and the outside world shall be enabled to support processing of

#### command-response pairs. The enabling process is defined by interface-specific protocols. With their

#### own words (between double quotes), the following standards define enabling procedures:

#### — ISO/IEC 7816-3 defines "activation of contacts", "cold reset" or "warm reset", and possible "Protocol

#### and Parameter Selection".


#### — ISO/IEC 7816-12 defines "electrical connection" of contacts with reference to the USB specification,

#### the "Configured" and "Initial" state of the device, and "ATR".

#### — ISO/IEC 14443[14] (all parts) defines how to set a proximity card to an "ACTIVE" state.

#### Those standards also define procedures and situations which disable the physical interface. A disabled

#### physical interface shall not support processing of command-response pairs.

### 5.2 Syntax

#### Syntax of APDU shall comply with ISO/IEC 7816-3. Table 1 shows a command-response pair (C-RP),

#### namely a command APDU followed by a response APDU in the opposite direction (see ISO/IEC 7816-3).

#### There shall be no interleaving of C-RPs across the interface , i.e. the response APDU shall be received

#### before initiating another C-RP.

#### In any command APDU comprising both Lc and Le fields (see ISO/IEC 7816-3), short and extended length

#### fields shall not be combined: either both of them are short, or both of them are extended.

#### If the card explicitly states its capability of handling "extended Lc and Le fields" (see Table 127 , third

#### software function table) in the historical bytes (see 12.2.2) or in EF .ATR/ INFO (see 12.3.3), then the

#### card handles short and extended length fields. Otherwise (default value), the card handles only short

#### length fields. In a command APDU longer than 5 bytes, the use of extended length fields is indicated by

#### the first byte after P2 equal to '00'.

#### Nc denotes the number of bytes in the command data field. The Lc field encodes Nc.

#### — If the Lc field is absent, then Nc is zero.

#### — A short Lc field consists of one byte not set to '00'. From '01' to 'FF', the byte encodes Nc from one to 255.

#### — An extended Lc field consists of three bytes: one byte set to '00' followed by two bytes not set to

#### '0000'. From '0001' to 'FFFF', the two bytes encode Nc from one to 65 535.

#### Table 1 — Command-response pair (C-RP)

```
Field Description Number of bytes Direction
```
```
Command header
```
```
Class byte denoted CLA 1
```
```
To the
card
```
```
Instruction byte denoted INS 1
Parameter bytes denoted P1-P2 2
Lc field Absent for encoding Nc = 0, present for encoding Nc > 0 0, 1 or 3
Command data field Absent if Nc = 0, present as a string of Nc bytes if Nc > 0 Nc
Le field Absent for encoding Ne = 0, present for encoding Ne > 0 0, 1, 2 or 3
```
```
Response data field Absent if Nr = 0, present as a string of Nr bytes if Nr > 0 Nr (at most Ne ) From the
Response trailer Status bytes denoted SW1-SW2 2 card
```
#### Ne denotes the maximum number of bytes expected in the response data field, regardless of any

#### structure of the data within this field. The Le field encodes Ne.

#### — If the Le field is absent, then Ne is zero.

#### — A short Le field consists of one byte with any value.

#### — From '01' to 'FF', the byte encodes N e from one to 255.


#### — If the byte is set to '00', then N e is 256.

#### — An extended Le field consists of either three bytes (one byte set to '00' followed by two bytes with

#### any value) if the Lc field is absent, or two bytes (with any value) if an extended Lc field is present.

#### — From '0001' to 'FFFF', the two bytes encode N e from one to 65 535.

#### — If the two bytes are set to '0000', then N e is 65 536.

#### Nr denotes the number of bytes in the response data field. Nr shall be less than or equal to Ne. Therefore

#### in any C-RP, the absence of Le field is the standard way for receiving no response data field. If the Le field

#### contains only bytes set to '00', then Ne is maximum, i.e. within the limit of 256 for a short Le field, or

#### 65 536 for an extended Le field, all the available bytes should be returned.

#### If the process is aborted, then the card may become unresponsive. However, if a response APDU occurs,

#### then the response data field shall be absent and SW1-SW2 shall indicate an error.

#### P1-P2 indicates controls and options for processing the command. A parameter byte P1 or P2 set to

#### '00' generally provides no further qualification. There is no other general convention for encoding the

#### parameter bytes.

#### General conventions are specified hereafter for encoding the class byte denoted CLA (see 5.4), the

#### instruction byte denoted INS (see 5.5) and the status bytes denoted SW1-SW2 (see 5.6). In those bytes,

#### the RFU bits shall be set to 0 unless otherwise specified.

### 5.3 Chaining procedures

#### 5.3.1 General...................................................................................................................................................................................

#### Chaining procedures are used either to support payload fragmentation or for a process involving

#### several consecutive C-RPs.

#### 5.3.2 Payload fragmentation

#### A command payload is data of arbitrary length to be sent to the card in order to be processed together.

#### A response payload is data of arbitrary length to be received from the card as requested. A payload is

#### oversize if its length is larger than available in a data field; chaining is needed to transmit an oversize

#### payload:

#### — Chaining of commands supports the transmission to the card of an oversize command payload. The

#### payload is fragmented; each fragment is a command data field which complies with size limitations.

#### — Chaining of responses supports the recovery from the card of an oversize response payload. The

#### payload is fragmented; each fragment is a response data field which complies with size limitations.

#### The receiver shall concatenate the successively transmitted fragments to recover the payload.

#### APDU syntax limits the size of data fields. More size limitations may be stated (see 12.8.1); if an Le field

#### ('0000' or '000000') indicates Ne = '010000', then all the required information should be returned, up to

#### 65 536 bytes. Fragmentation will occur with the short format of length fields if the command payload

#### exceeds 255 bytes and/or the response payload exceeds 256 bytes. Fragmentation should not occur

#### with the extended format of length fields if payloads comply with stated size limitations (see 12.8.1).

#### 5.3.3 Command chaining

#### This clause specifies a mechanism whereby in the interindustry class (CLA < '80', see Table 2 and

#### Table 3 ) consecutive C-RPs can be chained. If the card supports the mechanism, then it shall indicate it


#### (se e Table 127 , third software function table) in the historical bytes (see 12.2.2) or in EF .ATR/ INFO (see

#### 12.3.3).

NOTE The contents of this clause do not depend on the transmission protocol. ISO/IEC 7816-3 describes
chaining when using protocol T=0.

#### For chaining in the interindustry class, bit b5 of CLA shall be used while the other seven bits are

#### constant.

#### — If bit b5 is set to 0, then the command is the only or last command of a chain.

#### — If bit b5 is set to 1, then the command is not the last command of a chain.

#### The mechanism may be used:

#### — To transmit an oversize command payload:

#### — All CLA bytes of the commands shall be the same, except for bit b5 (see above).

#### — If bit b5 is set to 1, then the Le field shall be absent.

#### — If bit b5 is set to 0, then an Le field may be present.

#### — All INS P1 P2 bytes of the commands shall be the same.

#### — As specified elsewhere in this document (see example in Annex C).

#### — For any application-defined process involving several consecutive C-RPs.

#### — Bit b5 of CLA shall be used as defined above.

#### — The logical channel indicated by CLA shall be the same.

#### — There is no constraint on the values of INS P1 P2 bytes of the commands.

#### This document specifies the card behaviour only in the case where, once initiated, a chain of C-RPs is

#### successfully processed before initiating a C-RP not part of the chain. If this condition is not respected,

#### the card behaviour is out of scope of this document, but may be described in a specification.

#### In response to a command that is not the last command of a chain, SW1-SW2 set to '9000' means that

#### the process has been completed so far; the use of warning indications is defined in 5.6; the following

#### specific error conditions may occur.

#### — If SW1-SW2 is set to '6883', then the last command of the chain is expected.

#### — If SW1-SW2 is set to '6884', then command chaining is not supported.

#### 5.3.4 Response chaining

#### SW1 = '61' and get response support the transmission of an oversized response payload:

#### — All CLA bytes of the commands involved in response chaining shall be the same. By definition

#### response chaining starts with that C-RP where SW1 is set to '61'.

#### — With the exception of the first command APDU of the sequence, all INS P1-P2 bytes of the command

#### APDUs shall be 'C0 00 00' (get response).

#### — As in command chaining, payload transmission shall be interrupted by any C-RP different from get

#### response, or by any C-RP on another logical channel.

#### — Contrary to command chaining, this possible termination is normal when the outside world considers

#### that it has received enough data: the exchange should continue normally with an arbitrary C-RP.


#### — However, this document does not define the behaviour of the card if the outside world tries to

#### resume response chaining after e.g. the execution of a command on another logical channel. The

#### behaviour may be defined by the application.

#### If defined by the application, response chaining may be used for checking the availability of data, which

#### are not necessarily required. The card may indicate availability by SW1-SW2 = '61XY', without sending

#### any response data; the outside world will or will not send one or more get response commands.

#### In Figure 1, c= 0 and c=1 indicates the value of bit b5 of CLA. Lcmax indicates the maximum value of short

#### or extended Lc field the ICC supports.

#### WARNING — This is an example where the interface device chooses to send the longest command

#### data fields the card supports, and to recover all data made available by the card. None of those

#### choices is mandated.

#### Figure 1 — Transmission to the card of an oversize command payload using command chaining,

#### followed by the transmission by the card of an oversize response payload using response

#### chaining

### 5.4 Class byte

#### 5.4.1 Coding

#### CLA indicates the class of the command. Bit b8 of CLA distinguishes between the interindustry class

#### and the proprietary class.

#### — Bit b8 set to 0 indicates the interindustry class.

#### — Bit b8 set to 1 indicates the proprietary class, except for the value 'FF' which is invalid due to

#### specifications in ISO/IEC 7816-3. The application-context defines the other bits of CLA in

#### proprietary class.

#### The values 000x xxxx and 01xx xxxx are specified hereafter. The values 001x xxxx are RFU.

#### Table 2 specifies 000x xxxx as the first interindustry values.

#### — Bits b8, b7 and b6 are set to 000.

#### — Bit b5 controls command chaining (see 5.3.3).

#### — Bits b4 and b3 indicate secure messaging (see Clause 10 ).

#### — Bits b2 and b1 encode a logical channel number from zero to three (see 5.4.2).


#### Table 2 — First interindustry values of CLA

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 0 0 x - - - - Command chaining control (see 5.3.3)
0 0 0 0 - - - - — The command is the last or only command of a chain
0 0 0 1 - - - - — The command is not the last command of a chain
0 0 0 - x x - - Secure messaging indication
0 0 0 - 0 0 - - — No SM or no indication
0 0 0 - 0 1 - - — Proprietary SM format
0 0 0 - 1 0 - - — SM according to Clausecommand header not processed according to 10.3.3.2^10 ,^
```
```
0 0 0 - 1 1 - - — SM according to Clausecommand header authenticated according to 10.3.3.2^10 ,^
0 0 0 - - - x x Logical channel number from zero to three (see 5.4.2)
```
#### Table 3 — Further interindustry values of CLA

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 1 x - - - - - Secure messaging indication
0 1 0 - - - - - — No SM or no indication
0 1 1 - - - - - — SM according to Clausecommand header not processed according to 10.3.3.2^10 ,^
0 1 - x - - - - Command chaining control (see 5.3.3)
0 1 - 0 - - - - — The command is the last or only command of a chain
0 1 - 1 - - - - — The command is not the last command of a chain
0 1 - - x x x x Logical channel number from four to nineteen (see 5.4.2)
```
#### Table 3 specifies 01xx xxxx as further interindustry values.

#### — Bits b8 and b7 are set to 01.

#### — Bit b6 indicates secure messaging (see Clause 10 ).

#### — Bit b5 controls command chaining (see 5.3.3).

#### Bits b4 to b1 encode a number from zero to fifteen; this number plus four is the logical channel number

#### from four to nineteen (see 5.4.2).

#### 5.4.2 Logical channels

#### This clause specifies a mechanism whereby in the interindustry class, C-RPs can refer to logical

#### channels. Each logical channel has its own security status (see 9.3) and validity area (see 7. 2). The way

#### to share a security status is out of scope of this document.

#### If the card supports the mechanism, then it shall indicate the maximum number of available logical

#### channels (see Table 127 , third software function table) in the historical bytes (see 12.2.2) or in EF .ATR/

#### INFO (see 12.3.3).

#### — If the indicated number is four or less, then only Table 2 applies.

#### — If the indicated number is five or more, then Table 3 also applies.

#### For referring to logical channels in the interindustry class, the following rules apply.

#### — CLA encodes the number of the logical channel of the C-RP.


#### — Enabling the physical interface (see 5.1) opens the basic logical channel, which shall remain open

#### until disabling of the physical interface. It may be reset (see below). The number of the basic logical

#### channel is zero.

#### — Cards not supporting additional logical channel(s) (default value) shall use only the basic logical

#### channel.

#### — Any additional logical channel shall be opened by completion of either a select or a select data

#### command (see 11.2.2 and 11.5.2) where CLA encodes the number of a logical channel not yet in use,

#### or a manage channel command with open function (see 11.2.3).

#### — Any additional logical channel can be closed by the completion of a manage channel command

#### with close function (see 11.2.3). After closing, the logical channel shall be available for re-use.

#### — Even if more than one logical channel is opened there shall be no interleaving of C-RPs (see 5.2).

#### — If shareability is not explicitly excluded by the file descriptor byte (see bit b7 in Table 12 ), more

#### than one logical channel may be opened to the same structure (see clause 7 ), i.e. to a DF, possibly an

#### application DF, and also possibly to an EF.

#### — If shareability is not explicitly excluded by the data descriptor byte (see bit b7 in Table 14 ) more

#### than one logical channel may be opened to the same DO.

#### — Any logical channel can be reset by the completion of a manage channel command with reset

#### function (see 11.2.3).

### 5.5 Instruction byte

#### INS indicates the command to process. Due to specifications in ISO/IEC 7816-3, the values '6X' and '9X'

#### are invalid.

#### Table 4 and Table 5 list all the commands specified in ISO/IEC 7816 (all parts)[4] and

#### ISO/IEC 18328 (all parts)[20] at the time of publication.

#### — Table 4 lists the command names in the alphabetic order.

#### — Table 5 lists the INS codes in the numeric order.

#### ISO/IEC 7816 (all parts)[4] and ISO/IEC 18328 (all parts)[20] specify the use of those commands in the

#### interindustry class.

#### — This document specifies commands for interchange (see Clause 11 ).

#### — ISO/IEC 7816-7 specifies commands for structured card query language (SCQL).

#### — ISO/IEC 7816-8 specifies commands for security operations.

#### — ISO/IEC 7816-9 specifies commands for card management.

#### — ISO/IEC 7816-11 specifies commands for personal verification through biometric methods.

#### — ISO/IEC 7816-13 specifies commands for application management in a multi-application

#### environment.

#### — specifies commands for ICC-managed devices.

#### In the interindustry class, bit b1 of INS indicates a data field format as follows.

#### — If bit b1 is set to 0 (even INS code), then no indication is provided.

#### — If bit b1 is set to 1 (odd INS code), payloads (if any) shall be encoded in ber-tlv (se e 8.1).


#### Table 4 — Commands in the alphabetic order

```
Command name INS See Command name INS See
```
activate (file) '44' I S O/ IEC 7816-9 manage channel '70' 11.2.3

activate record (s) '08' 11.4.9 manage data 'CF' I S O/ IEC 7816-9

aditional device management '16', '17' 18328-3I S O/ IEC manage security environment '22' 11.6.11

append record 'E2' 11.4.6 perform biometric operation '2E', '2F' 7816 -11I S O/ IEC

application management
request '40', '41'

##### I S O/ IEC

```
7816 -13 perform scql operation '10'
```
##### I S O/ IEC

##### 7816 -7

change reference data '24', '25' 11.6.7 perform security operation '2A', '2B' I S O/ IEC 7816-8

compare '33' 11 .7.1 perform transaction operation '12' I S O/ IEC 7816 -7

create 'E1' I S O/ IEC 7816-9 perform user operation '14' I S O/ IEC 7816 -7

create file 'E0' I S O/ IEC 7816-9 put data 'DA', 'DB' 11.5.6

deactivate (file) '04' I S O/ IEC 7816-9 put next data 'D8', 'D9' 11.5.7

deactivate record (s) '06' 11.4.10 read binary 'B0', 'B1' 11.3.3

delete data 'EE' I S O/ IEC 7816-9 read record (s) 'B2', 'B3' 11.4.3

delete (file) 'E4' I S O/ IEC 7816-9 remove application 'EC', 'ED' 7816 -13I S O/ IEC

disable verification require-
ment '26' 11.6.9 reset retry counter '2C', '2D' 11.6.10
enable verification require-
ment '28' 11.6.8 search binary 'A0', 'A1' 11.3.6
envelope 'C2', 'C3' 11.8.2 search record 'A2' 11.4.7
erase binary '0E', '0F' 11.3.7 select 'A4' 11.2.2
erase record (s) '0C' 11.4.8 select data 'A5' 11.5.2
external (/mutual) authen-
ticate '82' 11.6.4 terminate card usage 'FE'

##### I S O/ IEC

##### 7816-9

general authenticate '86', '87' 11.6.5 terminate (df) 'E6' I S O/ IEC 7816-9

generate asymmetric key pair '46', '47' I S O/ IEC 7816-8 terminate ef 'E8' I S O/ IEC 7816-9

get attribute '34', '35' 11 .7. 2 update binary 'D6', 'D7' 11.3.5
get challenge '84' 11.6.3 update data 'DE', 'DF' 11.5.8
get data/get next data 'CA'/'CC' 11.5.3 update record 'DC', 'DD' 11.4.5
get data/get next data 'CB'/'CD' 11.5.4 verify '20', '21' 11.6.6
get response 'C0' 11.8.1 write binary 'D0', 'D1' 11.3.4

import card secret '48' I S O/ IEC 7816-9 write record 'D2' 11.4.4

internal authenticate '88' 11.6.2 — In the interindustry class, any valid INS code
not defined in ISO/IEC 7816 (all parts)[4] or
load application 'EA', 'EB' ISO/IEC 18328 (all parts)[20] is RFU.

##### I S O/ IEC

##### 7816 -13


#### Table 5 — Commands in the numeric order

**INS Command name See INS Command name See**
'04' deactivate (file) I S O/ IEC 7816-9 'A2' search record 11.4.7
'06' deactivate record (s) 11.4.10 'A4' select 11.2.2
'08' activate record (s) 11.4.9 'A5' select data 11.5.2
'0C' erase record (s) 11.4.8 'B0', 'B1' read binary 11.3.3
'0E', '0F' erase binary 11.3.7 'B2', 'B3' read record (s) 11.4.3

```
'10' perform scql operation I S O/ IEC 7816 -7 'C0' get response 11.8.1
```
```
'12' perform transaction operation I S O/ IEC 7816 -7 'C2', 'C3' envelope 11.8.2
```
```
'14' perform user operation I S O/ IEC 7816 -7 'CA'/'CC' get data/get next data 11.5.3
```
```
'16', '17' additional device management 18328-3I S O/ IEC 'CB'/'CD' get data/get next data 11.5.4
```
```
'20', '21' verify 11.6.6 'CF' manage data I S O/ IEC 7816-9
'22' manage security environment11.6.11 'D0', 'D1' write binary 11.3.4
'24', '25' change reference data 11.6.7 'D2' write record 11.4.4
'26' disable verification requirement - 11.6.9 'D6', 'D7' update binary 11.3.5
```
```
'28' enable verification requirement - 11.6.8 'D8', 'D9' put next data 11.5.7
```
'2A', '2B' perform security operation I S O/ IEC 7816-8 'DA', 'DB' put data 11.5.6

'2C', '2D' reset retry counter 11.6.10 'DC', 'DD' update record 11.4.5

'2E', '2F' perform biometric operation I S O/ IEC 7816 -11 'DE', 'DF' update data 11.5.8

```
'33' compare 11 .7.1 'E0' create file I S O/ IEC 7816-9
```
```
'34', '35' get attribute 11 .7. 2 'E1' create I S O/ IEC 7816-9
```
```
'40', '41' application management request I S O/ IEC 7816 -13 'E2' append record 11.4.6
```
```
'44' activate (file) I S O/ IEC 7816-9 'E4' delete (file) I S O/ IEC 7816-9
```
```
'46', '47' generate asymmetric key pair I S O/ IEC 7816-8 'E6' terminate (df) I S O/ IEC 7816-9
```
```
'48' import card secret I S O/ IEC 7816-9 'E8' terminate ef I S O/ IEC 7816-9
```
```
'70' manage channel 11.2.3 'EA', 'EB' load application 7816 -13I S O/ IEC
```
```
'82' external (/mutual) authenticate - 11.6.4 'EE' delete data I S O/ IEC 7816-9
```
```
'84' get challenge 11.6.3 'EC', 'ED' remove application 7816 -13I S O/ IEC
```
```
'86', '87' general authenticate 11.6.5 'FE' terminate card usage I S O/ IEC 7816-9
'88' internal authenticate 11.6.2 — In the interindustry class, any valid INS code
not defined in ISO/IEC 7816 (all parts)[4] or
'A0', 'A1' search binary 11.3.6 ISO/IEC 18328 (all parts)[20] is RFU.
```

### 5.6 Status bytes

#### SW1-SW2 indicates the processing state. Due to specifications in ISO/IEC 7816-3, any value different

#### from '6XXX' and '9XXX' is invalid; any value '60XX' is also invalid.

#### The values '61XX', '62XX', '63XX', '64XX', '65XX', '66XX', '68XX', '69XX', '6AXX' and '6CXX' are

#### interindustry. Due to specifications in ISO/IEC 7816-3, the values '67XX', '6BXX', '6DXX', '6EXX', '6FXX'

#### and '9XXX' are proprietary, except the values '6700', '6701', '6702', '6B00', '6D00', '6E00', '6F00' and

#### '9000' that are interindustry.

#### Figure 2 shows the structural scheme of the values '9000' and '61XX' to '6FXX' for SW1-SW2.

#### Figure 2 — Structural scheme of values of SW1-SW2

#### All interindustry values of SW1-SW2 are independent from any transmission protocol. Table 6 lists all

#### the interindustry values of SW1-SW2 and shows their general meaning. ISO/IEC JTC 1/SC 17 reserves

#### for future use any interindustry value of SW1-SW2 not defined in ISO/IEC 7816 (all parts)[4]. Table 7

#### lists all the specific interindustry warning and error conditions used in ISO/IEC 7816 (all parts)[4] at the

#### time of publication.

#### Table 6 — General meaning of the interindustry values of SW1-SW2

```
SW1-SW2 Meaning
Normal
processing
```
```
'9000' No further qualification
'61XX' SW2 encodes the number of data bytes still available (see text below)
```
```
Warning
processing
```
```
'62XX’ State of non-volatile memory is unchanged (further qualification in SW2, see Table 7 )
'63XX' State of non-volatile memory may have changedTable 7 ) (further qualification in SW2, see
```
```
Execution
error
```
```
'64XX' State of non-volatile memory is unchanged (further qualification in SW2, see Table 7 )
'65XX' State of non-volatile memory may have changedTable 7 ) (further qualification in SW2, see
'66XX' Security-related issues (further qualification in SW2 is RFU)
```
```
Checking
error
```
```
'67XX' Wrong length (further qualification in SW2, see Table 7 )
'68XX' Functions in CLA not supported (further qualification in SW2, see Table 7 )
'69XX' Command not allowed (further qualification in SW2, see Table 7 )
'6AXX' Wrong parameters P1-P2 (further qualification in SW2, see Table 7 )
'6B00' Wrong parameters P1-P2
'6CXX' Wrong Le field; SW2 encodes the exact number of available data bytes (see text below)
'6D00' Instruction code not supported or invalid
'6E00' Class not supported
'6F00' No precise diagnosis
```
#### If SW1 is set to '61', then the process is completed and before issuing any other command, a get response

#### command may be issued with the same CLA and using SW2 (number of data bytes still available) as

#### short Le field. If the C-RP which returned '61XY' used the extended length fields, the get response may


#### also use an extended Le field according to the buffer sizes stated in DO'7F66' (see 12.8.1). This feature is

#### used for response chaining (see 5.3.4).

#### If SW1 is set to '6C', then the process is aborted and before issuing any other command, the same

#### command may be re-issued using SW2 (exact number of available data bytes) as short Le field.

#### If the process is aborted with a value of SW1 from '64' to '6F', then the response data field shall be absent.

#### If SW1 is set to '63' or '65', then the state of the non-volatile memory may have changed. If SW1 is set to

#### '6X' except for '63' and '65', then the state of the non-volatile memory is unchanged.

#### When command chaining is used for payload fragmentation (see 5.3.3), in response to a command that

#### is not the last command of a chain (see 5.3.3), interindustry warning indications are prohibited (see

#### also ISO/IEC 7816-3), i.e. SW1 shall be set to neither '62' nor '63'.

#### Table 7 — Specific interindustry warning and error conditions

```
SW1 SW2 Meaning
```
##### '62'

```
(war n-
ing)
```
```
'00' No information given
'02' to '80' Triggering by the card (see 12.6.2)
'81' Part of returned data may be corrupted
'82' End of file, record or DO reached before reading Ne bytes, or unsuccessful search.
'83' Selected file deactivated
'84' File or data control information not formatted according to 7. 4
'85' Selected file or DO in termination state
'86' No input data available from a sensor on the card
'87' At least one of the referenced records is not processwd for some reason, e.g. record deactivated, security status not satisfied or conditions of use not satisfied
```
```
'63'
(war n-
ing)
```
```
'00' No information given
'40' Unsuccessful comparison
'81' File or DO filled up by the last write
'CX' Counter from 0 to 15 encoded by 'X' (exact meaning depends on the command)
```
##### '64'

```
(er r or)
```
```
'00' No information given
'01' Immediate response required by the card
'02' to '80' Triggering by the card (see 12.6.2)
'81' Logical channel shared access denied
'82' Logical channel opening denied
'65'
(er r or)
```
```
'00' No information given
'81' Memory failure
'66'
(er r or) '00' No information given, any other value is RFU
'67
(er r or)
```
```
'00' No information given
'01' Command APDU format not compliant with this standard (see 5.1)
'02' The value of Lc is not the one expected.
```
##### '68'

```
(er r or)
```
```
'00' No information given
'81' Logical channel not supported
'82' Secure messaging not supported
'83' Last command of the chain expected
'84' Command chaining not supported
NOTE Any other value of SW2 is RFU.
```

```
SW1 SW2 Meaning
```
##### '69'

```
(er r or)
```
```
'00' No information given
'81' Command incompatible with file structure
'82' Security status not satisfied
'83' Authentication method blocked
'84' Reference data not usable
'85' Conditions of use not satisfied
'86' Command not allowed (curEF not set)
'87' Expected secure messaging DOs missing
'88' Incorrect secure messaging DOs
```
##### '6A'

```
(er r or)
```
```
'00' No information given
'80' Incorrect parameters in the command data field
'81' Function not supported
'82' File or application not found
'83' Record not found
'84' Not enough memory space in the file
'85' Nc inconsistent with tlv structure
'86' Incorrect parameters P1-P2
'87' Nc inconsistent with parameters P1-P2
'88' Referenced data, reference data or DO not found (exact meaning depending on the command)
'89' File already exists
'8A' DF name already exists
NOTE Any other value of SW2 is RFU.
```
## 6 Data objects

### 6.1 General

#### This clause specifies two categories of data objects: simple-tlv data objects and ber-tlv data objects,

#### the latter abbreviated by DOs in this document.

### 6.2 SIMPLE-TLV data objects............................................................................................................................................................

#### Each simple-tlv data object shall consist of two or three consecutive fields: a mandatory tag field, a

#### mandatory length field and a conditional value field. A record (see 11.4.1) may be a simple-tlv data object.

#### — The tag field consists of a single byte encoding a tag number from 1 to 254. The values '00' and 'FF'

#### are invalid for tag fields. If a record is a simple-tlv data object, then the tag may be used as record

#### identifier.

#### — The length field consists of one or three consecutive bytes.

#### — If the first byte is not set to 'FF', then the length field consists of a single byte encoding a number

#### from zero to 254 and denoted N.

#### — If the first byte is set to 'FF', then the length field continues on the subsequent two bytes with any

#### value encoding a number from zero to 65 535 and denoted N.

#### — If N is zero, there is no value field, i.e. the data object is empty. Otherwise (N > 0), the value field

#### consists of N consecutive bytes.

#### Table 7 (continued)


NOTE This document defines neither tag values nor value fields of simple-tlv data objects. Hence, simple-
tlv data objects addressing cannot be used for interchange.

### 6.3 BER-TLV data objects

#### Each ber-tlv data object (DO) consists of two or three consecutive fields (see the basic encoding rules

#### of ASN.1 in ISO/IEC 8825-1): a mandatory tag field a mandatory length field and a conditional value

#### field. Any non-empty DO is denoted {T-L-V}.

#### The tag field consists of one or more consecutive bytes. It indicates a class and an encoding and it

#### encodes a tag number. The value '00' is invalid for the first byte of tag fields. ISO/IEC 7816 (all parts)[4]

#### supports tag fields of one, two and three bytes; longer tag fields are RFU.

#### The length field encodes a length, i.e. a number denoted N, according to ISO/IEC 8825-1. If N is zero,

#### there is no value field, i.e. the DO is empty, and noted {T-'00'}. Otherwise (N > 0), the value field consists

#### of N consecutive bytes, and the DO is noted {T-L-V}. ISO/IEC 7816 (all parts)[4].

#### a) precludes the use of the “indefinite length” (coded '80'), according to the DER encoding rules;

#### b) recommends to use the shortest possible coding of the length field, according to DER encoding

#### rules (see ISO/IEC 8825-1);

#### c) uses length fields consisting of one to five bytes, longer length fields are RFU.

NOTE 1 In order to ascertain the length of the length field, b) is provided, i.e. the use of shortest length field for
the coding of a given length.

NOTE 2 ISO/IEC 7816-4 uses '80' with a specific meaning in the length field of an extended header DO (see 8.4.5).

NOTE 3 Annex E provides the detailed coding of tag and length fields.

### 6.4 Constructed DOs versus primitive DOs

#### A constructed, non-empty DO is denoted {T-L-{T1-L1-V1} ... - {Tn-Ln-Vn}}. Its tag T indicates the

#### structure of its value field (see Annex E). This value field is called a template, which may either:

#### — consist of one DO, called "nested" in the constructed DO, or

#### — consist of a concatenation of several nested DOs, (n DOs in the example above), without padding

#### (se e 8.1.2).

#### Unless otherwise specified [e.g. wrapper (see 8.4.8) or tagged wrapper (see 8.4.9), ISO/IEC 7816-15,

#### ISO/IEC 24727 (all parts)[21]], the order of DOs within a template is not defined in this document.

#### See Annex E for the identification of a primitive or constructed data object by the first byte of its tag. A

#### possible structure of the value field of a primitive data object is to be defined elsewhere.

## 7 Structures for applications and data

### 7.1 Available structures

#### This clause specifies structures for applications and data, as seen at the interface when processing

#### commands in the interindustry class. The actual storage location of data and structural information


#### beyond what is described in this clause is out of scope of ISO/IEC 7816 (all parts)[4]. The following

#### structures are supported:

#### — Dedicated file (DF):

#### The DFs host applications and/or group files and/or store DOs. An application DF is a DF hosting an

#### application. A DF may be the parent of other structures, whose types shall belong to the following

#### set {DF, EF, DO}. These other structures are said to be immediately under the DF.

#### — Elementary file (EF):

#### The EFs store data. An EF may be the parent of other structures, whose types shall belong to the

#### following set {DO, Record, DataString}. These other structures are said to be immediately under

#### the EF. Two categories of EFs are specified.

#### — An internal EF stores data interpreted by the card, i.e. data used by the card for management

#### and control purposes.

#### — A working EF stores data not interpreted by the card, i.e. data used by the outside world

#### exclusively.

#### — Record:

#### The records store data. A record may be the parent of other structures, whose types shall belong to

#### the following set {DO}. These other structures are said to be immediately under the record.

#### — DataString:

#### DataStrings store data. A DataString is a sequence of bytes in a transparent EF. A DataString may

#### be the parent of other structures, whose types shall belong to the following set {DO}. These other

#### structures are said to be immediately under the DataString.

#### — Data object (DO):

#### The DOs store data. A DO may be the parent of other structures, whose types shall belong to the

#### following set {DO}. These other structures are said to be immediately under the DO.

#### Two types of logical organization are provided.

#### — Figure 3 illustrates a hierarchy of DFs with its corresponding security architecture (see Clause 9 ).

#### In such a card organization, the DF at the root is called the master file (MF); any DF may be an

#### application DF, with or without its own hierarchy of DFs.

#### Figure 3 — Example of hierarchy of DFs

#### — Figure 4 illustrates application DFs in parallel, with no MF seen at the interface, i.e. without any

#### apparent hierarchy of DFs. Such an organization supports independent applications in the card

#### where any application DF may have its own hierarchy of DFs with its corresponding security

#### architecture.


#### Figure 4 — Example of independent application DFs

### 7.2 Validity area

#### 7.2.1 Definitions and attributes

#### The validity area (VA) on a logical channel is the result of all successful selections performed on that

#### logical channel. The VA determines the resolution of DO tags and file identifiers. The VA consists of:

#### — curAppDF: a reference either to a DF or an application DF. It is always set.

#### — curDF: a reference to a DF, which may be an application DF. It is always set.

#### — curEF: a reference to an EF belonging to the DF referenced by curDF. It is not always set.

#### — curFile: a reference to a file, it is always set. Its value shall be identical to curDF if curEF is not set,

#### and identical to curEF if curEF is set.

#### — curRecord: a reference to a record, belonging to an EF referenced by curEF structured in records. It

#### is not always set.

#### — curDataString: a reference to a sequence of bytes being part of a transparent EF referenced by curEF.

#### It is not always set.

#### — curConstructedDO: it shall be set for DO handling. When set, it is a reference to a constructed DO. It

#### is not always set.

#### — curPrimitiveDO: a reference to a primitive DO whose parent is referenced by curConstructedDO. It

#### is not always set.

#### — curDO: It shall be set for DO handling. When set, it is a reference to a DO, its value shall be

#### identical to curConstructedDO if curPrimitiveDO is not set, and identical to curPrimitiveDO if

#### curPrimitiveDO is set.

NOTE 1 curFile can be calculated from curDF and curEF and vice versa. Thus either curFile is dispensable or
curDF and curEF are dispensable. The reason for redundancy is that some functions are easier to describe with
curFile (e.g. activate (file), deactivate (file)) and other functions are easier to describe with curDF and curEF.

NOTE 2 curDO can be calculated from curConstructedDO and curPrimitiveDO and vice versa. Thus either
curDO is dispensable or curConstructedDO and curPrimitiveDO are dispensable. The reason for redundancy
is that some functions are easier to describe with curDO and other functions are easier to describe with
curConstructedDO and curPrimitiveDO.

NOTE 3 The current SE (see 10.3.3) does not belong to the current VA.

#### 7.2.2 Basic rules for VA handling and use

#### The following is a non-exhaustive list of rules describing the use of the VA. More rules are given in

#### clauses containing command descriptions:

#### a) Enabling a physical interface (see 5.1), which opens the basic logical channel, sets the values of

#### curAppDF and curDF to identical values, i.e. they reference either the MF or the implicitly selected

#### application.

#### b) Resetting a logical channel resets the VA to the same value set when opening that logical channel.

#### See 11.2.3 for other consequences of resetting.


#### c) Opening a logical channel sets the values of curAppDF and curDF to identical values (see 11.2.2 and

#### 11.2.3).

#### d) Selecting an application DF sets curDF and curAppDF so that they reference the selected

#### application DF.

#### e) Selecting a DF which is not an application DF sets curDF so that it references the selected DF. It sets

#### or confirms curAppDF so that curAppDF references either the nearest application DF (if any) in the

#### ancestors (parent, grandparent...) of the selected DF, or the MF if no application DF exists in the

#### ancestors.

#### f) Selecting an EF sets curEF so that it references the selected EF, and curDF so that it references the

#### parent of the selected EF [see rule e)]. When EF selection occurs as a side-effect of a C-RP using

#### referencing by short EF identifier, curEF may change, while curDF does not change.

#### g) Selecting a record sets curRecord so that it references the selected record, and curEF so that it

#### references the parent of the selected record [see rule f )].

#### h) Selecting a DataString within a transparent EF sets curDataString so that it references the selected

#### DataString and curEF so that it references the parent of the selected DataString [see rule f )].

#### i) Selecting a structure containing DOs sets curConstructedDO so that it references the selected

#### DO according to the specified structure. If the selected structure is a constructed DO, it sets

#### curConstructedDO so that it references the selected DO. If the specified structure is a {Application

#### DF, DF, EF, record or DataString}, structure selection sets curConstructedDO so that it references a

#### virtual root DO'7F70'. This DO shall be associated with the last encountered structure supporting

#### DOs in the list above.

#### j) Selecting a primitive DO sets curPrimitiveDO so that it references the specified DO, and

#### curConstructedDO so that it references the parent of the selected primitive DO.

#### An explicit selection may modify elements of the VA beyond the explicit selection due to recursion. Such

#### implicit selections shall have the same outcome as an explicit selection.

EXAMPLE The selection of a constructed DO in a record will set curConstructedDO [rule i)] explicitly. It will
implicitly set or confirm curRecord [rule g)], curEF [rule f)], curDF [rule e)] and curAppDF [rule d)].

### 7.3 Structure selection

#### 7.3.1 Structure selection methods

#### Selecting a structure allows access to its data and to structures below, if any. Structures may be selected

#### implicitly, i.e. automatically [see 7.2.2, rules a), g)] after enabling a physical interface (see 5.1). When a

#### structure cannot be implicitly selected, it shall be selected explicitly, i.e. by at least one of the following

#### four methods.

#### Selection by DF name — A DF name may reference any DF. It is a string of up to sixteen bytes. Any

#### application identifier (AID, see 12.3.4) may be used as DF name. In order to select unambiguously by

#### DF name, e.g. when selecting by means of application identifiers, each DF name shall be unique within a

#### given card.

#### Selection by file identifier — A file identifier may reference any file. It consists of two bytes. The value

#### '3F00' is reserved for referencing the MF. The value 'FFFF' is reserved (see 11.5.1.2). The value '3FFF'

#### is reserved (see below and 11.5.1.2). The value '0000' is reserved (see 11.3.2 and 11.5.1.2). The values

#### ‘2F00’ and ‘2F01’ are reserved immediately under MF (see 12.3.2 and 12.3.3). In order to unambiguously

#### select any file by its identifier, all EFs and DFs immediately under a given DF shall have different file

#### identifiers.

#### Selection by path — A path may reference any file. It is a concatenation of file identifiers. The path

#### begins with the identifier of a DF (the MF for an absolute path or the DF referenced by curDF for a

#### relative path) and ends with the identifier of the file itself. Between those two identifiers, the path


#### consists of the identifiers of the successive parent DFs, if any. The order of the file identifiers is always

#### in the direction parent to child. If the identifier of the DF referenced by curDF is not known, then the

#### value '3FFF' (reserved value) can be used at the beginning of the path. The path allows an unambiguous

#### selection of any file from the MF or from the DF referenced by curDF (see 12.4).

#### Selection by short EF identifier — A short EF identifier may reference any EF. It consists of five bits

#### not all equal, i.e. any number from one to thirty. When used as short EF identifier, the number zero, i.e.

#### 00000 in binary, references the EF referenced by curEF. At MF level, the number thirty, i.e. 11110 in

#### binary, is reserved (see 12.3.2). Short EF identifiers cannot be used in a path or as a file identifier (e.g.

#### in a select command). All short EF identifiers of EF immediately under a given DF plus all short EF

#### identifiers indicated in FCP DO'A2' associated with this DF shall be unique.

#### If supported, selection by short EF identifier shall be indicated.

#### — If the first software function table (see Table 125 ) is present in the historical bytes (see 12.2.2) or in

#### EF .ATR/ INFO (see 12.3.3), then the indication is valid at card level.

#### — If a short EF identifier DO'88' (see 7.4.4 and Table 11 ) is present in the CPs of an EF, then the indication

#### is valid at EF level.

#### Selection by tag — A DO may be selected by its sole tag, without further information on the VA, if and

#### only if it belongs to the base template of the DO referenced by curConstructedDO.

#### Selection by record identifier — If the EF referenced by curEF supports records then a record

#### identifier provided by an application may reference a specific record in that EF.

#### Selection by record number — If the EF referenced by curEF supports records then a record number

#### references a specific record in that EF. A record number is a positive integer.

#### Selection by offset — If the EF referenced by curEF is transparent, then an offset references the

#### beginning of a sequence of bytes in that EF. An offset is an integer ≥ 0.

#### 7.3.2 File reference data element and DO

#### This interindustry DO'51' (see Table 8 ) references a file. It may have any length.

#### — An empty DO references the MF.

#### — If the length is one and if bits b8 to b4 of the data element are not all equal and if bits b3 to b1 are set

#### to 000, then bits b8 to b4 encode a number from one to thirty that is a short EF identifier.

#### — If the length is two, then the data element is a file identifier.

#### — If the length is more than two, then the data element is a path.

#### — If the length is even and if the first two bytes are set to '3F00', then the path is absolute. The data

#### element is a concatenation of at least two file identifiers starting with the MF identifier.

#### — If the length is even and if the first two bytes are not set to '3F00', then the path is relative. The

#### data element is a concatenation of at least two file identifiers starting with the identifier of the

#### DF referenced by curDF.

#### — If the length is odd, then the path is qualified. The data element is either an absolute path without

#### '3F00', or a relative path without the identifier of the DF referenced by curDF, followed by a byte

#### to use as P1 in one or more select commands (see 11.2.2 and 12.4).


#### Table 8 — Coding of the file reference DO'51'

```
Tag Length Value
```
##### '51'

```
0 The empty data object references the MF
1 Short EF identifier (bits b8 to b4 encode a number from one to thirty; bits b3 to b1 are set to 000)
2 File identifier
```
```
Even, > 2
```
```
Absolute path (the first two bytes are set to '3F00')
Relative path (the first two bytes are not set to '3F00')
Odd, > 2 Qualified path (the last byte shall be used as P1 in one or more select com ma nd s)
```
#### 7.3.3 General reference data element and DO

#### This interindustry DO'60' (see Table 94 ) and DO'7F72' (see Table 38 ) can reference any structure in a

#### card. The value of DO'60' is used in the command data field of many C-RPs handling DOs (see 11.5.2).

#### 7.3.4 Data referencing methods in elementary files

**Key**
1) transparent structure
2) linear structure with records of fixed size
3) linear structure with records of variable size
4) cyclic structure with records of fixed size (the arrow references the most recently written record)
5) simple-tlv or ber-tlv structure

#### Figure 5 — EF structures

#### Data referencing method is an EF-dependent feature. An EF shall support at least one of the following

#### structures:

#### — Transparent structure — The EF is seen at the interface as a single continuous, numbered

#### sequence of data units accessible by commands for handling data units (see 11.3). Data unit size is

#### an EF-dependent feature.

#### — Record structure — The EF is seen at the interface as a single continuous sequence of individually

#### identifiable records accessible by commands for handling records (see 11.4). Record numbering

#### method, simple-tlv or ber-tlv structure of the records are EF-dependent features. Three attributes

#### are defined: record size, record organization and record LCS.

#### — The size of the records is either fixed, or variable.

#### — The organization of the records is either a sequence (linear structure), or a ring (cyclic structure).

#### — A record may have a record life cycle. When it does, the record LCS distinguishes at least the

#### following states: ACTIVATED and DEACTIVATED. The coding of a record LCS is out of scope for

#### this document. Within a given EF, either all records have a record life cycle or no record has a

#### record life cycle. The presence of record life cycle is indicated by the CP (see Table 11 ).

#### — simple-tlv structure — The EF is seen at the interface as a set of simple-tlv data objects accessible

#### by commands for handling data objects (see 11.5). This structure precludes ber-tlv structure


#### — ber-tlv structure — The EF is seen at the interface as a set of DOs accessible by commands for

#### handling DOs (see 11.5). This structure precludes simple-tlv structure.

#### In DFs or applications, data may be referenced as DOs (see 6.3), the same way as in EFs. If the EF, DF or

#### application supports this referencing, its selection sets curConstructedDO (see 7.2.2 and 8.2.1).

### 7.4 File and data control information

#### 7.4.1 File control information retrieval...................................................................................................................

#### By definition, the file control information is the byte string available in response to the select command

#### (se e 11.2.2); it may be present for any file, i.e. any DF and any EF.

#### — If the first byte is valued from '00' to 'BF', then the byte string shall be ber-tlv enc o de d. I S O/

#### IEC JTC 1/SC 17 reserves for future use all the values in the range '00' to 'BF' that are not defined in

#### this document.

#### — If the first byte is valued from 'C0' to 'FF', then the byte string is not encoded according to this

#### document.

#### Table 9 shows three interindustry templates:

#### — The FCP template is a set of CP DOs eligible for files, i.e. logical, structural and security attributes

#### as listed in Table 11 and defined hereafter. Within the FCP template, the context-specific class is

#### reserved for FCPs; tags '85' and 'A5' reference proprietary information.

#### — The FMD template is a set of file management data, i.e. interindustry DOs such as an application

#### identifier as defined in 12.3.4, an application label as defined in 12.3.5 and an application expiration

#### date as defined in ISO/IEC 7816-6, possibly nested within an application template as defined in

#### 12.3.5. Within the FMD template, tags '53' and '73' reference discretionary data.

#### — The FCI template is a set of file CPs and file management data.

#### Table 9 — Interindustry templates for file control information

```
Tag Value
'62' Set of file control parameters (FCP template)
'64' Set of file management data (FMD template)
'6F' Set of file control parameters and file management data (FCI template)
```
#### The three templates may be retrieved according to selection options of the select command (see

#### Table 63).

#### — If the FCI option is set, then the FCI tag is optional for introducing the template in the response

#### data field.

#### — If the CP or FMD option is set, then the corresponding tag is mandatory for introducing the template.

#### Part of the control information of a DF may additionally be present in an EF under the control of an

#### application and referenced by tag '87' in the file CPs. If present within such an EF, file control information

#### shall be introduced by the appropriate tag, either a CP tag, or a FCI tag.

#### 7.4.2 Data control information retrieval

#### By definition, the data control information is the byte string available in response to a select command

#### with P1='10' or P1='13' (see 11.2.2) or a select data command if bit b3 of P2 is set to 1 (see 11.5.2); it

#### may be present for any DO. Table 10 shows interindustry template for data control information.


#### Table 10 — Interindustry template for data control information

```
Tag Value
'62' Set of data control parameters (CP DOs, possibly including a DO'62')
```
#### DO'62' nests CP DOs.

#### — It may be present in the data control information of any structure (files or applications supporting

#### a ber-tlv structure, constructed DO). It belongs and applies to the template referenced by

#### curConstructedDO after structure selection.

#### — When present within the current base template (see 8.2.2) it applies to, it may be retrieved by get

#### data or get next data.

#### — When it is present in another template, it may be indirectly referenced by a tagged wrapper (see 8.4.9).

#### 7.4.3 Control parameters

#### Table 11 lists CP DOs for files and data objects, all in the context-specific class. When a CP is present,

#### the table states whether it occurs at most once (explicit indication), or may be repeated (no indication).

#### Table 11 — Control parameter data objects

```
Tag Length Value Applies to
'80' Va r. Number of data bytes in the file, excluding structural information Any EFa
'81' Va r. Number of data bytes in the file or DO, including structural information if any Filea or DOa
```
##### '82'

```
1 File descriptor byte (see 7. 4. 5 and Table 12 )
2 File descriptor byte and data coding byte (see Table 126 ) Filea
3 or 4 File descriptor byte, data coding byte and maximum record size on one or two bytes EFa supporting
records
5 or 6 File descriptor byte, data coding byte, maximum record size on two bytes and number of records on one or two bytes
'83' 2 File identifier Filea
'84' up to 16 DF name DF
'85' Va r. Proprietary information not encoded in ber-tlv File
'86' Va r. Security attribute in proprietary format File
'87' 2 Identifier of an EF containing an extension of the file control information DFa
'88' 0 or 1 Short EF identifier (see 7.4.4) EFa
'8A' 1 Life cycle status (LCS, see 7. 4 .10 and Table 15 ) Filea or DOa
'8B' Va r. Security attribute referencing the expanded format (see Table 39 ) 9.3.4 and Filea
'8C' Va r. Security attribute in compact format, SE oriented (see Table 31 ) Filea
'8D' 2 Identifier of an EF containing security environment templates (see 10.4.4) DF
'8E' 1 Logical channel security attribute (see 9.3.8 and Table 4 8) Filea or DOa
'8F' 1 Profile indicator (see Table 13 ) EF supporting recordsa
```
```
'92' 1 Data descriptor byte (see 7. 4 .7) DO
```
```
a or EFa supporting
ber-tlv structure
'96' Va r. Verification information data object (VIDO) as defined in ISO/IEC 7816-11 see ISO/IEC 7816-11
a The DO shall appear at most once under DO'62'.
NOTE In the response to a select and under tags '62' and '6F', ISO/IEC JTC 1/SC 17 reserves any other DO of the context-
specific class.
```

```
Tag Length Value Applies to
'97' Va r. DF list (see 7. 4. 8) DFa
'98' Va r. Instance number (binary coding) DOa
'99' Va r. Number of DOs in the template referenced by curConstructedDO after file or DO selection (binary coding, see 7.2.2 rule i)). Filea or DOa
'9A' Va r. Number of EFs within a DF (binary coding) DFa
'9B' Va r. EF list (see 7. 4. 8) DFa
'9C' Va r. Security attribute in compact format, SPT oriented (see NOTE It is mainly intended for DO handling. Table^31 ). Filea or DOa
'9D' Va r. Tag of the DO(s) to which DO'62' applies. DO
'A0' Va r. Security attribute template for DOs (see 9.3.6) Filea or DO
'A1' Va r. Security attribute template in proprietary format File
'A2' Va r. Template consisting of one or more pairs of DOs: Short EF identifier (DO'88') - File reference (DO'51', L > 2, see^ 7. 3. 2) DF
'A3' Va r. Interface and LCS dependent security attribute template (see 7. 4 .1 2) File or DO
'A5' Va r. Proprietary information encoded in ber-tlv File
'A6' Va r. Verification information template (VIT) as defined in ISO/IEC 7816-11 see ISO/IEC 7816-11
'AB' Va r. Security attribute template in expanded format (see 9.3.4) Filea
'AC' Va r. Cryptographic mechanism identifier template (see 9.2) DF
'AD' Va r. Security parameters template (see 9. 3 .7.1) DO
'AF' Va r. Template encapsulating one or more DO'06' (OID) relevant to the application. - DFa
a The DO shall appear at most once under DO'62'.
NOTE In the response to a select and under tags '62' and '6F', ISO/IEC JTC 1/SC 17 reserves any other DO of the context-
specific class.
```
#### 7.4.4 Short EF identifier

#### The following rules apply for the use of DO'88' in the CPs of any EF.

#### — If the card supports selection by short EF identifiers (see 7. 3 .1) and if DO'88' is absent, then in

#### the second byte of the file identifier (the value field of DO'83'), bits b5 to b1 encode the short EF

#### identifier.

#### — If DO'88' is present with a length set to zero, then the EF supports no short EF identifier.

#### — If DO'88' is present with a length set to one and if bits b8 to b4 of the value field are not all equal and

#### if bits b3 to b1 are set to 000, then bits b8 to b4 encode the short EF identifier (a number from one

#### to thirty).

#### 7.4.5 File descriptor byte

#### DO'82' may be present in the CPs of any file (see Table 11 ).

#### — The first byte of the value is the file descriptor byte (see Table 12 ).

#### — If the value consists of two or more bytes, then the second byte is the data coding byte (see Table 126 ).

#### If the card provides data coding bytes in several places, then the indication valid for a given file is in

#### the closest position to that file within the path to that file from:

#### 1) The MF, if present.

#### 2) The DF referred to by curAppDF, if the MF is absent.

#### Table 11 (continued)


#### 3) In the absence of indication in the path, the data unit size is set to the default value (see

#### Table 126 ).

#### Table 12 — Coding of the file descriptor byte

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 x - - - - - - File accessibility
0 0 - - - - - - — File non-shareable
0 1 - - - - - - — File shareable
0 - 1 1 1 0 0 0 DF
0 - Not all set to 1 - - - EF category
0 - 0 0 0 - - - — EF for storing data not interpreted by the card (Working EF)
0 - 0 0 1 - - - — EF for storing data interpreted by the card (Internal EF)
0 - Any other
value
```
- - - — Proprietary categories of EFs

```
0 - EF structure
0 - Not all set to 1 0 0 0 — No information given
0 - Not all set to 1 0 0 1 — Transparent structure
0 - Not all set to 1 0 1 0 — Linear structure, fixed size, no further information
0 - Not all set to 1 0 1 1 — Linear structure, fixed size, tlv structure
0 - Not all set to 1 1 0 0 — Linear structure, variable size, no further information
0 - Not all set to 1 1 0 1 — Linear structure, variable size, tlv structure
0 - Not all set to 1 1 1 0 — Cyclic structure, fixed size, no further information
0 - Not all set to 1 1 1 1 — Cyclic structure, fixed size, tlv structure
0 - 1 1 1 0 0 1 — ber-tlv structure
0 - 1 1 1 0 1 0 — simple-tlv structure
NOTE 1 Any other value is RFU.
NOTE 2 “Shareable” means that the file supports concurrent access on different logical channels.
```
#### 7.4.6 Profile indicator

#### The following rules apply for the use of DO'8F' in the file CPs of any EF supporting records:

#### — If DO'8F' is present, then the value field contains a profile indicator according to Table 13 ;

#### — If DO'8F' is absent, then all records in the EF are implicitly in the unchangeable state ACTIVATED.

#### Table 13 — Coding of the profile indicator

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 x x x x x x x Coding of profile indicator defined by ISO/IEC JTC 1/SC 17
0 - - - - - - x Record LCS
0 - - - - - - 0 — All records in this file are in the unchangeable state ACTIVATED
0 - - - - - - 1 — Each record in this EF has its own record LCS, changeable by the commands activate record, deactivate record and activate file
0 x x x x x x - 000000 (any other value is RFU)
1 x x x x x x x Proprietary coding of profile indicator
NOTE 1 Any value is allowed but meaning is RFU.
```

#### 7.4.7 Data descriptor byte

#### Referenced by tag '92', this interindustry data element is a CP DO, which contains information relevant

#### to DO handling (see Table 14 ). The information is valid for all instances (if more than 1) of a DO in the

#### relevant template. If a DO is declared "non-shareable", only one instance of this DO is accessible on one

#### logical channel.

#### Table 14 — Coding of the data descriptor byte

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 x - - - - - - Data accessibility
0 0 - - - - - - — DO non-shareable
0 1 - - - - - - — Shareable DO
0 - x x - - - - structuring of the DOs in the template
0 - 0 0 - - - - — No information given (default).
0 - 0 1 - - - - — Linear management (see 11.5.7)
0 - 1 0 - - - - — Cyclic management of instances (see 11.5.7 )
0 - 1 1 - - - - — RFU
0 - - - x - - - Instances
0 - - - 0 - - - — A tag shall occur at most once in the template.
0 - - - 1 - - - — Tags may occur more than once in the template (default).
0 - - - - x x x DO properties
0 - - - - 0 0 0 — No information given
0 - - - - - - 1 — Tag list presence
0 - - - - - 1 - — Base template extendable by wrappers
0 - - - - 1 1 - — Automatic resolution of wrappers
NOTE 1 Any other value is RFU.
NOTE 2 “Shareable” means that the DO supports concurrent access on different logical channels.
```
#### 7.4.8 DF and EF list data elements

#### Referenced by tag '97', the DF list interindustry data element is a file CP which shows the DFs contained

#### in a DF or application DF. It is a concatenation of 2-byte file identifiers.

#### Referenced by tag '9B', the EF list interindustry data element is a file CP, which contains the identifiers of

#### the elementary files contained in the DF or application DF, and their short EF identifier. The information

#### of each file is coded on three consecutive bytes. The first two bytes contain the file identifier of an EF.

#### The third byte is either the short EF identifier of the EF coded according to 7.4.4 or a byte coded '00' if

#### that elementary file has no short EF identifier.

#### 7.4.9 Instance number data element

#### Referenced by tag '98', this interindustry data element is a CP DO, which may be present only if

#### there are several instances of the DO within its template. Its value shall be a binary coded positive

#### sequence number, as defined by ISO/IEC 8825-1 for the INTEGER type. The numbering scheme for cyclic

#### management of instances is the same as for the management of record numbers (see 11.4.6). See 11.5.7

#### for further information of numbering schemes.

#### 7.4.10 Life cycle status

#### The card, files and other objects, each have a life cycle; the life cycle status (LCS) allows the card and

#### the interface device to identify the different logical security states of the use of the card, files and other

#### objects in the card.


#### To support flexible management of the life cycle of a file, a record or a DO as an attribute (see

#### ISO/IEC 7816-9), this clause defines four primary states of the life cycle in the following order.

#### 1) Creation state

#### 2) Initialisation state

#### 3) Operational state: activated or deactivated

#### 4) Termination state

#### LCS (1 byte) shall be interpreted according to Table 15.

#### — The values '00' to '0F' are interindustry.

#### — The values '10' to 'FF' are proprietary.

#### The default state shall be Operational state (activated).

#### Table 15 — Coding of the file or data LCS byte

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 0 0 0 0 0 0 0 No information given
0 0 0 0 0 0 0 1 Creation state
0 0 0 0 0 0 1 1 Initialisation state
0 0 0 0 0 1 - 1 Operational state (activated)
0 0 0 0 0 1 - 0 Operational state
(de ac t iv at e d)
0 0 0 0 1 1 - - Termination state
Not all zero x x x x Proprietary
NOTE Any other value is RFU.
```
#### Under tag '8A', an LCS may be present in the CPs of any file or DO (see Table 11 ). A card LCS may be

#### present in the historical bytes (see 12.2.2.11). Under tag '48', a card LCS may be present in EF .ATR/ INFO

#### (se e 12.3.3). When it has an MF, the card is in, at least, the creation state.

NOTE Unless otherwise specified, the security attributes are valid if the LCS of:

— files are in Operational state (activated) or Operational state (deactivated),

— DOs are in Operational state (activated) or Operational state (deactivated).

#### 7.4.11 Indirect referencing by short EF identifier using DO'A2'

#### A DO'88' under DO'A2' in the FCP of a DF indicates that the nested short EF identifier is valid when

#### the DF is current. A command using it shall transiently select the EF referenced by the path which is

#### nested in DO'51' after that DO'88'. Its success has no impact on curDF and curAppDF [see 7.2.2 rule f )].

#### The impact on curEF is described in sections dealing with commands using short EF identifier (see e.g.

#### 11.3.2 or 11.4.2).

#### 7.4.12 Interface and life cycle status dependent security attribute template

#### 7.4.12.1 General

#### DO'A3' may be present in the CPs of any file or DO and in such templates it may occur more than once

#### (se e Table 11 ).


#### DO'A3' shall contain at most one DO'91' (see 7. 4 .1 2. 2). If DO'91' is absent then the security attributes

#### contained in DO'A3' apply to all interfaces. If DO'A3' contains a DO'91' it shall be the first DO in the

#### template.

#### DO'A3' shall contain at most one DO'8A' (see 7. 4 .1 2. 3). If DO'8A' is absent then the security attributes

#### contained in DO'A3' apply to all life cycle status. If DO'A3' contains a DO'8A' then it shall be

#### — the first DO in the template if DO'91' is absent, or

#### — the second DO in the template if DO'91' is present.

#### DO'A3' may contain any number of DO'8B', DO'8C', DO'9C', DO'A0', DO'AB' in any order having the same

#### meaning and coding as defined by Table 11.

#### 7.4.12.2 Transport type descriptor

#### Referenced by tag '91' under DO'A3', this data element indicates for which interfaces the security

#### attributes contained in the same DO'A3' apply. See Table 16.

#### Table 16 — Coding of transport type descriptor (DO'91' under DO'A3')

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
x - - - - - - - 0 (any other value is RFU a)
```
- x x - - - - - 00 (any other value is RFU)
- - - 1 - - - - Communication by contact C6 (see ISO/IEC 7816-3)
- - - - 1 - - - Near-field communication (see ISO/IEC 18092[19])
- - - - - 1 - - USB interface (see ISO/IEC 7816-12)
- - - - - - 1 - Contactless interface for proximity cards (see the
    ISO/IEC 14443 series[14])
- - - - - - - 1 Contact interface (see ISO/IEC 7816-3)
a This edition defines the case where one byte is sufficient to reference relevant interfaces. In the
future, more than one byte may be necessary.

#### If in this data element a bit is set to

#### — 1 then for the corresponding interface the security attributes shall apply.

#### — 0 then for the corresponding interface the DO'A3' is irrelevant.

#### 7.4.12.3 Indication of life cycle status

#### Referenced by tag '8A' under DO'A3', this data element indicates for which life cycle status the security

#### attributes contained in the same DO'A3' apply. This data element shall contain one or more bytes and

#### each byte shall be coded and interpreted according to 7. 4 .10 and Table 15 , i.e. each byte encodes a life

#### cycle status and all bytes of the data element build a set of life cycle status. If the life cycle of the file or

#### DO, being given within a DO'8A' in the control parameter template (i.e. the template with tag '62')

#### — is element of this set then the security attributes shall apply for the file or DO.

#### — is not element of this set then the DO'A3' is irrelevant for the file or DO.


## 8 Specific use of DOs and related concepts

### 8.1 ber-tlv payloads and padding..............................................................................................................................................

#### 8.1.1 General...................................................................................................................................................................................

#### A ber-tlv -encoded data field or payload is a concatenation of DOs, with possible padding before or after

#### any of those DOs.

#### There are two standard ways of stating ber-tlv -encoding of a command or response data field or

#### payload:

#### — CLA indicates secure messaging (see Clause 10 ).

#### — Bit b1 of INS is set to 1 (odd INS code).

#### Commands with an even INS code may specify ber-tlv-encoding of data fields and payloads.

#### Within a command payload, this document may define the order of DOs (see e.g. Table 95 ). In a

#### response payload, the order of DOs is either not defined, or is inherited from the order of the DOs

#### present in the card.

#### Because of the coding of ber-tlv length fields (see E.2) a DO with a tag of n bytes cannot have a total

#### length of e.g. (n+1+128) bytes or of (n+2+256) bytes or of (n+3+65536) bytes etc. The situation of invalid

#### total length may also occur if several DOs are to be transmitted and the last DO creates the same

#### problem. In all these cases if receiving a command with Ne set to such an invalid total length the card

#### may send within a response data field containing DO(s) the first Ne bytes requested by the command and

#### conclude with an SW1-SW2 set to '61XY', where 'XY' codes the number of remaining bytes. Afterwards

#### response chaining (see 5.3.4) applies.

#### 8.1.2 Padding conditions

#### The possibility of padding in a data field depends on the command. The terminology "concatenation of

#### DOs" precludes padding. Padding is allowed:

#### — when handling data structures through data units; e.g. padding may be present in a READ BINARY

#### response data field due to erasure or modification of DOs within an EF supporting data units;

#### — when handling data structures through records; e.g. padding may be present in a READ RECORD

#### response data field due to the fixed format of records within an EF supporting records;

#### — when explicitly allowed by a standard C-RP (CLA<'80');

#### — when explicitly allowed by a specification of a C-RP (CLA>'7F').

#### If ber-tlv -encoding is explicitly stated, the data payload(s) shall be ber-tlv encoded, without padding.

#### ber-tlv -encoding shall not apply to the individual data fields (a.k.a. payload fragments) of the

#### commands into which the payload is fragmented, because payload fragmentation is entitled to split

#### DOs. Padding is still precluded in payload fragments.

NOTE Secure messaging can require ber-tlv-encoding of payload fragments (see 10.2).

#### 8.1.3 Padding procedure

#### When padding is allowed in ber-tlv payloads, bytes set to '00' may be present before, between or

#### after DOs.


#### When present in the historical bytes (see 12.2.2) or in EF .ATR/ INFO (see 12.3.3) or in the control

#### information of any file (see tag '82' in Table 11 ), the data coding byte (see Table 126 ) indicates whether

#### the value 'FF' is

#### — valid for the first byte of long tag fields of the private class, constructed encoding (explicit

#### statement), or

#### — invalid for the first byte of tag fields (default value), i.e. used for the same purpose (padding) and

#### under the same conditions as the value '00'.

### 8.2 Template referenced by curConstructedDO and data object generations

#### 8.2.1 Template referenced by curConstructedDO and DO referenced by curDO

#### Any DO within the template referenced by curConstructedDO can be directly referenced by its sole tag

#### in a command for interchange which does not provide any information on the VA together with this tag.

#### If any of those DOs is also constructed, the template referenced by curConstructedDO does not include

#### any nested DOs within this constructed DO.

#### The virtual root DO'7F70' belongs to the 0 generation, and is the only DO in that generation. If

#### curConstructedDO references an nth generation constructed DO'XY', the template referenced by

#### curConstructedDO is a sequence of (n+1)th generation DOs nested in DO'XY'. The template referenced by

#### curConstructedDO does not include DOs possibly nested in any (n+1)th generation DO. Annex F shows

#### examples.

#### curDO (see 7. 2 .1 dash 9) is set by a select command (see 11.2.2) or a select data command (see

#### 11.5.2). DO selection also occurs as a side effect of other DO-handling commands, and is described in

#### the relevant clauses, e.g. 11.5.3 and 11.5.4 for the get data command.

#### In order to support referencing methods defined in this document, the card should be able to resolve

#### tag '7F70'.

#### Immediately after enabling of an interface (see 5.1) , thus before any selection, the template referenced

#### by curConstructedDO depends on the implicitly selected application or DF (curAppDF in the VA). It may

#### contain specific DOs to support e.g. discovery mechanisms defined in Reference [1].

#### Many commands which handle DOs imply one or several transient selections. In some cases, a side effect

#### of the command success may validate those transient selections, thus set the transient VA as current VA.

#### 8.2.2 Template extension

#### The template extension is that part of a template which is accessible only by automatic resolutions of

#### tagged wrappers, whereby extending the base template (see Annex G or examples). All wrapper DO'63'

#### are part of the base template.

#### If automatic resolution of tagged wrappers is not supported, the template extension is empty. The

#### indirect references are only informative. If needed, the outside world may perform a two-stage

#### procedure:

#### — selection of the structure where the DO is stored, when this structure is different from the current

#### structure;

#### — then handling of the DO within the selected structure.


#### 8.2.3 Data object pruned-tree

#### A constructed DO has a tree structure. A pruned-tree of this tree structure is obtained by removing

#### nested DOs from the tree. An extended header associated with a constructed DO refers a pruned-tree of

#### the DO (see 8.4.6 and 8.4.7).

EXAMPLE A given nth generation DO is denoted {T-L- {T1-L1-{T2-L2-V2}-{T3-L3-V3}}-{T4-L4-V4}-{T5-
L5-V5}}. Removing the (n+2)th generation DO T2 and the (n+1)th generation DO T4 yields the pruned-tree: {T-
L'- {T1-L1'-{T3-L3-V3}}-{T5-L5-V5}}. L and L1 are replaced by L' and L1' because removing a DO from a template
impacts its length.

#### 8.2.4 Data object life cycle

#### Any DO stored in the card may have a DO life cycle. When it does, the LCS shall distinguish at least two

#### states: Operational state (activated) and Operational state (deactivated). The coding of a DO's LCS and

#### the coding of a file's LCS are analogous (see Table 15 ). The presence of DO's LCS is indicated in the CP

#### template DO'62' (see Table 11 ).

### 8.3 Identification of data elements and data objects

#### 8.3.1 Principles

#### At the interface between the card and the interface device, a data element is generally presented in the

#### value field of a DO. The data element is said to be "under" the tag of the DO.

#### If the number of bits representing a data element is not a multiple of eight, one may use the BITSTRING

#### universal DO, as e.g. in ISO/IEC 7816-15. If not, the mapping into a byte or a string of bytes should

#### be specified together with the respective data element. Unless otherwise specified, the appropriate

#### number of bits shall be set to 1 in the last byte starting from bit b1.

#### For purposes of retrieval and referencing in interchange, a data element shall be associated with the tag

#### of a ber-tlv data object and the data element may be encapsulated in this data object.

#### A data element may be referenced directly by its associated ber-tlv tag. It may be associated with

#### another data element that sets the context to which it belongs.

#### One or more command-to-perform data objects may indirectly reference a data element.

#### The interindustry commands support multiple instances of the same DO within a template, thus within

#### an application and within a card.

#### A standard or an application may limit or prohibit multiple instances of the same DO within a template,

#### within a structure or within the application.

#### 8.3.2 Tag interpretation in command and response data fields or payloads

#### DOs of the universal class (first byte from '01' to '3F', see Annex E) always have their general meaning.

#### The meaning of DOs of the application class (first byte from '40' to '7F', see Annex E) is defined by

#### standards. The default is the ISO/IEC 7816 series[4] and the ISO/IEC JTC 1/SC 17 standards (see 8.3.3).

#### The meanings of those DOs are always the same, though their function is defined by the command

#### where they are used.

#### The way to interpret DOs of the context-specific class (first byte from '80' to 'BF', see Annex E) is

#### defined:

#### — generally by its nesting within a constructed DO defined by the standard, e.g. DOs nested in DO'62'

#### (se e Table 11 ). This rule is recursive, and applies e.g. to DOs nested in a DO'A0' nested in a DO'62'.

#### — by CLA: secure messaging indication (see 5.4 and 10.2).


#### — by INS: commands may define such DOs of the context-specific class for a specific use.

#### — In other cases, the interpretation of those DOs is defined by the application.

#### 8.3.3 Tag allocation

#### This document specifies many interindustry DOs, and allocates tags for the ber-tlv-encoding of those

#### DOs. In addition to defining further interindustry DOs, ISO/IEC 7816-6 maintains an exhaustive list of

#### the tuples (name of the interindustry DO, allocated tag) specified in ISO/IEC 7816 (all parts)[4] at the

#### time of publication. The tags allocated in ISO/IEC JTC 1/SC 17 standards belong either:

#### — to the application class, or

#### — to the context-specific class, when the corresponding DOs may be nested in a constructed DO the

#### tag of which has been allocated by the standard.

#### When a tag is defined by another standard, the national body responsible for the standard shall seek

#### advice of ISO/IEC JTC 1/SC 17/WG 4 for the tag or tags needed, and shall in due time comment in order

#### to add this or those tags in ISO/IEC 7816-6.

#### Illustrated by Annex A, 8.3.4 to 8.3.7 specify tag allocation schemes for identifying interindustry DOs in

#### data fields. When needed, those tag allocation schemes use the interindustry DOs shown in Table 17 for

#### notifying an authority responsible for tag allocation.

#### Table 17 — Interindustry data objects for tag allocation authority

```
Tag Value
'06' Object identifier (OID), encoding specified in ISO/IEC 8825-1), see examples in Annex A
'41' Country code (encoding specified in ISO 3166-1[2]) and optional national data
'42' Issuer identification number (encoding and registration specified in ISO/IEC 7812-1
```
```
[3]) and optional
issuer data
'4F' Application identifier (AID, encoding specified in 12.3.4)
'5F29' Interchange profile
```
#### 8.3.4 Standard tag allocation scheme

#### In the application class, ISO/IEC JTC1/SC17 allocates or reserves the use of any application class tag

#### numbers in the range 0-127 or greater than 511 (decimal).

#### Application class tag numbers in the range 128 to 511 (decimal) may be allocated by any standard or

#### specification referenced by an OID, or by an application referenced by an AID.

#### In order to identify the tag allocation authority in this range, a constructed DO'78' shall be used. This

#### DO shall nest an empty DO'80' followed by either a DO'06' or a DO'4F'. If DO'78' is present

#### — in the initial data string (see 12.2.3) or in EF .ATR/ INFO (see 12.3.3), then the authority shall be valid

#### for the entire card, except if overruled by another DO'78' in a file or a constructed DO.

#### — in the management data of an EF or DF, possibly supporting an application (see 7. 4), or in the

#### template made current by the selection of any file, then the authority shall be valid within that file

#### or application, except if it is overruled by another DO'78' in a constructed DO.

#### — in a template, it shall be valid for all DOs in the template, and all objects contained in the constructed

#### DOs, (thus irrespective of their generation), except if it is overruled by another DO'78' in a template.

#### 8.3.5 Compatible tag allocation scheme

#### These tag allocation schemes use interindustry DOs and further DOs.


#### These further DOs shall be nested within interindustry DOs referenced by tags '70' to '72', or tags '74' to

#### '77'. In those DOs, the meaning of the application class tags is not defined in ISO/IEC 7816 (all parts)[4]

#### except for tags '41', '42' and '4F' for identifying tag allocation authorities (see Table 17 ).

#### When further DOs use tags of the context-specific class and belong to the interindustry templates

#### defined above, their meaning is defined by the tag allocation authority.

#### The use of the context-specific class within interindustry templates with tags '65' (cardholder-related

#### data), '66' (card data), '67' (authentication data) and '6E' (application-related data) is deprecated.

#### In order to identify a compatible tag allocation scheme and the authority responsible for the scheme,

#### the interindustry DO'78' may be used. Possible occurrence and overruling are the same as in 8.3.4.

#### If present, its value shall contain one of the interindustry DOs shown in Table 17 , for identifying a tag

#### allocation authority.

#### 8.3.6 Coexistent tag allocation scheme

#### In such a scheme, all the interindustry DOs shall be nested within interindustry DOs'7E'. Moreover, tags

#### '79' and '7E' shall not be given another interpretation, as well as tags '62', '64', '6F' (CP, FMD and FCI

#### templates, see 7. 4) and '7D' (SM template, see 10.2).

#### These tag allocation schemes may use tags with an interpretation not defined in ISO/IEC 7816 (all parts)[4].

#### In order to identify a coexistent tag allocation scheme and the authority responsible for the scheme, an

#### interindustry DO'79' shall be used. This DO shall nest one of the interindustry DOs shown in Table 17.

#### — If an authority is valid for the entire card, then DO'79' shall be present in the initial data string (see

#### 12.2.3) or in EF .ATR/ INFO (see 12.3.3).

#### — If an authority is valid within a file or application, then DO'79' shall be present in the EF, DF or

#### application DF management data (see 7. 4), or in the template referenced by curConstructedDO set

#### by any file selection.

#### 8.3.7 Avoidance of independent tag allocation schemes

#### An independent tag allocation scheme uses tags with another interpretation than

#### ISO/IEC 7816 (all parts)[4], but which does not comply with 8.3.6. Such tag allocation schemes do not

#### comply with this document and do not allow interchange.

#### Besides a consistent use of compatible and coexistent allocation schemes, there are three ways for an

#### application to avoid such a situation and remain compliant with this document:

#### — The use of interindustry discretionary DOs'53' to present discretionary DOs, and DOs'73' to nest

#### proprietary DOs in discretionary templates.

#### — The use of 3-byte tags reserved for this purpose (see 8.3.4 ).

#### — The use of DOs of the context-specific class (see 8.3.2 ).

### 8.4 Referencing and retrieval of DOs and data elements

#### 8.4.1 General...................................................................................................................................................................................

#### A tag 'XY' directly references a data element, which is the value of DO'XY'. For retrieval of DOs before

#### selection of an application see 12.5.

#### Control parameters and file management data may be retrieved in the response to a select or select

#### data command (see 11.2.2, 11.5.2.1 and Table 95 ).


#### Once an application is selected, any DO should be retrieved directly or indirectly:

#### — in the file management data (see 7. 4) of the application DF and from specific EFs within the DF

#### referenced by curDF;

#### — in the template referenced by curConstructedDO (see 8.2) after application selection, using get

#### data or get next data commands (see 11.5.3 and 11.5.4). File management data and/or DO'62'

#### (nesting CPs) should be included in this template, to ensure that those particular DOs are relevant

#### to the application.

#### Element lists, tag lists, header lists, extended headers and extended header lists, are interindustry

#### DOs which reference indirectly data elements, thus reference DOs within any template. Such a data

#### element instructs the card how to interpret a command data field or to construct a response data field.

#### Computing the concatenation of data elements or the DOs from the indirect reference is called resolving

#### (or resolution of ) the indirect reference.

#### The interpretation of a tag list, a header list, an extended header or an extended header list depends on

#### the template in which they are defined. Nesting one of those DOs within a wrapper (which defines this

#### template), allows referencing wherever in a card. An optional tag within the wrapper allows referencing

#### the result of the resolution of the indirect reference by this tag.

#### The command data field syntax in the select data, get data, get next data shows the use of those

#### DOs, which may be close to the syntax of a wrapper.

#### 8.4.2 Element list

#### Under tag '5F41', this interindustry data element denotes that the information to retrieve is not

#### presented as DOs, but under application control. It shall be used only within the wrapper template. Its

#### structure and the returned information are out of scope of ISO/IEC 7816 (all parts)[4].

#### 8.4.3 Tag list

#### Referenced by tag '5C', this interindustry data element is a concatenation of tag fields without delimiter.

#### It references a concatenation of DOs with the respective tags, in the same order as in the tag list.

#### 8.4.4 Header list

#### Under tag '5D', this interindustry data element is a concatenation of tuples (tag field T, length field L)

#### without delimiter. The byte string is as defined as in the tag list except for possible truncation of the

#### values. When L = '00', no truncation occurs. When L > '00', the value shall be right truncated to L bytes,

#### except when it is already shorter or equal to L bytes. The coding of L is a BER length.

#### WARNING — Within a header list, all referenced DOs to be truncated should be primitive,

#### because a truncated constructed DO is not a DO. For extraction of parts of a constructed DO, an

#### extended header should be used.

#### 8.4.5 Extended header and extended header list

#### Under tags '4D', '5F60' or '5F61' (see 8.4.8 for the differences between different tags), this interindustry

#### data element is an extended header list.

#### An extended header list is either

#### — an extended header, or

#### — a concatenation of extended headers.


#### An extended header is a concatenation of tuples (tag field T, length field L) without delimiter. An

#### extended header references information within a target DO. A complete extended header shall be

#### derived from the target DO by the following procedure:

#### a) primitive DO not to be referenced:

#### If the extended header is to be tagged by

#### 1) '4D', delete the tag, length and value field.

#### 2) '5F60' or '5F61', delete the value field and replace the length field by '00'.

#### b) primitive DO to be referenced without truncation:

#### Delete the value field. If the extended header is to be tagged by

#### 1) '4D', replace the length field by '00'.

#### 2) '5F60' or '5F61', replace the length field by '80'.

#### c) primitive DO to be referenced with truncation:

#### Delete the value field and replace the length field by a truncation indication (see 8.4.6)

#### d) constructed DO not to be referenced at all

#### Delete the value field and replace the length field by '00'.

#### e) constructed DO to be referenced entirely:

#### Delete the value field and replace the length field by '80'.

#### f ) constructed DO where part of the information is to be referenced:

#### Adjust the value of the length field according to the outcome of applying the procedures above.

#### As shown in F. 2, the explicit referencing of DOs where nothing is referenced is not always necessary,

#### even when several instances of such a DO exist in a given template. Removing useless referencing is

#### entitled by this document. Annex H describes an example procedure of parsing an extended header.

#### 8.4.6 Resolving an extended header

#### To resolve an extended header, one shall build the referenced byte string as follows.

#### — If a tag indicates a primitive encoding, then the pair of tag field and length field is replaced by

#### data referenced by the tag. If the extended header is tagged by '4D', a length of '00' means that the

#### complete DO/element is included in the byte string. If the extended header is tagged by '5F60' or

#### '5F61', a length of '80' means that the complete DO/element is included in the byte string. A length

#### which is neither '00' in an extended header tagged by '4D', nor '80' in an extended header tagged

#### by '5F60' or '5F61', indicates the maximum number of data bytes to be retrieved and consequently

#### may require truncation as defined in 8.4.4. If the truncation indication indicates more bytes than

#### available in the DO, the behaviour depends on the tagging:

#### — Under tag '4D', it is out of the scope of this document.

#### — Under tag '5F60' and '5F61' the extended header is invalid. If used in a command APDU, the

#### command shall be rejected by SW1-SW2 = '6985'.

#### — A tag indicating a constructed encoding followed by a non-zero length, except '80', introduces a

#### subsequent value field that is an extended header list. A tag indicating a constructed encoding

#### followed by a zero length is ignored. A tag indicating a constructed encoding followed by '80' means

#### that the complete constructed DO/complete template is included in the byte string.


#### — The card shall ignore the elements of the extended header that do not match the target structure.

#### For security reasons, a card may reject a command with SW1-SW2 = '6985' because of the lack of

#### consistency between the structure used in the command data field and the contents of the card. This

#### may override security attributes.

#### The byte string consists of either

#### — the value fields of the primitive DOs, possibly truncated according to the indicated lengths, or

#### — the primitive DOs, possibly truncated according to the indicated lengths, and nested in the respective

#### template, the length of which complies with the ber-tlv rules.

#### If present, the length '80' shall be replaced by the actual length. The complete constructed DO/complete

#### template is included in the byte string.

#### The encoding of the referenced byte string, namely, a (possibly constructed) DO(s) or a concatenation

#### of (possibly truncated) data elements, is indicated:

#### — by an appropriate INS code (odd/even), or

#### — by an appropriate parameter of the command, e.g., either an appropriate encoding of the data field

#### (either constructed for those containing DOs or primitive for those containing data elements), or

#### — by tagging the extended header list by another tag than '4D', as shown in 8.4.8 and the PERFORM

#### SECURITY OPERATION command (see ISO/IEC 7816-8).

#### 8.4.7 Resolving an extended header list

#### The byte string referenced by an extended header list is the concatenation of the byte strings referenced

#### by the extended headers, in the same order as in the extended header list. When parsing an extended

#### header list:

#### — The resolution of one extended header shall be followed by the resolution of the next one if any.

#### — The order within the byte string is therefore defined by the order of extended headers in the

#### extended header list, which should match the order within the target (template) in order to avoid

#### the following problem: As in the resolution of an extended header, the card shall ignore the elements

#### (extended headers) of the extended header list that do not match the target (template) structure.

#### 8.4.8 Wrapper

#### Under tag '63', this interindustry DO shall nest two or more DOs.

#### a) The first DO is a mandatory indirect reference. Only one indirect reference shall be given in a

#### wrapper. It is a choice between:

#### 1) an element list (tag '5F41' or '53');

#### 2) an element list nesting DOs (tag '73');

#### 3) a tag list (tag '5C')

#### 4) a header list (tag '5D');

#### 5) an extended header list (tag '4D') ;

#### 6) an extended header list referencing a byte string with no stated structure (tag '5F60');

#### 7) an extended header list referencing one DO or a concatenation of DOs (tag '5F61);

#### 8) a byte string identical to the response data of the last command to perform (tag '80', empty

#### DO), see below.


#### possibly followed by a filter DO'7F71' (see 11.5.2.3) in the case of tag list or extended header list. The

#### use of DO'5F60' or the use of DO'5F61' entitle skipping indication of primitive DOs according to 8.4.5.

#### b) The remainder of the wrapper value field shall be:

#### 1) an application identifier DO'4F' (see 12.3.4); the indirect reference shall be valid within the

#### template referenced by curConstructedDO after application selection; or

#### 2) a file reference DO'51' (see 7. 3. 2 and Table 8 ); the indirect reference shall be valid within the

#### template referenced by curConstructedDO; or

#### 3) a DO'4F' followed by a non-empty DO'51' referencing a file which shall exist in the application;

#### the indirect reference shall be valid within this file; or

#### 4) one DO'52' (command to perform); the indirect reference shall be valid within the response

#### payload of this command; or

#### 5) several DO'52'; the commands to perform shall be processed in the presented order; the

#### indirect reference shall be valid within the response payload of the last command or in the

#### transient VA set by this command.

#### The resolution of a wrapper:

#### — It starts with the resolution of the second part of the wrapper, which is either a standard structure,

#### or a response APDU. It ends there if the indirect reference is a DO'80'.

#### — If the indirect reference is not a DO'80', it ends with the resolution of the indirect reference, which

#### is defined in 8.4.3, 8.4.4, 8.4.5.

EXAMPLE The following wrapper DO nests a tag list and one command-to-perform.
{'63'-L-{'5C'-L-(Tag1-Tag2-Tag3)}-{'52'-L-Command APDU}}

#### 8.4.9 Tagged wrapper

#### Under tag '63', this DO extends a template in a card which supports automatic resolution of wrappers.

#### The first DO in the value filed of a tagged wrapper DO'63' shall be an empty DO'XY'. The tag 'XY' shall

#### be valid in get data or get next data C-RPs when the extended template is the template referenced

#### by curConstructedDO; 'XY' shall respect the current tag allocation scheme. The remainder of the value

#### shall be the value of a wrapper DO (see 8.4.8). The outcome of resolving the indirect reference shall be

#### the value of DO'XY' when addressed within the template it extends (see 8.2.2):

#### — If the wrapper references a DO'ZT', the value of DO'XY' shall be the value of this DO'ZT' (see Annex G

#### for examples). The wrapper shall reference only one DO, possibly constructed.

#### — If the wrapper references a byte string, the value of DO'XY' shall be that byte string.

NOTE 1 Neither the notation 'XY' nor 'ZT' precludes the use of tags consisting of more than one byte.

NOTE 2 The automatic resolution of the tagged wrapper creates within the template referenced by
curConstructedDO a virtual DO. The tag of this virtual DO is taken from the first DO in the tagged wrapper.
The length field of this DO codes the length of the content of the resolved indirection. The value of the DO is the
content itself (see examples in Annex G).

## 9 Security architecture

### 9.1 General

#### This clause describes security status, security attributes and security mechanisms.


#### Security status — The security status represents the current state possibly achieved on a logical

#### channel after physical interface enabling (see 5.1) or resetting a logical channel and/or execution of

#### one or several C-RP(s) on this logical channel possibly performing authentication procedures. The

#### security status may also result from completion of a security procedure related to the identification

#### of the involved entities, if any, e.g. by proving knowledge of a password (e.g. using a verify command)

#### or knowledge of a key (e.g. using a get challenge command followed by an external authenticate

#### command, or using a sequence of general authenticate commands), or by secure messaging (e.g.

#### message authentication). Five security statuses are considered.

#### — Global security status — In a card using a hierarchy of DFs, it may be modified by completion of an

#### MF-related authentication procedure (e.g. entity authentication by a password or a key attached to

#### the MF).

#### — Application-specific security status — It may be modified by completion of an application-

#### related authentication procedure (e.g. entity authentication by a password or a key attached to

#### the application); it may be maintained, recovered or lost by application selection; this modification

#### may be relevant only for the application to which the authentication procedure belongs. If logical

#### channels apply, then the application-specific security status may depend on the logical channel.

#### — File-specific security status — It may be modified by completion of a DF-related authentication

#### procedure (e.g. entity authentication by a password or by a key attached to the specific DF); it may

#### be maintained, recovered or lost by file selection; this modification may be relevant only for files

#### within the application to which the authentication procedure belongs. If logical channels apply, then

#### the file-specific security status may depend on the logical channel.

#### — DO-specific security status — It may be modified by completion of a DO-related authentication

#### procedure; it may be maintained, recovered or lost by selections; this modification may be relevant

#### only for DO within the application to which the authentication procedure belongs. If logical channels

#### apply, then the DO-specific security status may depend on the logical channel.

#### — Command-specific security status — It only exists while processing a command using secure

#### messaging and involving authentication; such a command may leave the other security status

#### unchanged.

#### Security attributes — The security attributes, when they exist, define which actions are allowed, and

#### under which conditions. The security attributes of a structure depends on:

#### — its category (DF, EF or DO);

#### — optional CPs in its CP template DO'62' and/or in that of its parent structure(s);

#### Security attributes may also be associated with commands, DOs and tables & views. In particular,

#### security attributes may

#### — specify the security status of the card to be in force before accessing data;

#### — restrict access to data to certain functions (e.g. read only) if the card has a particular status;

#### — define which security functions shall be performed to obtain a specific security status.

#### Security mechanisms — This clause considers the following security mechanisms.

#### — Entity authentication with password — The card compares data received from the outside world

#### with secret internal data. This mechanism may be used for protecting the rights of the user.

#### — Entity authentication with key — The entity to authenticate shall prove the knowledge of the

#### relevant secret or private key in an authentication procedure (e.g. a get challenge command

#### followed by an external authenticate command, a sequence of general authenticate

#### com m a nd s).

#### — Data authentication — Using internal data, either a secret key or a public key, the card checks

#### redundant data received from the outside world. Alternatively, using secret internal data, either a


#### secret key or a private key, the card computes a data element (cryptographic checksum or digital

#### signature) and inserts it in the data sent to the outside world. This mechanism may be used for

#### protecting the rights of a provider.

#### — Data encipherment — Using secret internal data, either a secret key or a private key, the card

#### deciphers a cryptogram received in a data field. Alternatively, using internal data, either a secret key

#### or a public key, the card computes a cryptogram and inserts it in a data field, possibly together with

#### other data. This mechanism may be used to provide a confidentiality service, e.g. key management

#### and conditional access. In addition to the cryptogram mechanism, data confidentiality can be

#### achieved by data concealment. In this case, the card computes a string of concealing bytes and adds

#### it by exclusive-or to bytes received from or sent to the outside world. This mechanism may be used

#### for protecting privacy and as a countermeasure against pattern recognition.

#### The result of an authentication may be logged internally according to application requirements.

### 9.2 Cryptographic mechanism identifier template

#### One or more cryptographic mechanism identifier DO'AC' may be present in the CPs of any DF (see

#### Table 11 ). Each one explicitly indicates the meaning of a cryptographic mechanism reference in the DF

#### and its hierarchy. The template shall consist of two or more DOs.

#### — The first DO shall be a cryptographic mechanism reference, DO'80' (see Table 56 ).

#### — The second DO shall be an object identifier, DO'06', as defined in ISO/IEC 8825-1. The identified object shall

#### be a cryptographic mechanism defined in a standard, e.g. an ISO standard. Examples of cryptographic

#### mechanisms are encryption algorithms [e.g. ISO/IEC 18033 (all parts)[18]], message authentication

#### codes [e.g. ISO/IEC 9797 (all parts)[7]], authentication protocols [e.g. ISO/IEC 9798 (all parts)[8]],

#### digital signatures [e.g. ISO/IEC 9796 (all parts)[6] or ISO/IEC 14888 (all parts)[15]], and so on.

#### — If present, one or more subsequent DOs (DO'06' or DO'0D') shall either identify a mechanism used

#### by the previous mechanism [i.e. a mode of operation, e.g. ISO/IEC 10116 [9], or a hash-function, e.g.

#### ISO/IEC 10118 (all parts)[10]], or indicate parameters (tag dependent on the previous mechanism).

#### DO'0D' gives a relative-OID rooted at the nearest preceding DO'06' as defined in ISO/IEC 8825-1.

EXAMPLE (see explanations in Annex A and Annex B)

{'AC' - '0B' - {'80'-'01'-'01'} - {'06'-'06'-'28818C710201'}}

The template associates the local reference '01' to the first encryption algorithm in in ISO/IEC 18033-2[18].

{'AC' - '11' - {'80'-'01'-'02'} - {'06'-'05'-'28CC460502'} - {'06'-'05'-'28CF060303'}}

The first object identifier refers to the second authentication mechanism in ISO/IEC 9798-5[8]. The second object
identifier refers to the third dedicated hash-function in ISO/IEC 10118-3[10]. Therefore the template associates
the local reference '02' to GQ2 using SHA-1.

### 9.3 Security attributes

#### 9.3.1 General...................................................................................................................................................................................

#### This subclause defines the coding of data relevant to the security attributes, and two formats for

#### binding objects and security attributes: a compact format based on bitmaps and an expanded format

#### that extends the compact format by tlv list management. The expanded format may use the codings

#### defined for the compact format under different encapsulations.

#### 9.3.2 Security attributes targets

#### Referenced by tags '86', '8B', '8C', '8E', '9C', 'A0', 'A1', 'A3', 'AB', security attributes may be present in the

#### CPs of any file or DO (see Table 11 ). Any object in the card (e.g., command, file, DO, table & view) may


#### be associated with more than one security attribute and/or with a reference contained in a security

#### attribute.

#### In SCQL environment (see ISO/IEC 7816-7, commands for structured card query language), security

#### attributes can be specified in SCQL operations, e.g. create table and create view commands. If

#### security attributes based on this clause are used, then they shall be conveyed in a DO with tags '8B', '8C'

#### or 'AB' in the security attribute parameters of an SCQL operation.

#### Security attributes for DOs are defined in 9.3.6. Security attributes for logical channels are defined

#### in 9.3.8.

#### 9.3.3 Compact format

#### In compact format, an access rule consists of an access mode field followed by one or more security

#### condition bytes. The security attribute contains one or several concatenated access rules.

#### If several access rules are present in the value field of a DO'8C' or '9C' (see Table 11 ), they represent an

#### OR condition.

#### Access mode field — An access mode field consists of either one or more bytes.

#### — If the access mode field consists of one byte, then bit b7 to b1 indicates either the absence of a security

#### condition byte when set to 0, or the presence of a security condition byte in the same order (bits b7

#### to b1) when set to 1. When bit b8 is set to 1, bits b7 to b4 may be used for additional commands, e.g.

#### application-specific commands.

#### — If the access mode field consists of more bytes, the first byte of the access mode field shall be set

#### to '00'. The second and possibly further bytes (see NOTE below) in the access mode field are AMBs.

#### Each AMB indicates in bit b8 whether or not it is the last AMB. Bit b8 shall be set to 0 in the last

#### AMB. Bit b8 shall be set to 1 in all other AMBs. Bits b6 to b1 indicate either the absence of a security

#### condition byte when set to 0, or the presence of a security condition byte in the same order (bits b6

#### to b1) when set to 1 and in the same order as the AMBs. When bit b7 is set to 1, bits b6 to b1 may be

#### used for additional commands, e.g. application-specific commands.

NOTE Further AMBs are not defined in this document and can be defined in future editions or other parts of
this document.

#### Table 18 to Table 30 define access mode bytes respectively for DFs, EFs, DOs and tables & views.

#### Table 18 — Coding of the sole byte in an access mode field for DFs

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 - - - - - - - Bits b7 to b1 according to this table
1 - - - - - - - Bits b3 to b1 according to this table (bits b7 to b4 proprietary)
0 1 - - - - - - delete (file) (sel f )
0 - 1 - - - - - terminate card usage (MF), terminate (df)
0 - - 1 - - - - activate (file)
0 - - - 1 - - - deactivate (file)
```
- - - - - 1 - - create (file) ( DF c reat ion)
- - - - - - 1 - create (file) ( EF c reat ion)
- - - - - - - 1 delete (file) (ch i ld)

#### Table 19 — Coding of the sole byte in an access mode field for EFs

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 - - - - - - - Bits b7 to b1 according to this table
1 - - - - - - - Bits b3 to b1 according to this table (bits b7 to b4 proprietary)
```

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 1 - - - - - - delete (file)
0 - 1 - - - - - terminate ef
0 - - 1 - - - - activate (file), activate record (s)
0 - - - 1 - - - deactivate (file), deactivate record (s)
```
- - - - - 1 - - write binary, write record, append record
- - - - - - 1 - update binary, update record, erase binary, erase record (s)
- - - - - - - 1 read binary/record (s), search binary/record, compare binary/record

#### Table 20 — Coding of the sole byte in an access mode field for DOs

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 - - - - - - - Bits b7 to b1 according to this table
1 - - - - - - - Bits b3 to b1 according to this table (bits b7 to b4 proprietary)
0 1 - - - - - - delete data
0 - 1 - - - - - manage data Te r m i n a t e
0 - - 1 - - - - manage data Activate
0 - - - 1 - - - manage data Deactivate
```
- - - - - 1 - - manage security environment
- - - - - - 1 - put data/put next data/update data
- - - - - - - 1 get data/get next data/compare data

#### Table 21 — Coding of the sole byte in an access mode field for security objects

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 - - - - - - - Bits b7 to b1 according to this table
1 - - - - - - - Bits b3 to b1 according to this table (bits b7 to b4 proprietary)
0 x - - - - - - 0 (any other value is RFU)
0 - 1 - - - - - terminate a
0 - - 1 - - - - activate a
0 - - - 1 - - - deactivate a
```
- - - - - x - - 0 (any other value is RFU)
- - - - - - 1 - _put/update_ a
- - - - - - - 1 _get_ a
a Description in _italic format_ means an operation and not a command.

#### Table 22 — Coding of the sole byte in an access mode field for tables & views

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 - - - - - - - Bits b7 to b1 according to this table
1 - - - - - - - Bits b3 to b1 according to this table (bits b7 to b4 proprietary)
0 1 - - - - - - create user, delete user
0 - 1 - - - - - grant, revoke
0 - - 1 - - - - create table, create view, create dictionary
0 - - - 1 - - - drop table, drop view
```
- - - - - 1 - - insert
- - - - - - 1 - update, delete

#### Table 19 (continued)


**b8 b7 b6 b5 b4 b3 b2 b1 Meaning**

- - - - - - - 1 fetch

#### Table 23 — Coding of the 2nd byte in an access mode field (1st AMB) for DFs

**b8 b7 b6 b5 b4 b3 b2 b1 Meaning**
0 - - - - - - - Last byte of access mode field
1 - - - - - - - Another byte follows in this access mode field

- 0 - - - - - - Bits b6 to b1 according to this document
- 1 - - - - - - Bits b6 to b1 proprietary
- 0 1 - - - - - terminate card usage (MF), terminate (df)
- 0 - 1 - - - - activate (file)
- 0 - - 1 - - - deactivate (file)
- 0 - - - 1 - - create (file) ( DF c reat ion)
- 0 - - - - 1 - create (file) ( EF c reat ion)
- 0 - - - - - 1 delete (file) (ch i ld)

#### Table 24 — Coding of the 3rd byte in an access mode field (2nd AMB) for DFs

**b8 b7 b6 b5 b4 b3 b2 b1 Meaning**
x x - - - - - - Same coding and meaning as in Table 23

- 0 1 - - - - - delete (file) (sel f )
- 0 - 1 - - - - application management request
- 0 - - 1 - - - remove application
- 0 - - - x x x 000 (any other value is RFU)

#### Table 25 — Coding of the 4th byte in an access mode field (3rd AMB) for DFs

**b8 b7 b6 b5 b4 b3 b2 b1 Meaning**
x x - - - - - - Same coding and meaning as in Table 23

- 0 x x x x - - 0000 (any other value is RFU)
- 0 - - - - 1 - command creating data objects (see ISO/IEC 7816-9)
- 0 - - - - - 1 delete data

#### Table 26 — Coding of the 2nd byte in an access mode field (1st AMB) for EFs

**b8 b7 b6 b5 b4 b3 b2 b1 Meaning**
x x - - - - - - Same coding and meaning as in Table 23

- 0 1 - - - - - terminate ef
- 0 - 1 - - - - activate (file), activate record(s)
- 0 - - 1 - - - deactivate (file), deactivate record(s)
- 0 - - - 1 - - append record
- 0 - - - - 1 - update binary, update record
- 0 - - - - - 1 read binary/record (s), search binary/record

#### Table 27 — Coding of the 3rd byte in an access mode field (2nd AMB) for EFs

**b8 b7 b6 b5 b4 b3 b2 b1 Meaning**
x x - - - - - - Same coding and meaning as in Table 23

#### Table 22 (continued)


```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
```
- 0 1 - - - - - delete ef
- 0 - x x - - - 00 (any other value is RFU)
- 0 - - - 1 - - write binary, write record
- 0 - - - - 1 - erase binary, erase record (s)
- 0 - - - - - 1 compare binary/record

#### Table 28 — Coding of the 4th byte in an access mode field (3rd AMB) for EFs

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
x x - - - - - - Same coding and meaning as in Table 23
```
- 0 x x x x - - 0000 (any other value is RFU)
- 0 - - - - 1 - command creating data objects (see ISO/IEC 7816-9)
- 0 - - - - - 1 delete data

#### Table 29 — Coding of the 2nd byte in an access mode field (1st AMB) for DOs

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
x x - - - - - - Same coding and meaning as in Table 23
```
- 0 1 - - - - - manage data Te r m i n a t e
- 0 - 1 - - - - manage data Activate
- 0 - - 1 - - - manage data Deactivate
- 0 - - - 1 - - manage security environment
- 0 - - - - 1 - put data/update data
- 0 - - - - - 1 get data/get next data

#### Table 30 — Coding of the 3rd byte in an access mode field (2nd AMB) for DOs

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
x x - - - - - - Same coding and meaning as in Table 23
```
- 0 1 - - - - - delete data
- 0 - 1 - - - - command creating data objects (see ISO/IEC 7816-9)
- 0 - - x x - - 00 (any other value is RFU)
- 0 - - - - 1 - put next data
- 0 - - - - - 1 compare data

#### Security condition byte — Each security condition byte specifies which security mechanisms are

#### necessary to conform to the access rule. Table 31 shows the security condition byte. Bits b8 to b5

#### indicate the required security conditions. If not all equal, bits b4 to b1 identify either:

#### — a security environment (see 10.4.4 , SEID from '01' to '0E'), or

#### — a DO'AD' (see 9.3.7) by its number from '01' to '0E'. The DO'AD' is a CP under the same DO'62' as this

#### security attribute.

#### Table 27 (continued)


#### Table 31 — Coding of the security condition byte

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
All equal Constant security condition
0 0 0 0 0 0 0 0 Always
1 1 1 1 1 1 1 1 Never
Not all equal
x - - - - - - - Indication of logical operation for conditions indicated in bits b7, b6, b5
0 - - - - - - - At least one condition
1 - - - - - - - All conditions
```
- **x x x** - - - - **Indication of security condition**
- 1 - - Secure messaging
- - 1 - External authentication
- - - 1 User authentication (e.g. password)
- - - - **x x x x Reference to an SE or a sequence number of an SPT DO'AD'**
- - - - 0 0 0 0 No reference to a security environment nor to a DO'AD'
- - - - 1 1 1 1 RFU
0 0 0 0
Not all equal

```
Use Boolean expression in DO’AD’ identified in bits b4, b3, b2, b1 (see below)
```
```
Not all zero
```
```
Under tag '8C'a or '9E'b SEID identified in bits b4 to b1 (see 10.4.4)
Under tag '9C'a or '9D'b Sequence number identified in bits b4 to b1 of an SPT DO'AD' (see 9.3.7.3)
a For use in compact format (under tag '62', see Table 11 ).
b For use in expanded format (see Table 34 ).
```
#### The mechanisms defined in the security environment, or in the DO'AD', shall be used according to

#### the indications in bits b7 to b5 for secure messaging and/or external authentication and/or user

#### authentication.

#### — If bit b8 is set to 1, then all the conditions set in bits b7 to b5 shall be satisfied.

#### — If bit b8 is set to 0, then at least one of the conditions set in bits b7 to b5 shall be satisfied.

#### — If bit b7 is set to 1, in a security condition which references a security environment, then the control

#### reference template (see 10.4.2) of the security environment describes whether SM shall apply to

#### the command data field and/or to the response data field (see usage qualifier byte, Table 58 ). If

#### the security condition indicates a DO'AD' number, the relevant SEID shall be available either in the

#### DO'AD' or in a security attributes extension nested in the DO'AD'.

#### — If b8 = b7 = b6 = b5 =0, and if b4 b3 b2 b1 indicates a valid DO'AD' number, a Boolean expression DO

#### shall be present in the DO'AD' (see 9. 3 .7.11).

#### 9.3.4 Expanded format

#### 9.3.4.1 General

#### In expanded format, an access rule consists of an access mode DO followed by one or more security

#### condition DOs. Access control to an object is managed by referencing access rules from the related

#### object. A DO'AB' may be present in the CPs of any file (see Table 11 ) for such access rules.

#### Access mode DOs — An access mode DO contains either an access mode field (see Table 18 to Table 30

#### and Table 42 to Table 45 ), or a list of command descriptions or a proprietary state machine description;

#### subsequent security condition DOs are relevant for all the indicated commands. Table 32 shows access

#### mode DOs.


#### Table 32 — Coding of access mode DOs

```
Tag Length Value Meaning
'80' Va r. Access mode field See Table 18 to Table 30 and Table 42 to Table 45
'81' to '8F' Va r. Command header descriptionList of (part of ) command headers (see Table 33 )
'9C' Va r. Proprietary state machine description
```
#### If the tag is from '81' to '8F', then the access mode data element represents a list of possible combinations

#### of values of the four bytes CLA, INS, P1 and P2 in the command header. Depending on bits b4 to b1 of the

#### tag, the list contains only values as described in Table 33. Several groups may appear in order to define

#### a set of commands, e.g. values of INS P1 P2, INS P1 P2, ... for tag '87'.

#### Table 33 — Coding of tags '81' to '8F' for access mode DOs

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
1 0 0 0 x x x x The command description includes
1 0 0 0 1 - - - — (CLA), i.e. the value of CLAa
1 0 0 0 - 1 - - — INS), i.e. the value of INS
1 0 0 0 - - 1 - — (P1), i.e. the value of P1
1 0 0 0 - - - 1 — (P2), i.e. the value of P2
a The value of CLA shall encode zero as the number for a logical channel with the meaning that the description is
independent from logical channels.
```
#### Security condition data objects — According to Table 34 , the security condition DOs define the security

#### actions required for accessing an object protected through the particular access mode DO. If used as a

#### security condition, a control reference template (see 10.4.2) referenced by tag 'A4' (AT), 'B4' (CCT), 'B6'

#### (DST) or 'B8' (CT) shall contain a usage qualifier DO (see Table 58 ) indicating the security action.

#### Table 34 — Coding of security condition DOs

```
Tag Length Value Meaning
'90' 0 - Always
'97' 0 - Never
'9D','9E' 1 Security condition byte See Table 31
'A4' Va r. Control reference template External or user authentication depending on the usage qualifier
'AB' Va r. Object status condition template See 9.3.4.2
```
```
'B4', 'B6', 'B8' Va r. Control reference template SM in command and/or response depending on the usage qualifier
'A0' Va r. Security condition DOs At least one security condition shall be fulfilled (OR template)
'A7' Va r. Security condition DOs Inversion of the security condition (NOT template)
'AF' Va r. Security condition DOs Every security condition shall be fulfilled (AND template)
'BE' Va r. Security condition templateBoolean which refers to the values of items present in the card
```
#### Several security condition DOs may be attached to the same operation.

#### — If security condition DOs are nested in an OR template (tag 'A0'), then at least one security condition

#### shall be fulfilled before acting.

#### — If security condition DOs are not nested in an OR template (tag 'A0') or if they are nested in an AND

#### template (tag 'AF'), then every security condition shall be fulfilled before acting.

#### — The value of the NOT security condition (tag 'A7') is logical inversion of the value of the security

#### condition it nests.


#### 9.3.4.2 Object status condition template

#### The template provides the possibility to make a security condition depending on the:

#### — current value of an object (EF, DO), referenced in the object status condition template;

#### — current value of an attribute related to the object (EF, DF, DO, key or password), referenced in the

#### object status condition template;

#### — current value of OS internal data (e.g. system clock);

#### — current value of (parts of ) the command message.

#### The template is composed by four different parts:

#### — a mandatory condition data object that defines the operation to be performed to compare the

#### referenced value with the comparison data given in the template;

#### — a mandatory object locator DO; the object locator identifies unambiguously the data to be used for

#### comparison;

#### — a mandatory comparison data to be compared with the value of the referenced object or the value

#### of an attribute related to the referenced object;

#### — an optional binary filter to be applied to the data to be compared (logical AND) before comparison.

#### Table 35 shows an object status condition template.

#### Table 36 together with Table 37 shows a condition data object.

#### Table 35 — SC-DO for the description of access conditions depending on object attributes

```
Tag Length Value Meaning
```
```
'AB' Va r.
```
```
condition DO'9E'
object locator according to Table 38 (tag '7F72')
binary filter DO'5F71' (optional)
comparison data (tag '53')
```
```
Object status condition
```
#### Table 36 — Coding of the condition data object

```
Tag Length Value
'9E' '01'Rule to verify the object attribute (see Table 37 )
```
#### Table 37 — Coding of the value field in condition DO’9E’

```
Value Meaning
'01' <a, the value of the referenced object/attribute is lower than the given comparison data
'02' ≤a, the value of the referenced object/attribute is lower than or equal to the given comparison data
'03' =a, the value of the referenced object/attribute is equal to the given comparison data
'04' ≥a, the value of the referenced object/attribute is higher than or equal to the given comparison data
'05' >a, the value of the referenced object/attribute is higher than the given comparison data
'06' ≠a, the value of the referenced object/attribute is not equal to the given comparison data
a By equal length of the objects.
```
#### The security condition described by the object status condition template is not fulfilled if the referenced

#### object/attribute value does not fulfil the condition defined by the condition DO.


#### 9.3.4.3 Object locator

#### The object locator provides a reference to an object stored in the card. The following object types may

#### be referenced:

#### — MF or DF specific key;

#### — MF or DF specific password;

#### — a discretionary data object;

#### — an EF or DF;

#### — special system data managed by the card;

#### — a data element of a command message.

#### The object locator is represented by DO'7F72'. The value field of DO’7F72’ is composed by an object

#### reference DO (mandatory) followed by an attribute reference DO (conditional). The type of the object

#### reference DO depends on the object to be referenced (EF, DF, DO, key, password). Table 38 lists the

#### object reference DOs depending on the referenced object type.

#### A control reference template (CRT) is used to refer to a key or a password (see 10.4.2). The CRT shall

#### contain at least a key reference data object (DO'83' or '84'). Further data objects from Table 56 may be

#### used (e.g. usage qualifier) if required for further qualification of the reference. A mandatory DO (empty)

#### following refers by its tag to the intended key attribute from Table 41.

#### An object locator according to Table 38 is used to refer to either:

#### — a control parameter of a DF, an EF, or a DO, or

#### — a DataString in a transparent EF, or

#### — (part of) the data content in a record of a structured EF, or

#### — the value field of a DO.

#### If a reference to a DF is given, a second DO shall follow, indicating a control parameter object from

#### Table 11. If an EF or DO is referenced, the second DO is optional. If present it shall indicate a control

#### parameter of the EF or DO in the same way as for a DF. If absent the object locator refers to the

#### DataString, the record or the value field of the DO.

#### To refer to OS internal system data the empty DO'80' shall be used. The following attribute reference

#### DO indicates by its tag the relevant system information. The definition of the relevant tags is out of the

#### scope of this document.

#### To refer to parts of the command message, the empty DO'81' shall be used. The following mandatory

#### DO indicates which part of the command APDU is addressed. This following DO shall be chosen from a

#### command header DO’89’, an Le field DO’96’ or a command data DO’A1’. The DO'A1' is used to address either

#### — (a part of) the data field, defined by an offset and a length, or

#### — (a part of) the value field of a data object contained in the data field.

#### The intended data object in the data field is defined by the tag list. If no tag list is given, the command

#### data field is in the focus scope of the object locator. Using the offset DO and/or the length DO the relevant

#### area of the command data field or the value field of the data object can be restricted. If the offset DO is

#### missing, the offset value zero is implicitly used. If the length DO is missing, the object locator refers to

#### the complete range starting from the position indicated by the offset up to the end of the command data

#### field or the value field of the data object.


#### Table 38 — Coding of the object locator DO'7F72'

```
Object Type Object reference DO Attribute reference DO
Key CRT containing at least a key reference DO [DO'83' or DO'84' (see Table 56 )] Empty DO (mandatory), tag refers to the relevant key attribute (see Table 41 ) -
```
```
Password CRT containing at least a password reference DO'83' and a usage qualifier DO'95'-Empty DO (mandatory), tag refers to the relevant password attribute (see Table 41 )
```
```
CP of DF General reference template '60' (see Table 94 ) indicating a DF Empty DO (mandatory), tag refers to the relevant control parameter object (see Table 11 )
CP of EF or
DO
```
```
General reference template '60' (see
Table 94 ) indicating an EF or DO
```
```
Empty DO (mandatory), tag refers to the relevant control
parameter object (see Table 11 )
Record,
DataString
or data
element
```
```
General reference template '60' (see
Table 94 ) indicating a record or Data-
String or the value filed of a data object
(possibly located in an EF)
```
```
None
```
```
System data DO'80' (empty) indicating the internal system data area Data object (empty) that indicates the intended system data element (proprietary)
```
```
Command
message
```
```
DO'81' (empty) indicating
the command APDU
```
```
One of the following data objects (mandatory):
DO'89' (empty): Refers to the command header
DO'96' (empty): Refers to the Ne value of the command
APDU
DO'A1': Command data DO; may contain following DOs in
the given order:
— tag list DO’5C’ indicating a DO of the command data
field (optional)
— an offset DO'54' (optional)
— a length DO'02' (optional)
An empty DO'A1' refers to the complete data field of the
command APDU
```
#### 9.3.4.4 Binary filter value (optional)

#### The binary filter DO'5F71' provides a binary mask to be used in a logical AND operation to the data to

#### be compared before comparison.

#### 9.3.4.5 Comparison data

#### The comparison data are encapsulated in a discretionary DO'53' and provide the binary representation

#### of the value to be compared with the data specified by the object locator.

#### 9.3.5 Access rule references

#### Access rules in expanded format may be stored in an EF supporting a linear structure with records

#### of variable size. Such an EF is named EF.ARR. One or more access rules may be stored in each record

#### referenced by a record number. Such a record number is named ARR byte. Table 39 illustrates the layout

#### of an EF.ARR.


#### Table 39 — EF.ARR layout

```
Record number (ARR byte) Record content (one or more access rules)
1 Access mode DO, one or more security condition DOs, access mode DO, ...
2 Access mode DO, one or more security condition DOs, ...
```
```
N Access mode DO, one or more security condition DOs, ...
```
#### Security attributes DO'8B' referencing expanded format (see Table 4 0) may be present in the CPs of any

#### file or DO (see Table 11 ).

#### — If the length is one, then the value field is an ARR byte that references a record in an implicitly

#### known EF.ARR.

#### — If the length is three, then the value field is a file identifier followed by an ARR byte; the file identifier

#### references EF.ARR and the ARR byte is the record number in EF.ARR.

#### — If the length is even and at least four, then the value field is a file identifier followed by one or

#### more pairs of bytes. Each pair consists of an SEID followed by an ARR byte; the SEID identifies the

#### security environment where the access rules referenced by the ARR byte apply.

#### Table 40 — Security attribute DOs referencing expanded format

```
Tag Length Value
```
```
'8B'
```
```
1 ARR byte (one byte)
3 File identifier (two bytes) - ARR byte (one byte)
Even, > 3 File identifier (two bytes) - SEID (one byte) - ARR byte (one byte) – (SEID byte - ARR byte) - ...
```
#### The ARR byte of the current SE (see 10.3.3) indicates the access rules valid for the current access to the

#### application DF.

NOTE If no SE is set in a former manage security environment command, then the default SE is the
current SE.

#### 9.3.6 Security attributes for data objects

#### The granularity of security-related properties is the DO, identified by its tag within the template

#### referenced by curConstructedDO associated with the VA. Any DO may have control parameters seen at

#### the card interface as DO'62' nesting security attributes for that DO. When a DO does not feature control

#### parameters, the security attributes of the parent template will be inherited.

#### When it belongs to a template extension, the security attributes of a DO shall not be inherited from

#### parent of the tagged wrapper. Its security attributes are those defined where the indirect reference

#### points to.

#### Under tag 'A0', a security attribute template for DOs may be present in the CPs of any file or DO (see

#### Table 11 ). Such a template:

#### — starts with a security attribute DO (tags '86', '8B', '8C', '8E', '9C', 'A0', 'A1', 'AB');

#### — ends with a possibly empty tag list DO'5C'.

#### The tag list should contain only tags belonging to the base template to which DO'62' nesting DO'A0'

#### belongs, or tags of DOs expected to be added to this template. When the tag list is empty, the security

#### attribute template is valid for the whole base template to which the DO'62' belongs.


#### 9.3.7 Security parameters template

#### 9.3.7.1 General properties

#### An SPT DO'AD' under DO'62' provides an extension of security attributes associated with a security

#### object (e.g. a key, password...) or a DO which endorses security handling (see 9. 3 .7. 2). Any DO'AD' which

#### supports this function shall contain either a wrapper or a tagged wrapper DO'63' (see 8.4.9 and 9. 3 .7. 2)

#### giving an indirect reference to the security object or DO. It may give data usage parameters describing

#### the properties and conditions of use of this DO.

#### A DO'AD' nested in a DO'AD' has the same coding as a DO'AD' nested in a DO'62'.

#### As any template, the SPT may nest a DO'62'. Within this DO, the security attributes for DOs have the

#### meaning defined in 9.3.6. All other security attributes apply to the security object (see Table 21 for the

#### coding of the access mode byte).

EXAMPLE Within a DO'62' under a DO'AD', the following DOs can be both present:

— A DO {A0 06 {8CXYZT}{5C01B3}} has its normal meaning, i.e. the security attributes for access to the DO'B3'
which contains DOs specified by an OID.

— A DO {8CXYZT} or {ABXY...} codes the security attributes for access to the DO nesting the security object (see
Table 21 ).

#### A DO'AD' may also be referenced by any command using this DO or the security object to which the

#### DO'AD' is attached.

#### If a Boolean expression is to be evaluated as TRUE to allow the execution of a C-RP, a DO defining this

#### Boolean expression shall be present in a DO'AD' (see 9. 3 .7.11).

#### 9.3.7.2 Extensions of the security attribute

#### All DOs with tags from 'A0' to 'A5' identify the type of the security object. Each type has a specific

#### access mode byte (see Table 42 to Table 45 ). The security attribute for Diffie-Hellman keys is irrelevant,

#### so DO'A5' is always empty.

#### Any DO with tag from 'A0' to 'A4' shall nest either:

#### — a DO'8C' nesting a security attribute in compact format (see 9.3.3 ), referencing SEs; or

#### — a DO'9C' nesting a security attribute in compact format (see 9.3.3 ), referencing SPTs; or

#### — a DO'AB' nesting a security attribute in expanded format (see 9.3.4), where the security condition

#### byte DO'9D' may be used to reference SPTs.


#### Table 41 — Data usage parameters in an SPT (tag 'AD' under tag '62')

```
Tag Length Value Occurrence
'06' Va r. OID of a document describing e.g. an algorithm and/or the use of DO'B3' At most once
'63' Va r. Wrapper At most once
'7B' Va r. Security environment DO (see Table 60 ) Once
'80' 1 Sequence number (mandatory) Once
'82' Va r. Security object (password/reference data type) number (binary coding) At most once
'83' Va r. Security object (key/certificate type) number (binary coding) At most once
'84' 1 SEID Any
'86' 1 Key usage constraints indicator (see 9. 3 .7. 4) At most once
'8A' 1 LCS byte of the security object At most once
'90'
Va r. Maximum number of tries of an authentication procedure (binary coding)-
```
```
Volat ile
At most once
91 Non-volatile
'92' Va r. Remaining number of tries of an au-
thentication procedure (binary coding)
```
```
Volat ile At most once
'93' Non-volatile
'94'
Va r. Maximum usage counter (binary coding)
```
```
Volat ile
'95 Non-volatile At most once
'96'
Va r. Remaining usage counter (binary coding)
```
```
Volat ile
At most once
'97 Non-volatile
'98' Va r. Maximum number of signature crea-
tions (binary coding)
```
```
Volat ile At most once
'99 Non-volatile
'9A'
Va r. Remaining number of signature crea-tions (binary coding)
```
```
Volat ile
'9B Non-volatile At most once
'9C' 1 Non-repudiation flag (non-endorsed if value = '00') At most once
'9D' Va r. Maximum number of key generations (binary coding) At most once
'9E' Va r. Remaining number of key generations (binary coding) At most once
'A0' Va r. Security attribute extension for authentication objects
```
```
At most
one choice
among those
```
```
'A1' Va r. Security attribute extension for private keys
'A2' Va r. Security attribute extension for public keys
'A3' Va r. Security attribute extension for certificates
'A4' Va r. Security attribute extension for secret keys
'A5' 0 Security attribute extension for private Diffie-Hellman keysa
'AD' Va r. Security parameters template Any
'AF' Va r. Password properties template (see 9. 3 .7.1 2) Any
'B3' Va r. DOs specified by the DO'06' Any
'BE' Va r. Boolean expression At most once
NOTE 1 Other tags in the context-specific class are RFU.
NOTE 2 The value of a non-volatile counter is not related to physical channel enabling and disabling.
NOTE 3 The value of a volatile counter is impacted by physical channel enabling and disabling.
a The use of such a key is not subject to usage conditions, because it belongs to public domain parameters.
```
#### When a DO'AD' is referenced in a DO'9C' or a DO'9D', this DO'AD' or a tagged wrapper referencing it

#### shall belong to the same template as the security attribute extension.

#### The access mode byte in the security attribute extension indicates which functions or commands are

#### supported by the security object. When it is not used in a DO'AD', the access mode byte may also indicate

#### which operations can be performed on the security object.


#### If no SEID is provided in the security attribute referencing a DO'AD', this extension of the security

#### attribute may provide an SEID if necessary.

#### Table 42 — Coding of the access mode byte for authentication objects

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 - - - - - - - Bits b7 to b1 according to this table
1 - - - - - - - Bits b3 to b1 according to this table (bits b7 to b4 proprietary)
0 1 - - - - - - enable verification requirement
0 - 1 - - - - - disable verification requirement
0 - - 1 - - - - Proprietary use
0 - - - 1 - - - Proprietary use
```
- - - - - 1 - - reset retry counter
- - - - - - 1 - change reference data
- - - - - - - 1 verify

#### Table 43 — Coding of the access mode byte for private asymmetric keys

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 - - - - - - - Bits b7 to b1 according to this table
1 - - - - - - - Bit b5 proprietary, all other bits according to this table
```
- 1 - - - - - - pso Compute digital signature
- - 1 - - - - - pso Decipher
0 - - x - - - - 0 (any other value is RFU)
- - - - 1 - - - general authenticate
- - - - - 1 - - internal authenticate
- - - - - - 1 - generate asymmetric key pair
- - - - - - - 1 proprietary when used in the SPT, get attribute when used elsewhere

#### Table 44 — Coding of the access mode byte for public asymmetric keys and certificates

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 - - - - - - - Bits b7 to b1 according to this table
1 - - - - - - - Bit b5 proprietary, all other bits according to this table
```
- 1 - - - - - - pso Verify digital signature, Verify certificate
- - 1 - - - - - pso Encipher
0 - - x - - - - 0 (any other value is RFU)
- - - - 1 - - - general authenticate
- - - - - 1 - - external authenticate
- - - - - - 1 - generate asymmetric key pair
- - - - - - - 1 proprietary when used in the SPT, get attribute when used elsewhere

#### Table 45 — Coding of the access mode byte for secret keys

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 - - - - - - - Bits b7 to b1 according to this table
1 - - - - - - - Bit b4 proprietary, all other bits according to this table
```
- 1 - - - - - - pso encipher, compute cryptographic checksum
- - 1 - - - - - pso decipher, verify cryptographic checksum


```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
```
- - - 1 - - - - mutual authenticate/general authenticate
0 - - - x - - - 0 (any other value is RFU)
- - - - - 1 - - external authenticate/mutual authenticate
- - - - - - 1 - internal authenticate
- - - - - - - 1 proprietary when used in the SPT, get attribute when used elsewhere

#### 9.3.7.3 Sequence number

#### The successive instances of a DO'AD' shall correspond to increasing values of the sequence number. The

#### value of DO'80' is coded in binary, on one byte. The DOs'AD' referenced in a security condition byte (see

#### Table 31 ) shall have a number in the range '01' to '0E'.

#### 9.3.7.4 Key usage constraints indicator

#### The data element in DO'86' indicates certain constraints to the usage of a key (see Table 4 6). Within this

#### clause the following definitions are used:

#### — Preparation phase: the preparation phase consists of a C-RP or a sequence of C-RPs. The nature of

#### commands sent in the preparation phase is out of scope of this document.

#### — Usage phase: the usage phase consists of a C-RP or a sequence of C-RPs. The nature of commands

#### sent in the usage phase is out of scope of this document.

#### Table 46 — Coding of the key usage constraints

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
1 - - - - - - - At most one usage
```
- 1 - - - - - - Immediate usage
- - 1 - - - - - Details are provided in the OID reference
- - - x x x x x 00000 (any other value is RFU)

#### If bit b8 is set to

#### — 1 this indicates that for each key usage the preparation phase shall be performed.

#### — 0 this indicates that the key is usable more than once per preparation phase.

#### If bit b7 is set to

#### — 1 this indicates that the interface device is not allowed to send a C-RP between the preparation

#### phase and the usage phase on the logical channel used for key usage.

#### — 0 this indicates that the interface device may send one or several C-RP(s) between the preparation

#### phase and the usage phase, on arbitrary logical channels.

#### If bit b6 is set to

#### — 1 then the SPT containing the DO'86' shall contain a DO'06' and the OID reference shall provide

#### details for key usage constraints.

#### — 0 then the SPT containing the DO'86' may or may not contain a DO'06'.

#### Table 45 (continued)


#### Bits b5 to b1 of the key usage constraints indicator are RFU.

EXAMPLE 1 For signature keys granting non-repudiation the preparation phase typically consists of user
authentication (e.g. a verify command) and the usage phase typically contains e.g. zero, one or more pso hash
commands followed by e.g. a pso compute digital signature command.

EXAMPLE 2 For keys used in authentication procedures proving the authenticity of an external entity the
preparation phase typically contains the retrieval of a challenge from the card (e.g. by means of a get challenge
command) and the usage phase typically contains an authentication procedure (e.g. external authenticate
command).

#### 9.3.7.5 Number of tries

#### When the security object is used for authentication, the number of tries is limited to the value of DO'90'

#### or '91' in the data usage parameters nested in DO'AD'. The number of allowed remaining tries is given

#### by the value of DO'92' or '93'. The values of DO'90', '91, '92' and '93' are coded in binary.

#### 9.3.7.6 Number of uses

#### The number of uses of the security object is limited to the value of DO'94' or '95' in the data usage

#### parameters nested in DO'AD'. The number of allowed remaining uses is given by the value of DO'96' or

#### '97'. The values of DO'94', '95', 96' and '97' are coded in binary.

#### 9.3.7.7 Non-repudiation

#### When granting non-repudiation, a function can rely on a security object DO with this flag set in DO'9C',

#### i.e. to a value > 0. If this value is '00', the DO ('9C 01 00') cannot endorse non-repudiation.

#### 9.3.7.8 Security object numbering

#### If needed, security objects (reference data/passwords or keys/certificates) may have a number

#### contained in DO'82' (respectively '83'). The values of DO'82' and '83' are coded in binary, on one or

#### several byte(s). The first byte of the value may be used as object reference in commands handling basic

#### security (see 11.6 and Table 102 ). The value field may also be used when referencing the security data

#### object by a CRT (see DO'83', '84' in Table 56 ).

NOTE The constrains from Table 102 limit the range of possible values for the first byte of the value field if
that byte is intended to be used as object reference in a command handling basic security.

#### 9.3.7.9 Signature creation

#### If needed, the number of signature creations with the security object is limited to the value of DO'98' or

#### '99' in the data usage parameters nested in DO'AD'. The number of allowed remaining creations is given

#### by the value of DO'9A' or '9B'. The values of DO'98', '99', '9A' and '9B' are coded in binary.

#### 9.3.7.10 Key generation

#### If needed, the number of key generations with the security object is limited to the value of DO'9D' in the

#### data usage parameters nested in DO'AD'. The number of allowed remaining creations is given by the

#### value of DO'9E'. The values of DO'9D' and '9E' are coded in binary.

#### 9.3.7.11 Boolean expression

#### The Boolean expression DO'BE' under DO'AD' contains:

#### — a mandatory object identifier DO'06', which defines how to use the DOs which follow to build the

#### Boolean expression;

#### — one or several DOs of the context-specific class, referencing data or DOs with the same syntax as the

#### general reference DO'60' (see 11.5.2.1) or object locator DO'7F72' (see 9.3.4.3).


NOTE In 9.3.3, the last dash contains a requirement for the presence of a DO'BE'.

#### 9.3.7.12 Password properties template

#### The password properties template DO'AF' under DO'AD' contains password properties. A DO'06' may

#### be present in the password properties template.

#### If the password properties template

#### — contains an OID in a DO'06', that DO'06' shall be the first DO in the password template; the standard

#### or specification referenced by this OID shall specify further data objects enclosed in the password

#### properties template;

#### — does not contain a DO'06' then the template is in conformance to ISO/IEC 7816-15:2016, 8.9.2 and

#### may contain any DO from Table 47 in any order with the meaning and coding specified in Table 47.

#### Table 47 — Password properties template (DO'AF' under tag 'AD')

```
Tag Length Description
```
##### '81' 1

```
Verification data history length: the maximum number of verification data values that shall
be recorded and maintained. When the verification data is set, it shall be different from all
values in the verification data history.
The value of verification data history length shall be in the closed interval [0, 8].
Transport format for verification data and new reference data
```
##### '82' 1

```
— '00', direct: data transferred to the ICC is taken as it is (binary coding).
— '01', numeric: each character is encoded according to ISO/IEC 10646 [12] (UTF-8) and
shall be element of the closed interval ['30', '39']. Data transferred to the ICC shall
padded with 'FF' until maximum length characters are available.
— '03', alphanumeric, i.e. digit, upper and lower case ASCII: each character is encoded
according to ISO/IEC 10646 [12] (UTF-8) and shall be element of the closed interval
['30', '39'] or ['41', '5A'] or ['61', '7A']. Data transferred to the ICC shall padded with 'FF'
until maximum length characters are available.
— any other value is RFU.
'83' 1 Minimum length: minimum number of characters in verification data.
'84' 1 Maximum length: maximum number of characters in verification data.
NOTE Other tags in the context specific class are RFU.
```
#### 9.3.8 Security attributes for logical channels.....................................................................................................

#### A logical channel security attribute DO'8E' (at most one) may be present in the CPs of any file or DO (see

#### Table 11 ) and in any appropriate security environment (SE, see 10.4.4). It shall be interpreted according

#### to Table 4 8, where:

#### — "Non-shareable" means that at most one logical channel shall be available. The physical technology

#### of the logical channel may be limited.

#### — "Secured" means that SM keys (see Clause 10 ) shall be available (e.g. established by a previous

#### authentication).

#### — "User authenticated" means that the user shall be authenticated (e.g. a successful password

#### verification).


#### Table 48 — Coding of the logical channel security attribute

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 0 0 0 0 - - 1 Non-shareable
0 0 0 0 0 - 1 - Secured
0 0 0 0 0 1 - - User authenticated
NOTE Any other value is RFU.
```
### 9.4 Security support data elements

#### This subclause specifies a collection of security support data elements with rules governing the way

#### their values are handled. The security support data elements extend and refine the control reference

#### DOs. The card may provide them as generic support to security mechanisms performed by an

#### application. Applications may reference them for secure messaging and for security operations (see

#### ISO/IEC 7816-8). This subclause specifies neither some characteristics of the security support data

#### elements, e.g. their lengths, nor the algorithms that alter their value.

#### Table 49 — Security support DOs

```
Tag Value
'7A' Set of security support DOs with the following tags
'80' Card session counter
'81' Card session identifier
'82' to '8E'File selection counter
'93' Digital signature counter
'9F2X' Internal progression value ('X' is a specific index, e.g. an index referencing a counter of file
selections)
'9F3Y' External progression value ('Y' is a specific index, e.g. an index referencing an external time
s t a mp)
NOTE Under tag '7A', ISO/IEC JTC 1/SC 17 reserves any other DO of the context-specific class.
```
#### Principles — The card shall maintain and use the value of security support data elements as follows.

#### — Update is done with new values either computed by the card, or provided by the outside world, in

#### accordance with the specific rule for a specific type of security support data element.

#### — Update is performed before any output is produced for the command causing an update. The update

#### is independent of the completion status of the command. If the value is to be used by the application

#### in an operation that causes an update, the update is performed before the value is used.

#### — Access to application-specific security support data elements is restricted to functions performed

#### by the specific application.

NOTE The actual security achieved in a C-RP ultimately depends on the algorithms and protocols specified
by the application; the card only provides support with these data elements and associated usage rules.

#### Data elements — The card may support C-RP security with data elements called progression values.

#### Increased at specific events throughout the life of the card, these values are different each time the card

#### is activated. Two progression values are specified: a card session counter and a session identifier.

#### — The card session counter is incremented once during card activation.

#### — The session identifier is computed from the card session counter and from data provided by the

#### outside world.


#### Two types of progression values are specified.

#### — Internal progression values, if so specified for an application, register the number of times specific

#### events are performed. The data element shall be incremented after the event; the card may provide

#### a reset function for these counters which if so specified for an application sets its value to zero.

#### Internal progression values cannot be controlled by the outside world and are suitable for use as

#### secured in-card approximate representations of real time. Their values can be used in cryptographic

#### computations.

#### — External progression values, if so specified for an application, shall only be updated by a data value

#### from the outside world. The new value shall be numerically larger than the current value stored in

#### the card.

#### References — The card may provide access to the value of security support data elements as follows.

#### — An EF may be present in the MF, e.g. for a card session counter, or in an application DF, e.g. for

#### application-specific progression values.

#### — Auxiliary DOs, with tags '88', '92' and '93' (see Table 56 ) may be present in a control reference

#### template. These DOs can be used if the SE supports unambiguous use of these data elements.

#### — Within the interindustry DO'7A', the context-specific class is reserved for security support DOs as

#### listed in Table 49.

## 10 Secure messaging

### 10.1 General

#### Secure messaging (SM) protects all or part of a C-RP, or a concatenation of consecutive data fields

#### (payload fragmentation, see 5.3), by ensuring two basic security functions: data confidentiality and

#### data authentication. Secure messaging is achieved by applying one or more security mechanisms.

#### Possibly explicitly identified by a cryptographic mechanism identifier template (see 9.2) in the CPs of

#### any DF (see 7. 4), each security mechanism involves a cryptographic algorithm, a mode of operation, a

#### key, an argument (input data) and often, initial data.

#### — The transmission and reception of data fields may be interleaved with the processing of security

#### mechanisms. This specification does not preclude the determination by sequential analysis of which

#### mechanisms and which security items shall be used for processing the remaining part of the data field.

#### — Two or more security mechanisms may use the same cryptographic algorithm with different modes

#### of operation. The hereafter specified padding rules do not preclude such a feature.

### 10.2 SM fields and SM DOs

#### 10.2.1 SM protection of command payloads

#### An SM payload is an SM command or response SM field, irrespective of its length. If protection of the

#### payload by secure messaging takes place before possible fragmentation, an oversize SM payload is a

#### particular case of oversize ber-tlv coded payload, to which the rules given in 5.3 apply.

#### The format of the payload shall be as defined below (see 10. 5), except that its length is not limited by

#### the length formats and constraints which mandated chaining (see 5.3).

#### 10.2.2 SM protection of chained commands and responses

#### If there is a need to protect chained SM command or response data fields individually, fragmentation

#### according to 5.3 shall take place before C-RP protection. Each of the C-RPs shall then be protected (see

#### 10. 5) according to the requirements of the security environment.


#### Fragmentation will yield a sequence of command or response data fields with no ascertained structure.

#### The CLA INS P1 P2 bytes shall comply with the chaining rules used for fragmentation (see 5.3).

#### 10.2.3 SM DOs

#### Table 50 shows the SM DOs specified in this document, all in the context-specific class. Some SM DOs

#### (SM tags '82', '83', 'B0', 'B1') are recursive, i.e. the plain value field is an SM field.

#### In each SM field, bit b1 of the last byte of the tag field (tag parity) of each SM DO (context-specific class)

#### indicates whether the SM DO shall be included (bit b1 set to 1, odd tag number) or not (bit b1 set to 0,

#### even tag number) in the computation of a data element for authentication: cryptographic checksum (see

#### 10.3.3.2), or digital signature (see 10.3.3.3). If present, the DOs of the other classes (e.g. interindustry

#### DOs) shall be included in the computation. If such a computation occurs, the data element shall be the

#### value field of an SM DO for authentication (SM tags '8E', '9E') at the end of the SM field.

#### There are two categories of SM DOs.

#### — Each basic SM DO (see 10. 3) conveys a plain value, or an input or result of a security mechanism.

#### — Each auxiliary SM DO (see 10.4) conveys a control reference template, or a security environment

#### identifier, or a response descriptor template.

NOTE Basic SM DOs are also used to control security operations (see ISO/IEC 7816-8). Auxiliary SM DOs are
also used to manage security environment (see 11.6.11). The global approach to security by secure messaging
shares several security-related issues with the security operations, i.e. the atomic approach to security. Annex B
illustrates the synergy between the two approaches.

#### Table 50 — SM data objects

```
Tag Value
'80', '81' Plain value not encoded in ber-tlv
'82', '83' Cryptogram (plain value encoded in ber-tlv and including SM DOs i.e. an SM field)
'84', '85' Cryptogram (plain value encoded in ber-tlv, but not including SM DOs)
'86', '87' Padding-content indicator byte followed by cryptogram (plain value not encoded in ber-tlv)
'89' Command header (CLA INS P1 P2, four bytes)
'8E' Cryptographic checksum (at least four bytes)
'90', '91' Hash-code
'92', '93' Certificate (data not encoded in ber-tlv)
'94', '95' Security environment identifier (SEID)
'96', '97' One or two bytes encoding Le in the unsecured C-RP (possibly empty, see 10. 5)
'99' Processing status (SW1-SW2, two bytes; possibly empty)
'9A', '9B' Input data element for the computation of a digital signature (the value field is signed)
'9C', '9D' Public key
'9E' Digital signature
'A0', 'A1' Input template for the computation of a hash-code (the template is hashed)
'A2' Input template for the verification of a cryptographic checksum (the template is included)
'A4', 'A5' Control reference template for authentication (AT)
'A6', 'A7' Control reference template for key agreement (KAT)
'A8' Input template for the verification of a digital signature (the template is signed)
'AA', 'AB' Control reference template for hash-code (HT)
'AC', 'AD' Input template for the computation of a digital signature (the concatenated value fields are signed)
In order to use those SM DOs out of SM C-RPs, one shall encapsulate them in a DO'7D'.
NOTE In SM fields, ISO/IEC JTC 1/SC 17 reserves any other DO of the context-specific class.
```

```
Tag Value
'AE', 'AF' Input template for the verification of a certificate (the concatenated value fields are certified)
'B0', 'B1' Plain value encoded in ber-tlv and including SM DOs, i.e. an SM field
'B2', 'B3' Plain value encoded in ber-tlv, but not including SM DOs
'B4', 'B5' Control reference template for cryptographic checksum (CCT)
'B6', 'B7' Control reference template for digital signature (DST)
'B8', 'B9' Control reference template for confidentiality (CT)
'BA', 'BB' Response descriptor template
'BC', 'BD' Input template for the computation of a digital signature (the template is signed)
'BE' Input template for the verification of a certificate (the template is certified)
In order to use those SM DOs out of SM C-RPs, one shall encapsulate them in a DO'7D'.
NOTE In SM fields, ISO/IEC JTC 1/SC 17 reserves any other DO of the context-specific class.
```
### 10.3 Basic SM DOs

#### 10.3.1 SM DOs for encapsulating plain values

#### Encapsulation is mandatory for SM fields and for data not encoded in ber-tlv. It is optional for ber-tlv,

#### not including SM, DOs. Table 51 shows SM DOs for encapsulating plain values.

#### Table 51 — SM DOs for encapsulating plain values

```
Tag Value
'B0', 'B1' Plain value encoded in ber-tlv and including SM DOs (i.e. an SM field)
'B2', 'B3' Plain value encoded in ber-tlv, but not including SM DOs
'80', '81' Plain value not encoded in ber-tlv
'89' Command header (CLA INS P1 P2, four bytes)
'96', '97' One or two bytes encoding Le in the unsecured C-RP (possibly empty, see 10. 5)
'99' Processing status (SW1-SW2, two bytes; possibly empty)
```
#### 10.3.2 SM DOs for confidentiality

#### Table 52 shows SM DOs for confidentiality. A security mechanism for confidentiality consists of an

#### appropriate cryptographic algorithm in an appropriate mode of operation. In the absence of explicit

#### indication and when no mechanism is implicitly selected for confidentiality, a default mechanism

#### shall apply.

#### — For computing a cryptogram to be preceded by a padding indication, the default mechanism is a

#### block cipher in “electronic code book” mode, which may involve padding. Padding for confidentiality

#### may have an influence on transmission: the cryptogram (one or more blocks) may be longer than

#### the plain value.

#### — For computing a cryptogram not to be preceded by a padding indication, the default mechanism is a

#### stream cipher. In this case, the cryptogram is the exclusive-or of the string of data bytes to conceal

#### with a concealing string of the same length. Concealment thus requires no padding and the string of

#### data bytes is recovered by the same operation.

#### Padding and/or content shall be indicated when the plain value is not encoded in ber-tlv. If padding

#### applies but is not indicated, the rules specified in 10.3.3.2 apply.

#### Table 53 shows the padding-content indicator byte.

#### Table 50 (continued)


#### Table 52 — SM DOs for confidentiality

```
Tag Value
'82', '83' Cryptogram (plain value encoded in ber-tlv and including SM DOs, i.e. an SM field)
'84', '85' Cryptogram (plain value encoded in ber-tlv, but not including SM DOs)
'86', '87' Padding-content indicator byte (see Table 53 ) followed by cryptogram (plain value not encoded in
ber-tlv)
```
#### Table 53 — Padding-content indicator byte

```
Value Meaning
'00' No further indication
'01' Padding as specified in 10.3.3.2
'02' No padding
'1X' One to four secret keys for enciphering information, not keys ('X' is a bitmap with any value from
'0' to 'F')
'11' indicates the first key (e.g. an “even” control word in a pay TV system)
'12' indicates the second key (e.g. an “odd” control word in a pay TV system)
'13' indicates the first key followed by the second key (e.g. a pair of control words in a pay
TV system)
'2X' Secret key for enciphering keys, not information ('X' is a reference with any value from '0' to 'F')
(e.g. in a pay TV system, either an operational key for enciphering control words, or a manage-
ment key for enciphering operational keys)
'3X' Private key of an asymmetric key pair ('X' is a reference with any value from '0' to 'F')
'4X' Password ('X' is a reference with any value from '0' to 'F')
'80' to '8E'Proprietary
NOTE Any other value is RFU.
```
#### 10.3.3 SM DOs for authentication

#### 10.3.3.1 General

#### Table 5 4 shows SM DOs for authentication.

#### Table 54 — SM DOs for authentication

```
Tag Value
'8E' Cryptographic checksum (at least four bytes)
'90', '91' Hash-code
'92', '93' Certificate (data not encoded in ber-tlv)
'9C', '9D' Public key
'9E' Digital signature
Input DOs (see also ISO/IEC 7816-8)
'9A', '9B' Input data element for the computation of a digital signature (the value field is signed)
'A0', 'A1' Input template for the computation of a hash-code (the template is hashed)
'A2' Input template for the verification of a cryptographic checksum (the template is included)
'A8' Input template for the verification of a digital signature (the template is signed)
'AC', 'AD' Input template for the computation of a digital signature (the concatenated value fields are signed)
'AE', 'AF' Input template for the verification of a certificate (the concatenated value fields are certified)
'BC', 'BD' Input template for the computation of a digital signature (the template is signed)
'BE' Input template for the verification of a certificate (the template is certified)
```

#### 10.3.3.2 Cryptographic checksum data element

#### The computation of a cryptographic checksum involves an initial check block, a secret key

#### and either a block cipher algorithm [see ISO/IEC 18033 (all parts)[18]], or a hash-function [see

#### ISO/IEC 10118 (all parts)[10]].

#### The computation method may be part of the system specifications. Alternatively, a cryptographic

#### mechanism identifier template (see 9.2) may identify a standard (e.g. ISO/IEC 9797-1) fixing a

#### computation method.

#### Unless otherwise specified, the following computation method shall be used. The parameters used in

#### this computation method may be defined in the relevant CRT (see Table 56 ). This document does not

#### define a default CRT.

#### Under the control of the key, the algorithm basically converts a current input block of k bytes (typically

#### 8, 16 or 20) into a current output block of the same size. The computation is performed in the following

#### consecutive stages.

#### Initial stage — The initial stage shall set either one of the following blocks as the initial check block:

#### — the null block, i.e. k bytes set to '00',

#### — the chaining block, i.e. a result from former computations, namely for a command, the final check

#### block of the previous command and for a response, the final check block of the previous response,

#### — the initial value block provided e.g. by the outside world,

#### — the auxiliary block resulting from converting auxiliary data under the control of the key. If the

#### auxiliary data is less than k bytes, then bits set to 0 head it up to the block size.

#### Sequential stage(s) — The command header (CLA INS P1 P2) may be encapsulated for protection (SM

#### tag '89'). However, if bits b8 to b6 of CLA are set to 000 and bits b4 and b3 to 11 (see 5.4.1), then the first

#### data block consists of the command header (CLA INS P1 P2) followed by one byte set to '80' and k–5

#### bytes set to '00'.

#### The cryptographic checksum shall include any secure messaging DO having an odd tag number and any

#### DO with the first byte not from '80' to 'BF'. Those DOs shall be included data block by data block in the

#### current check block. The splitting into data blocks shall be performed as follows.

#### — The blocking shall be continuous at the border between adjacent DOs included in the cryptographic

#### checksum.

#### — The padding shall apply at the end of each block followed by either a DO not included in the

#### cryptographic checksum, or no further DO. The padding consists of one mandatory byte set to '80'

#### followed, if needed, by 0 to k–1 bytes set to '00', until the respective data block is filled up to k

#### bytes. Padding for authentication has no influence on transmission as the padding bytes shall not

#### be transmitted.

#### Figure 6 shows two examples of deriving data from C-APDU for computation of the cryptographic

#### checksum. In these examples, candidate data consists of command header and DOs in command data

#### field as same order. DOs not to include are removed and paddings are added.


#### Figure 6 — Examples of deriving data from C-APDU for computaion of cryptographic checksum

#### In this mechanism, the mode of operation is “cipher block chaining” (see ISO/IEC 10116 [9]). The first

#### input is the exclusive-or of the initial check block with the first data block. The first output results from

#### the first input. The current input is the exclusive-or of the previous output with the current data block.

#### The current output results from the current input.

#### Final stage — The final check block is the last output. The final stage extracts a cryptographic

#### checksum (first m bytes, at least four) from the final check block.

#### 10.3.3.3 Digital signature data element

#### The digital signature schemes rely on asymmetric cryptographic techniques [see

#### ISO/IEC 9796 (all parts)[6], ISO/IEC 14888 (all parts)[15]]. The computation implies a hash-function [see

#### ISO/IEC 10118 (all parts)[10]]. The data input consists of the value field of a digital signature input DO,

#### or of the concatenation of the value fields of DOs forming a digital signature input template. It may be

#### determined by the mechanism specified in 10.3.3.2.

### 10.4 Auxiliary SM DOs

#### 10.4.1 General...................................................................................................................................................................................

#### Table 55 shows auxiliary SM DOs.

#### Table 55 — Auxiliary SM DOs

```
Tag Value
'94', '95' Security environment identifier (SEID)
'A4', 'A5' Control reference template for authentication (AT)
'A6', 'A7' Control reference template for key agreement (KAT)
'AA', 'AB' Control reference template for hash-code (HT)
'B4', 'B5' Control reference template for cryptographic checksum (CCT)
'B6', 'B7' Control reference template for digital signature (DST)
'B8', 'B9' Control reference template for confidentiality (CT)
'BA', 'BB' Response descriptor template
```

#### 10.4.2 Control reference templates

#### Six control reference templates are defined for the purpose of authentication (AT), key agreement

#### (KAT), hash-code (HT), cryptographic checksum (CCT), digital signature (DST) and confidentiality

#### (CT) using either symmetric or asymmetric cryptographic techniques (CT-sym and CT-asym).

#### Each security mechanism involves a cryptographic algorithm in a mode of operation and uses a key and,

#### possibly, initial data. Such items are selected either implicitly, i.e. known before issuing the command,

#### or explicitly, i.e. by control reference DOs nested in control reference templates. Within the control

#### reference templates, the context-specific class is reserved for control reference DOs.

#### In an SM field, the last possible position of a control reference template is just before the first DO to

#### which the mechanism indicated in the CRT applies. For example, the last position of a CCT is just before

#### the first DO to include in the computation.

#### Each control reference remains valid until a new control reference is provided for the same mechanism.

#### For example, a command may provide control references for the next command.

#### 10.4.3 Control reference DOs in control reference templates

#### Each control reference template (CRT) is a set of control reference DOs: a cryptographic mechanism

#### reference, a file and key reference, an initial data reference, a usage qualifier and, only in a control

#### reference template for confidentiality, a cryptogram content reference.

#### — The cryptographic mechanism reference denotes a cryptographic algorithm in a mode of operation.

#### The CPs of any DF (see tag 'AC' in Table 11 ) may contain cryptographic mechanism identifier

#### templates (see 9.2). Each one indicates the meaning of a cryptographic mechanism reference.

#### — The file reference (same encoding as in 7. 3. 2 ) denotes the file where the key reference is valid. If no

#### file reference is present, then the key reference is valid in the DF referenced by curDF, possibly an

#### application DF. The key reference unambiguously identifies the key to use.

#### — The initial data reference, when applied to cryptographic checksums, indicates the initial check

#### block. If no initial data reference is present and no initial check block implicitly selected, then the

#### null block applies. Moreover, before transmitting the first DO for confidentiality using a stream

#### cipher, a template for confidentiality shall provide auxiliary data for initializing the computation of

#### the string of concealing bytes.

#### Table 56 lists control reference DOs and indicates to which control reference template they are relevant.

#### All the control reference DOs are in the context-specific class.

#### A CRT may contain interindustry DOs, e.g. certificate holder authorization (tag '5F4C', see 10.4.4) in

#### AT, header list or extended header list (tags '5D' and '4D', see 8.4.4 to 8.4.7) in HT or DST. In any control

#### reference template, a key usage template under tag 'A3' may associate a file and key reference with a

#### key usage counter and/or a key retry counter. The key usage template contains a set of key usage DOs

#### (se e Table 57 ).


#### Table 56 — Control reference DOs in control reference templates

```
Tag Value AT KAT HT CCT DST CT-asymCT-sym
'80' Cryptographic mechanism reference x x x x x x x
File and security object references
'81' — File reference (for encoding, see 7. 3. 2 ) x x x x x x x
'82' — DF name (see 7. 3 .1) x x x x x x x
```
##### '83'

```
— Reference of a secret key (for direct use) x x x x x
— Reference of a public key x x x x x
— Reference data x
```
```
'84'
```
```
— Reference for computing a session key x x x x
— Reference of a private key x x x x
'A3' Key usage template (see text below) x x x x x x x
Initial data reference: Initial check block
'85' — L=0, null block x x x
'86' — L=0, chaining block x x x
'87' — L=0, previous initial value block plus one L=k, initial value block^ x x^ x^ x
Initial data reference: Auxiliary data elements (see also 10.3.3.2)
```
```
'88'
```
```
— L=0, previous exchanged challenge plus
one
L>0, no further indication
```
```
x x x x
```
```
'89' to
'8D'
```
```
— L=0, index of a proprietary data element
L>0, value of a proprietary data element
```
```
x
x
```
```
x
```
```
'90' — L=0, hash-code provided by the card x x
'91' — L=0, random number provided by the card L>0, random number^ x^ x x^ x xx^
```
```
'92' — L=0, time stamp provided by the card L>0, time stamp^ x^ xx^ xx^
```
##### '93'

```
— L=0, previous digital signature counter
plus one
L>0, digital signature counter
```
```
x x
x
```
```
x
x
```
```
x
x
```
```
'94' Challenge or data element for deriving a key x x x
```
```
'95' Usage qualifier byte (see text below) x x x x x x
'8E' Cryptogram content reference (see text
below)
```
```
x x
```
```
NOTE In a control reference template, ISO/IEC JTC 1/SC 17 reserves any other DO of the context-specific class.
```
#### Table 57 — Key usage DOs

```
Tag Value
'80' to '84' File and key references as specified in Table 56
'90' Key usage counter
'91' Key retry counter
NOTE In this context, ISO/IEC JTC 1/SC 17 reserves any other DO of the context-
specific class.
```
#### In any control reference template for authentication (AT), for key agreement (KAT), for cryptographic

#### checksum (CCT), for confidentiality (CT) or for digital signature (DST), a usage qualifier byte (tag

#### '95') may specify the usage of the template either as a security condition (see 9.3.4 and Table 34 ), or


#### in compliance with the manage security environment command (see 11.6.11). Table 58 shows the

#### usage qualifier byte.

#### Table 58 — Coding of the usage qualifier byte

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
1 - - - - - - - Verification (DST, CCT), Encipherment (CT),External authentication (AT), Key agreement (KAT)^
```
- 1 - - - - - - Computation (DST, CCT), Decipherment (CT),Internal authentication (AT), Key agreement (KAT)^
- - 1 - - - - - Secure messaging in response data fields (CCT, CT, DST)
- - - 1 - - - - Secure messaging in command data fields (CCT, CT, DST)
- - - - 1 - - - User authentication, password based (AT)
- - - - - 1 - - User authentication, biometry based (AT)
- - - - - - x x 00 (any other value is RFU)

#### In any control reference template for confidentiality (CT), a cryptogram content reference (tag '8E')

#### may specify the content of the cryptogram. The first byte of the value field is mandatory; its name is the

#### cryptogram descriptor byte. Table 59 shows the cryptogram descriptor byte.

#### Table 59 — Cryptogram descriptor byte

```
Value Meaning
'00' No further indication
```
##### '1X'

```
One to four secret keys for enciphering information, not keys ('X' is a bitmap with any value from
'0' to 'F')
'11' indicates the first key (e.g. an “even” control word in a pay TV system)
'12' indicates the second key (e.g. an “odd” control word in a pay TV system)
'13' indicates the first key followed by the second key (e.g. a pair of control words in a pay TV
system)
```
```
'2X'
```
```
Secret key for enciphering keys, not information ('X' is a reference with any value from '0' to 'F')
(e.g. in a pay TV system, either an operational key for enciphering control words, or a management
key for enciphering operational keys)
'3X' Private key of an asymmetric key pair ('X' is a reference with any value from '0' to 'F')
'4X' Password ('X' is a reference with any value from '0' to 'F')
'80' to 'FF' Proprietary
NOTE Any other value is RFU.
```
#### 10.4.4 Security environments.............................................................................................................................................

#### This clause specifies security environments (SE) for referencing cryptographic algorithms, modes of

#### operation, protocols, procedures, keys and any additional data needed for secure messaging and for

#### security operations (see ISO/IEC 7816-8). An SE consists of data elements stored in the card or resulting

#### from some computation, to be processed by the specified algorithms. An SE may contain a mechanism

#### to initialise non-persistent data to be used in the environment, e.g. a session key. An SE may provide

#### directions for handling computation results, e.g. storage in the card. An interindustry SE template (tag

#### '7B') describes an SE.

#### SE identifier — An SE identifier (SEID) may reference any security environment, e.g. for secure

#### messaging and for storing and restoring by a manage security environment command (see 11.6.11).

#### — Unless otherwise specified by the application, the value '00' denotes an empty environment where

#### no secure messaging and no authentication are defined.

#### — The value 'FF' denotes that no operation can be performed in this environment.


#### — Unless otherwise specified by the application, the value '01' is reserved for the default SE, always

#### available. This subclause does not specify the content of the default SE; it may be empty.

#### — The value 'EF' is RFU.

#### Components — Control reference templates (CRT) may describe various components of an SE. Any

#### relative control reference (files, keys or data) specified with a mechanism in the environment definition

#### shall be resolved with respect to curDF selected before using the mechanism. There is no need to resolve

#### absolute control references (e.g. absolute path). Within an SE, components may have two aspects: one

#### being valid for SM in command data fields and the other for SM in response data fields.

#### At any time during card operation, a current SE shall be active, either by default or as a result of

#### commands performed by the card. The current SE contains one or more components among the

#### following components.

#### — Some components belong to the default SE associated with curDF.

#### — Some components are transmitted in commands using secure messaging.

#### — Some components are transmitted in manage security environment commands.

#### — Some components are invoked by an SEID in a manage security environment command.

#### The current SE is valid until

#### — disabling a physical interface (see 5.1 ), or

#### — resetting a logical channel (see 11.2.3), or

#### — a change of VA (e.g. a change of curDF), or

#### — a manage security environment command (see 11.6.11) setting or replacing the current SE.

#### In SM, control reference DOs transmitted in a CRT shall take precedence over any corresponding control

#### reference DO present in the current SE.

#### Certificate holder authorization — Authentication procedures may use card-verifiable certificates,

#### i.e. templates that can be interpreted and verified by the card by a verify certificate operation using

#### a public key (see ISO/IEC 7816-8). In such a certificate, a certificate holder authorization (e.g. a role

#### identifier) may be conveyed in an interindustry DO'5F4C'. If such a data element is used in the security

#### conditions to fulfil for accessing data or functions, then DO'5F4C' shall be present in the control

#### reference template for authentication (AT) describing the authentication procedure.

NOTE In the first edition of ISO/IEC 7816-9, tag '5F4B' references a certificate holder authorization (data
element of five or more bytes). In amendment 1 to the first edition of ISO/IEC 7816-6, tag '5F4B' references
an integrated circuit manufacturer identifier (1-byte data element). Consequently, tag '5F4B' is deprecated in
ISO/IEC 7816 (all parts)[4].

#### Access control — The card may store security environments used for access control within EFs (see

#### tag '8D' in Table 11 ) containing interindustry SE templates (tag '7B'). An application may store DOs'7B'

#### in the VA set by application selection (e.g. 1st generation DOs). Within the interindustry SE template (tag

#### '7B'), the context-specific class is reserved for security environment DOs. As listed in Table 6 0 for every

#### included SE, the security environment template contains an SEID DO'80', an optional LCS DO'8A', one

#### or more optional cryptographic mechanism identifier template(s) (tag 'AC') and one or more CRTs (tags

#### 'A4', 'A6', 'AA', 'B4', 'B6', 'B8', as SM tags).


#### Table 60 — Security environment DOs

```
Tag Value
'80' SEID (1byte, mandatory)
'8A' LCS (1 byte, see 7. 4 .10 and Table 15 ), optional
'AC' Cryptographic mechanism identifier template (see optional 9.2),
'A4', 'A6', 'AA', 'B4', B6', 'B8' CRTs (see 10.4.2)
NOTE Under tag '7B', ISO/IEC JTC 1/SC 17 reserves any other DO of the context-specific class.
```
#### An SE template is applicable to a structure (see Clause 7 ) only if the value of DO'8A' of that SE template

#### matches the LCS of the structure (e.g. see DO'8A' in Table 11 ). If no DO'8A' is present in an SE template,

#### then that SE template is valid only for the Operational state (activated).

#### In the SE template, if a CRT carries several DOs with the same tag (e.g. DOs specifying a key reference),

#### then at least one of the DOs shall be fulfilled (OR condition).

#### SE retrieval — Any CRT in the current SE may be retrieved by a get data command with INS set to 'CA',

#### P1-P2 set to '004D' (extended header, see 8.4.5) and a command data field consisting of an SE template

#### (tag '7B') containing one or more pairs, each one consisting of a CRT tag followed by '80' (see 8.4.1 for

#### the use of a length set to '80' in an extended header). One may also use the GET option of the manage

#### security environment command.

#### 10.4.5 Response descriptor template

#### Each command data field may contain a response descriptor template. If present in the command data

#### field, the response descriptor template shall indicate the SM DOs required in the response data field.

#### Inside the response descriptor template, the security mechanisms are not yet applied; the receiving

#### entity shall apply them for constructing the response data field. The security items (algorithms, modes

#### of operation, keys and initial data) used for processing the command data field may be different from

#### those used for producing the response data field. The following rules apply.

#### — The card shall fill each empty primitive basic SM DO.

#### — Each CRT present in the response descriptor template shall be present in the response at the same

#### place with the same control reference DOs for security mechanisms, files and keys.

#### — If the response descriptor template provides auxiliary data, then the respective DO shall be

#### empty in the response.

#### — If an empty reference DO for auxiliary data is present in the response descriptor template, then

#### it shall be full in the response.

#### — By the relevant security mechanisms, with the selected security items, the card shall produce all

#### the requested basic SM DOs.

### 10.5 SM impact on command-response pairs

#### Figure 7 illustrates a C-RP.

#### Figure 7 — Command-response pair


#### The following rules apply for securing a C-RP of the interindustry class (see 5.4.1), i.e. when switching

#### either bit b4 from 0 to 1 in CLA where bits b8, b7 and b6 are set to 000, or bit b6 from 0 to 1 in CLA

#### where bits b8 and b7 are set to 01. The notation CLA* means that secure messaging is indicated in CLA.

#### — The secured command data field is an SM field; it shall be formed as follows.

#### — If a command data field is present ( Nc > 0), then either a plain value DO (SM tags '80', '81', 'B2',

#### 'B3'), or a DO for confidentiality (SM tags '84', '85', '86', '87') shall convey the Nc bytes.

#### — The command header (four bytes) may be encapsulated for protection (SM tag '89').

#### — If an Le field is present, then a new Le field (containing only bytes set to '00') and an Le DO

#### (SM tags '96', '97') shall be present. If present, the value of an Le DO shall provide the Le for

#### the unprotected response. An empty Le DO ('9600' or '9700') means the maximum, i.e. 256 or

#### 65 536 depending upon whether the new Le field is short or extended. Otherwise, if the Le field

#### for the unprotected response consists of:

#### — one byte, this byte shall become the value field of the Le DO;

#### — two bytes, these two bytes shall become the value field of the Le DO;

#### — three bytes, i.e. one byte set to '00' followed by two bytes with any value, the two bytes

#### shall become the value field of the Le DO.

#### WARNING — Some implementations encode a three byte Le field into an Le DO with a 3-byte

#### value field.

#### — The secured response data field is an SM field; it shall be interpreted as follows.

#### — If present, a plain value DO (SM tags '80', '81', 'B2', 'B3') or a DO for confidentiality (SM tags '84',

#### '85', '86', '87') conveys the response data bytes.

#### — If present, a processing status DO (SM tag '99') conveys SW1-SW2 encapsulated for protection.

#### The empty processing status DO means SW1-SW2 set to '9000'.

#### Figure 8 shows the corresponding secured C-RP.

#### Figure 8 — Secured command-response pair

#### When bit b1 of INS is set to 1 (odd INS code, see 5.5), the unsecured data fields are encoded in ber-tlv

#### and SM tags 'B2', 'B3', '84' and '85' shall be used for their encapsulation; unless the use of tags '80', '81',

#### '86' and '87' is specified at application level.

#### Otherwise (even INS code, see 5.5), as the format of the data fields to protect is not always apparent, SM

#### tags '80', '81', '86' and '87' are recommended.

#### — The secured data fields are SM fields; they may contain further or other SM DOs, e.g. a cryptographic

#### checksum (SM tag '8E') or a digital signature (SM tag '9E') at the end.

#### — The new Lc field encodes the number of bytes in the secured command data field.

#### — The new Le field shall be absent when no data field is expected in the secured response data field;

#### otherwise, it shall contain only bytes set to '00'.


#### — The response trailer indicates the status of the receiving entity after processing the secured

#### command. The following specific error conditions may occur.

#### — If SW1-SW2 is set to '6987', then expected secure messaging DOs are missing.

#### — If SW1-SW2 is set to '6988', then secure messaging DOs are incorrect.

#### Annex B provides illustrative examples of secure messaging.

## 11 Commands for interchange

### 11.1 General

#### This clause specifies commands for interchange. It shall not be mandatory for all cards complying

#### with this document to support all those commands or all the options of a supported command. When

#### interchange is required, a set of application-independent card services and related commands and

#### options shall be used as specified in Clause 12.

### 11.2 Selection.....................................................................................................................................................................................................

#### 11.2.1 General...................................................................................................................................................................................

#### After enabling a physical interface (see 5.1), the VA on the basic logical channel is as defined in 7.2.2. The

#### historical bytes (see 12.2.2) or the initial data string (see 12.2.3) may indicate an implicitly selected

#### application.

#### 11.2.2 covers the selection of files, applications and DOs. Additional DO selection functions are covered

#### in 11.5.2.

NOTE Because it is impossible to use a short EF identifier in a select/select data command, the FCP DO'A2'
of DFs are irrelevant for a select/select data command. Thus indirect file referencing (see 7. 4 .11) never occurs
during the processing of a select/select data command.

#### 11.2.2 select command

#### Table 61 shows the select C-RP. When completed, the command opens the logical channel (see 5.4.2)

#### numbered in CLA (see 5.4.1), if not yet opened, and sets a current structure within that logical channel.

#### Subsequent commands may implicitly refer to the current structure through that logical channel.

#### The selected DF (MF, application DF, DF) becomes current in the logical channel [see 7.2.2 rules d) and

#### e)]. The previously selected DF, if any, is no longer referred to through that logical channel. After such a

#### selection, an implicit EF referenced by curEF may be referred to through that logical channel.

#### The selection of an EF sets a pair of current files: the EF and its parent DF [see 7.2.2 rule f )].


#### Table 61 — select command-response pair

```
CLA As defined in 5.4.1
INS 'A4'
P1 See Table 62
P2 See Table 63
Lc field Absent for encoding Nc = 0, present for encoding Nc > 0
Data field Absent or file identifier or path or DF name or tag (according to P1)
Le field Absent for encoding Ne = 0, present for encoding Ne > 0
```
```
Data field Absent or control information (according to P2)
SW1-SW2 See Table 6 and Table 7 when relevant, e.g. '6283', '6284', '6A80', '6A81', '6A82', '6A86', '6A87', '6A88'
```
#### Table 62 — Coding of P1 in the select command

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning Command data field
0 0 0 0 0 0 x x Selection by file identifier
0 0 0 0 0 0 0 0 Select MF, DF or EF File identifier or absent
0 0 0 0 0 0 0 1 Select child DF File identifier referencing a DF
0 0 0 0 0 0 1 0 Select EF under the DF referenced by curDF File identifier referencing an EF
```
```
0 0 0 0 0 0 1 1 Select parent DF of the DF referenced by curDF - Absent
0 0 0 0 0 1 x x Selection by DF name
0 0 0 0 0 1 0 0 Select by DF name e.g. (truncated) application identifier
0 0 0 0 1 0 x x Selection by path
0 0 0 0 1 0 0 0 Select from the MF Path without the MF identifier
0 0 0 0 1 0 0 1 Select from the DF referenced by curDF Path without the file identifier of the DF referenced by curDF
0 0 0 1 0 0 x x Selection of DO
0 0 0 1 0 0 0 0 Select a DO in the template referenced by curConstructedDO - Tag belonging to the template referenced by curConstructedDO
```
##### 0 0 0 1 0 0 1 1

```
Select parent DO of the construct-
ed DO setting the template refer-
enced by curConstructedDO
```
```
Absent
```
NOTE 1 Any other value is RFU.
NOTE 2 When present in the historical bytes (see 12.2.2) or in EF .ATR/ INFO (see 12.3.3), the first software function table
(see Table 125 ) indicates selection methods supported by the card.


#### Table 63 — Coding of P2 in the select command

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 0 0 0 - - x x File or DO occurrence
0 0 0 0 - - 0 0 — First or only occurrence
0 0 0 0 - - 0 1 — Last occurrence
0 0 0 0 - - 1 0 — Next occurrence
0 0 0 0 - - 1 1 — Previous occurrence
0 0 0 0 x x - - Response data field requirements (see 7.4.2 and Table 9)
0 0 0 0 0 0 - - — Return FCI template, optional use of FCI tag and length
0 0 0 0 0 1 - - — Return CP template, mandatory use of CP tag and length
```
##### 0 0 0 0 1 0 - -

```
— Return FMD template, mandatory use of FMD tag and length
— Return the tags belonging to the template set by the selection of a
constructed DO as a tag list
0 0 0 0 1 1 - - — No response data if Le field absent, or proprietary if Le field present
NOTE Any other value is RFU.
```
#### Unless otherwise specified, the following rules apply to each open logical channel within a hierarchy of

#### DFs.

#### — If curEF is changed, or when curEF is not set, then the security status, if any, specific to the previously

#### selected EF shall be revoked.

#### — If the DF referenced by curDF is a descendant of, or identical to the previously selected DF, then the

#### security status specific to the previously selected DF shall be maintained.

#### — If the DF referenced by curDF is neither a descendant of, nor identical to the previously selected DF,

#### then the security status specific to the previously selected DF shall be revoked. The security status

#### common to all common ancestors of the previously selected DF and the new DF referenced by curDF

#### shall be maintained.

#### If P1 is set to '00', then the card knows whether the file to select is the MF, a DF or an EF, either because

#### of a specific encoding of the file identifier, or because of the command processing context. If P2 is also

#### set to '00' and the command data field

#### — provides a file identifier, then that file identifier shall be unique in the following three environments:

#### the immediate children of the DF referenced by curDF, the parent DF and the immediate children of

#### the parent DF;

#### — is absent or set to '3F00', then the MF shall be selected.

#### If P1 is set to '04', then the command data field is a DF name, which may be an application identifier

#### (se e 12.3.4), possibly right truncated. If supported, successive such commands with the same data field

#### shall select DFs whose names match with the data field, i.e. start with the command data field. If the

#### card accepts the select command without data field, then all or a subset of the DFs can be successively

#### selected.

#### If P1 is set to '10', then the command data field is a tag belonging to the template referenced by

#### curConstructedDO. The selected DO becomes the DO referenced by curDO. If the selected DO is

#### constructed, curConstructedDO is set to the selected DO. For handling multiple instances of DOs, the

#### use of bits b1 b2 in P2 (see Table 63) is mandatory.

#### If the Le field contains only bytes set to '00', then all the bytes corresponding to the selection option

#### should be returned within the limit of 256 for a short Le field, or 65 536 for an extended Le field. If the

#### Le field is absent, the available control information (CPs and/or FMDs) of the selected structure may be

#### recovered through DO handling (see 11.5.3 and 11.5.4).


#### 11.2.3 manage channel command

#### Table 6 4 shows the manage channel C-RP. When completed, the command opens or closes a logical

#### channel (see 5.4.2) other than the basic one, i.e. a logical channel numbered from one to nineteen (the

#### greater numbers are RFU). The reset function may apply to any logical channel.

#### The open function opens an additional logical channel other than the basic logical channel. Options are

#### provided for the card to assign a channel number, or for a channel number to be supplied to the card.

#### — If bits b8 and b7 of P1 are set to 00 (i.e. P1 set to '00' because the other six bits are RFU), then

#### manage channel shall open a logical channel numbered from one to nineteen as follows.

#### — If P2 is set to '00', then the response data field shall consist of a single byte for encoding a non-

#### zero channel number assigned by the card from '01' to '13'.

#### — If P2 is set from '01' to '13', then it encodes an externally assigned non-zero channel number and

#### the Le field shall be absent.

#### — After an open function performed from the basic logical channel (CLA encoding zero as channel

#### number), the MF or a default application DF shall be implicitly selected as the DF referenced by

#### curDF on the new logical channel.

#### — After an open function performed from a non-basic logical channel (CLA encoding a non-zero channel

#### number), the DF referenced by curDF on the logical channel numbered in CLA shall be selected

#### according to 7.2.2 rule e) on the new logical channel.

#### The close function explicitly closes a logical channel other than the basic one. The Le field shall be

#### absent. After closing, the logical channel shall be available for re-use. If bits b8 and b7 of P1 are set to

#### 10 (i.e. P1 set to '80' because the other six bits are RFU), then manage channel shall close a logical

#### channel numbered from 1 to nineteen as follows.

#### — If P2 is set to '00', then the logical channel numbered in CLA (a non-zero channel number) shall

#### be closed.

#### — If P2 is set from '01' to '13', then the logical channel numbered in P2 shall be closed.

#### WARNING — The close function may be aborted if CLA indicates neither the basic logical channel

#### nor the logical channel numbered in P2. P1-P2 codings in the range '8001' to '8013' will be

#### deprecated in the future.

#### The reset function explicitly closes and opens again any logical channel defined by CLA. The Le field

#### shall be absent. After resetting, the VA on the logical channel is defined by 7.2.2. The security status set

#### on this logical channel shall be revoked.

#### The command which resets the basic logical channel and closes all additional logical channels shall be

#### sent on the basic logical channel.

NOTE At APDU level, this function (P1-P2='4001') is equivalent to enabling a physical interface (see 5.1).


#### Table 64 — manage channel command-response pair

```
CLA As defined in 5.4.1
INS '70'
```
##### P1-P2

```
'0000' Open a logical channel to be numbered in the response data field
'0001' to '0013' Open the logical channel numbered in P2
'8000' Close the logical channel numbered in CLA (other than the basic logical channel)
'8001' to '8013'Close the logical channel numbered in P2
'4000' Reset the logical channel numbered in CLA
'4001' Reset the basic logical channel and closes all additional logical channels
other values RFU
Lc field Absent for encoding Nc = 0
Data field Absent
Le field Absent for encoding Ne = 0, present for encoding Ne > 0
```
```
Data field Absent (P1-P2 not set to '0000'), or '01' to '13' (P1-P2 set to '0000')
SW1-SW2 See Table 6 and Table 7 when relevant, e.g. '6200', '6482', '6881', '6A81'
```
### 11.3 Data unit handling

#### 11.3.1 Data units

#### Within each EF supporting data units, an offset shall reference each data unit. From zero for the first

#### data unit of the EF, the offset is incremented by one for each subsequent data unit. The offset data

#### element is binary encoded on the minimum number of bytes. Reference to a data unit not contained in

#### the EF is an error.

#### The card can provide a data coding byte (see Table 126 ) in the historical bytes (see 12.2.2), in EF .ATR/

#### INFO (see 12.3.3) and in the control information of any file (see DO'82' in Table 11 ). The data coding

#### byte fixes a data unit size. If the card provides data coding bytes in several places, then 7. 4. 5 specifies

#### which data coding byte shall be taken into account.

#### 11.3.2 General...................................................................................................................................................................................

#### Any command of this group shall be aborted if applied to an EF not supporting data units. It can be

#### performed on an EF only if the security status satisfies the security attributes defined for the function,

#### namely, read, write, update, erase, search or compare.

#### Each command of this group may use either a short EF identifier or a file identifier. If there is an EF

#### referenced by curEF at the time of issuing the command, then the process may be completed on that

#### EF by just setting all the corresponding bits to 0. If the process is completed, then the identified EF

#### becomes current.

#### INS P1 P2 — All the commands of this group shall use bit b1 of INS and bit b8 of P1 as follows.

#### — If bit b1 of INS is set to 0 and bit b8 of P1 to 1, then bits b7 and b6 of P1 are set to 00 (any other value

#### is RFU), bits b5 to b1 of P1 encode a short EF identifier and P2 (eight bits) encodes an offset from 0

#### to 255 in the EF referenced by the command.

#### — If bit b1 of INS is set to 0 and bit b8 of P1 to 0, then P1-P2 (fifteen bits) encodes an offset in the EF

#### referenced by curEF from 0 to 32 767.

#### — If bit b1 of INS is set to 1, then P1-P2 shall identify an EF. If the first eleven bits of P1-P2 are set to 0

#### and if bits b5 to b1 of P2 are not all equal and if the card and/or the EF supports selection by short

#### EF identifier, then bits b5 to b1 of P2 encode a short EF identifier (a number from one to thirty).

#### Otherwise, P1-P2 is a file identifier. P1-P2 set to '0000' identifies the EF referenced by curEF. At least


#### one offset DO'54' shall be present in the command data field. When present in a command or response

#### data field, data shall be encapsulated in a discretionary DO'53' ('73' is deprecated for this use).

#### In this group of commands:

#### — SW1-SW2 set to '63CX' indicates a successful change of memory state, but after an internal retry

#### routine; 'X' > '0' encodes the number of retries; 'X' = '0' means that no counter is provided.

#### — SW1-SW2 set to '6B00' should be used to indicate that the offset points outside of EF.

#### 11.3.3 read binary command

#### Table 65 shows the read binary C-RP. The response data field gives (part of) the content of an EF

#### supporting data units. If the Le field contains only bytes set to '00', then all the bytes until the end of the

#### file should be read within the limit of 256 for a short Le field, or 65 536 for an extended Le field.

#### Table 65 — read binary command-response pair

```
CLA As defined in 5.4.1
INS 'B0' or 'B1'
```
```
P1-P2
```
```
INS = 'B0' Mandatory offset, possible short EF identifier
See 11.3.2
INS = 'B1' EF identifier, or short EF identifier
Lc field Absent for encoding Nc = 0, present for encoding Nc > 0
```
```
Data field
```
```
INS = 'B0' Absent
INS = 'B1' Offset DO
Le field Present for encoding Ne > 0
```
```
Data field
```
```
INS = 'B0' Data read
INS = 'B1' Discretionary DO for encapsulating data read
SW1-SW2 See Table 6 and Table 7 when relevant, e.g. '6281', '6282', '6700', '6981', '6982', '6986', '6A81', '6A82', '6B00'
```
#### 11.3.4 write binary command

#### Table 6 6 shows the write binary C-RP. The command initiates one of the following operations into an

#### EF according to the file attributes:

#### 1) the logical-OR of the bits already present in the card with the bits given in the command data field

#### (the logical erased state of the bits of the file is zero);

#### 2) the write-once of the bits given in the command data field (the command shall be aborted if the

#### string of data units is not in the logical erased state);

#### 3) the logical-AND of the bits already present in the card with the bits given in the command data field

#### (the logical erased state of the bits of the file is one).

#### By default, i.e. when a data coding byte is not available (see 11.3.1), operation 1) shall apply in that EF.


#### Table 66 — write binary command-response pair

```
CLA As defined in 5.4.1
INS 'D0' or 'D1'
```
```
P1-P2
```
```
INS = 'D0' Mandatory offset, possible short EF identifier
INS = 'D1' EF identifier, or short EF identifier See 11.3.2
Lc field Present for encoding Nc > 0
```
```
Data field INS = 'D0' String of data units to be written
INS = 'D1' offset DO and discretionary DO for encapsulating the string of data units to be written
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2 See Table 6 and Table 7 when relevant, e.g. '63CX' (see 11.3.2), '6581', '6700', '6981', '6982', '6B00'
```
#### 11.3.5 update binary command

#### Table 67 shows the utdate binary C-RP. The command initiates the update of bits already present in

#### an EF with the bits given in the command data field. When the process is completed, each bit of each

#### specified data unit will have the value specified in the command data field.

#### Table 67 — update binary command-response pair

```
CLA As defined in 5.4.1
INS 'D6' or 'D7'
```
```
P1-P2
```
```
INS = 'D6' Mandatory offset, possible short EF identifier
INS = 'D7' EF identifier, or short EF identifier See 11.3.2
Lc field Present for encoding Nc > 0
Data field INS = 'D6' String of data units to be updated
INS = 'D7' Offset DO and discretionary DO for encapsulating the string of updating data units
Le field Absent for encoding Ne = 0
```
```
Data fieldAbsent
SW1-SW2See Table 6 and Table 7 when relevant, e.g. '63CX' (see 11.3.2), '6581', '6700', '6981', '6982', '6B00'
```
#### 11.3.6 search binary command

#### Table 6 8 shows the search binary C-RP. The command initiates a search within an EF supporting data

#### units. The response data field gives the offset of a data unit: the byte string at the returned offset within

#### the EF shall have the same value as the search string in the command data field. The response data

#### field is absent either because the Le field is absent, or because no match is found. If the search string is

#### absent, then the response data field gives the offset of the first data unit in a logically erased state.

#### Table 68 — search binary command-response pair

```
CLA As defined in 5.4.1
INS 'A0' or 'A1'
```
```
P1-P2
```
```
INS = 'A0' Mandatory offset, possible short EF identifier -
See 11.3.2
INS = 'A1' EF identifier, or short EF identifier
Lc field Absent for encoding Nc = 0, present for encoding Nc > 0
```
```
Data field
```
```
INS = 'A0' Absent or search string
INS = 'A1' Offset DO and discretionary DO for encapsulating the search string
```

```
Le field Absent for encoding Ne = 0, present for encoding Ne > 0
```
```
Data field
```
```
INS = 'A0' Absent or offset of the first data unit matching the command data field
INS = 'A1' Offset DO indicating the first data unit matching the search string
SW1-SW2 See Table 6 and Table 7 when relevant, e.g. '6282', '6982', '6B00'
```
#### 11.3.7 erase binary command

#### Table 69 shows the erase binary C-RP. The command sets (part of ) the content of an EF to its logical

#### erased state, sequentially, starting from a given offset.

#### — If INS = '0E', then, if present, the command data field encodes the offset of the first data unit not to

#### be erased. This offset shall be higher than the one encoded in P1-P2. If the data field is absent, then

#### the command erases up to the end of the file.

#### — If INS = '0F', then, if present, the command data field shall consist of zero, one or two offset DOs.

#### If there is no offset, then the command erases all the data units in the file. If there is one offset, it

#### indicates the first data unit to be erased; then the command erases up to the end of the file. Two

#### offsets define a sequence of data units: the second offset indicates the first data unit not to be erased;

#### it shall be higher than the first offset.

#### Table 69 — erase binary command-response pair

```
CLA As defined in 5.4.1
INS '0E' or '0F'
```
```
P1-P2
```
```
INS = '0E' Mandatory offset, possible short EF identifier
INS = '0F' EF identifier, or short EF identifier See 11.3.2
Lc field Absent for encoding Nc = 0, present for encoding Nc > 0
```
```
Data field INS = '0E' Absent or offset of the first data unit not to be erased
INS = '0F' Absent or one or two offset DOs
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2 See Table 6 and Table 7 when relevant, e.g. '63CX' (see 11.3.2), '6581', '6700', '6981', '6982', '6B00'
```
#### 11.3.8 compare binary function

#### This function is supported by the compare command (see 11 .7.1).

### 11.4 Record handling

#### 11.4.1 Records

#### Within each EF supporting records, a record number and/or a record identifier shall reference each

#### record. Reference to a record not contained in the EF is an error.

#### Referencing by record number — Each record number is unique and sequential.

#### — Within each EF supporting a linear structure, the record numbers shall be sequentially assigned

#### when writing or appending, i.e. in the order of creation; the first record (number one) is the first

#### created record.

#### — Within each EF supporting a cyclic structure, the record numbers shall be sequentially assigned in

#### the opposite order, i.e. the first record (number one) is the most recently created record.

#### Table 68 (continued)


#### The following rule is defined for linear structures and for cyclic structures.

#### — Zero shall refer to the record referenced by curRecord.

#### Referencing by record identifier — Each record identifier is provided by an application. Several

#### records may have the same record identifier, in which case data contained in the records may be used

#### for discriminating between them. If a record is a simple-tlv data object in a data field, then the record

#### identifier is the first byte of the data object, i.e. the simple-tlv tag.

#### Referencing by record identifier shall induce the management of curRecord. Enabling a physical

#### interface, resetting a logical channel, a select and any command using a valid short EF identifier for

#### accessing an EF may affect curRecord. Referencing by record number shall not affect curRecord.

#### Each time a reference is made with a record identifier, the logical position of the target record shall be

#### indicated: the first or last occurrence, the next or previous occurrence relative to curRecord.

#### — Within each EF supporting a linear structure, the logical positions shall be sequentially assigned

#### when writing or appending, i.e. in the order of creation. The first created record is in the first logical

#### position.

#### — Within each EF supporting a cyclic structure, the logical positions shall be sequentially assigned in

#### the opposite order, i.e. the most recently created record is in the first logical position.

#### The following rules are defined for linear structures and for cyclic structures.

#### — The first occurrence shall be the record with the specified identifier and in the first logical position;

#### the last occurrence shall be the record with the specified identifier and in the last logical position.

#### — If there is a record referenced by curRecord, then the next occurrence shall be the closest record with

#### the specified identifier but in a greater logical position than the record referenced by curRecord; the

#### previous occurrence shall be the closest record with the specified identifier but in a smaller logical

#### position than the record referenced by curRecord.

#### — If curRecord is not set, then the next occurrence shall be equivalent to the first occurrence; the

#### previous occurrence shall be equivalent to the last occurrence.

#### — Zero shall refer to the first, last, next or previous record in the numbering sequence, independently

#### from the record identifier.

#### 11.4.2 General...................................................................................................................................................................................

#### Any command of this group shall be aborted if applied to an EF not supporting records. It can be

#### performed on an EF only if the security status satisfies the security attributes defined for the function,

#### namely, read, write, append, update, search, erase, activate or deactivate.

#### The records in an EF may support record life cycle. If so, in general deactivated records are not accessible

#### by the commands read record, write record, update record, erase record, append record and

#### compare (record ). If such a command is used, the respective command returns with the status bytes

#### '6287' (at least one of the referenced records is not processed). Furthermore, deactivated records shall

#### be ignored, when executing a search record command. Further details and exceptions to the general

#### rules stated above are given below.

#### Two commands of this group (read, update) may use an odd INS code (data fields encoded in ber-tlv)

#### for initiating an action on a part of a given record (partial read, partial update). Then an offset shall

#### reference each byte inside a record: from 0 for the first byte of the record, the offset is incremented

#### by one for each subsequent byte of the record. Reference to a byte not contained in the record is an

#### error. As needed, the offset data element is binary encoded and referenced by tag '54'. When present

#### in a command or response data field, data shall be encapsulated in a discretionary DO'53' ('73' is

#### deprecated for this use).


#### Each command of this group may use a short EF identifier. If the process is completed, then the

#### identified EF becomes current and curRecord is reset. If there is an EF referenced by curEF at the time

#### of issuing the command, then the process may be completed without indicating the EF (by just setting

#### the corresponding five bits to 0).

#### P1 — Each record number or identifier is a number from one to 254, encoded by a value of P1 from '01'

#### to 'FE'. 0 (encoded '00') is reserved for special purposes. 255 (encoded 'FF') is RFU.

NOTE If the number of records exceeds the numbering range ('01' to 'FE') of the record handling command,
records can be handled e.g. by using next occurrence option of the record identifier, or by using multiple record
handling with record number DO’02’. Next occurrence means the closest record with the specified identifier.

#### P2 — If bits b8 to b4 are not all equal, these bits are a short EF identifier according to Table 70 and

#### bits 3 to 1 depend upon the command. If bits b8 to b1 are set to 11111000 (i.e. P2 = ‘F8‘), P2 indicates

#### multiple record handling (for details, see 11.4.3 to 11.4.10).

#### Table 70 — Coding of P2

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 0 0 0 0 - - - Current EF
Not all equal - - - Short EF identifier (a number from one to thirty)
1 1 1 1 1 0 0 0 Multiple record handling (for details, see 11.4.3 to 11.4.10)
1 1 1 1 1 Not all zero RFU
```
#### In this group of commands, SW1-SW2 set to '63CX' indicates a successful change of memory state, but

#### after an internal retry routine; 'X' > '0' encodes the number of retries; 'X' = '0' means that no counter is

#### provided.

#### In the multiple record handling option of this command group, SW1-SW2 set to ‘6287‘ indicates that

#### some command processes are done and others are not (e.g. some addressed records are read but others

#### are not). SW1-SW2 set to ‘6F00‘ indicates that all command processes are not completed for different

#### reasons (e.g. record deactivated, security status not satisfied).

#### 11.4.3 read record (s) command

#### Table 71 shows the read record (s) C-RP. The response data field gives the (partial) contents of the

#### addressed record(s) (or the beginning part of one record) within an EF.

#### If any record referenced by P1 and P2 is in record LCS DEACTIVATED, the command is processed with

#### warning '6287' and the response data field shall be empty.

#### If INS = 'B2' and if the records are simple-tlv data objects (see 6.2), then Figure 9 illustrates the

#### response data field. The comparison of Nr with the tlv structure indicates whether the unique record

#### (read one record) or the last record (read all records) is incomplete, complete or padded.

NOTE If the records are not data objects, then the read-all-records function results in receiving records
without delimiter.

#### If INS = 'B3', then the command does not support the "read all records" options in P2. It partially reads

#### the record referenced by P1. The command data field shall contain an offset DO'54' indicating the first

#### byte to be read in the record. The response data field shall contain a discretionary DO'53' encapsulating

#### the data read.

#### If INS = ‘B2‘ and bits b8 to b1 of P2 are set to 11111000 (i.e. P2 = ‘F8‘), then this command may read

#### multiple records in different EFs. The command data field contains one or more record handling

#### DO‘7F76‘ each containing one file reference DO‘51‘ and one or more integer DO‘02‘. The value field of

#### DO‘51‘ contains a file identifier or a short EF identifier indicating the record structure EF under the

#### DF referenced by curDF. This field may also contain a relative path or an absolute path. The value field

#### of DO‘02‘ is a record number to be read from the file referenced by DO‘51‘. DO‘02‘ may indicate record

#### number over 254. For each DO‘02‘ under DO‘7F76‘ in the command data field, the response data field


#### contains a corresponding DO‘53‘ or DO‘04‘. If the addressed record is readable (i.e. record exists, record

#### is activated and security status satisfies the security attributes) then the corresponding DO‘53‘ contains

#### the entire record. When present, a DO‘53‘ denotes an implicit normal processing without corresponding

#### status bytes, i.e. ‘9000‘. Otherwise the corresponding DO‘04‘ contains value of status bytes defined in

#### Table 5 and 6 indicating why the record data is not read. If at least one addressed record is not read, the

#### status bytes ‘6287‘ shall be returned. The VA shall not be changed in case P2 = ‘F8‘.

#### If INS='B2' and P2 = 'F8' and the command data references missing files or files with incompatible file

#### structure or missing record(s), the command shall be aborted with the respective return code from

#### Table 5 or 6 (e.g. command incompatible with file structure '6981', file not found '6A82', record not

#### found '6A83', etc.).

#### Table 71 — read record (s) command-response pair

```
CLA As defined in 5.4.1
INS 'B2' or 'B3'
P1 Record number or record identifier or '00' referencing the record referenced by curRecord
P2 See Table 72
Lc field Absent for encoding Nc = 0, present for encoding Nc > 0
```
```
Data field
```
```
INS = ‘B2‘ and bits b8 to b1 of P2 set to 11111000 One or more record handling DO‘7F76‘
INS = 'B2' and bits b8 to b1 of P2 not set to
11111000 Absent
INS = 'B3' offset DO
Le field Present for encoding Ne > 0
```
```
Data field
```
```
INS = ‘B2‘ and bits b8 to b1 of P2 set to 11111000 One or more discretionary data DO‘53‘ and/or DO‘04‘ containing value of status bytes.
INS = 'B2' and bits b8 to b1 of P2 not set to 11111000Data read
INS = 'B3' Discretionary DO for encapsulating the data read
SW1-SW2 See Table 6 and Table 7 when relevant, e.g. '6281, '6282', '6700', '6981', '6982', '6A81, '6A82', '6A83'
```
#### Table 72 — Coding of P2 in the read record (s) command

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
x x x x x
```
- - - Short EF identifier according to Table 70
(Not all one)

```
Not all one
```
```
0 x x Record identifier in P1
0 0 0 — Read first occurrence
0 0 1 — Read last occurrence
0 1 0 — Read next occurrence
0 1 1 — Read previous occurrence
1 x x Record number in P1
1 0 0 — Read record P1
1 0 1 — Read all records from P1 up to the last (for INS = 'B2' only)
1 1 0 — Read all records from the last up to P1 (for INS = 'B2' only)
1 1 1 1 1 0 0 0 INS = ‘B2’ P1 set to ‘00’ and one or more record handling DO‘7F76’ in
the command data field
NOTE Any other value is RFU.
```
#### If the Le field contains only bytes set to '00', then the command should read completely either the single

#### requested record, or the requested sequence of records, depending on bits 3, 2 and 1 of P2 and within

#### the limit of 256 for a short Le field, or 65 536 for an extended Le field.


#### Figure 9 — Response data fields with INS = 'B2' when records are simple-tlv data objects

#### 11.4.4 write record command

#### Table 73 shows the write record C-RP. The command initiates one of the following operations into an

#### EF according to the file attributes:

#### 1) the write-once of a record given in the command data field (the command shall be aborted if the

#### record is not in the logical erased state);

#### 2) the logical-OR of the data bytes of a record already present in the card with the data bytes of the

#### record given in the command data field;

#### 3) the logical-AND of the data bytes of a record already present in the card with the data bytes of the

#### record given in the command data field.

#### By default, i.e. when a data coding byte is not available (see 11.3.1), operation 1) shall apply in that EF.

#### If the record referenced by P1 and P2 is in the record LCS DEACTIVATED, the command is processed

#### with warning '6287' without changing the record content.

#### When P1 set as ‘00’, the command shall set curRecord on the successfully written record.

#### If applied to an EF supporting a cyclic structure with records of fixed size, the “previous” option (bits 3,

#### 2 and 1 of P2 set to 011) behaves as append record.

#### If bits b8 to b1 of P2 are set to 11111000 (i.e. P2 = ‘F8‘), then this command may write multiple records in

#### different EFs. The command data field contains one or more record handling DO‘7F76‘ each containing

#### one file reference DO‘51‘ and one or more sets of an integer DO‘02‘ and a discretionary data DO‘53‘. The

#### value field of DO‘51‘ contains a file identifier or a short EF identifier indicating the record structure

#### EF under the DF referenced by curDF. This field also may contain a relative path or an absolute path.

#### The value field of DO‘02‘ is a target record number in the file referenced by DO‘51‘. The value field of

#### DO‘53‘ is the record to be written. DO‘02‘ may indicate record number over 254. This command can

#### be performed only when all addressed records are stored in record structure EF(s), addressed records

#### are present and activated, and when the security status satisfies the security attributes. If at least one

#### addressed record is not written, any of addressed record is not written. The VA shall not be changed in

#### case P2 = ‘F8‘.


#### Table 73 — write record command-response pair

```
CLA As defined in 5.4.1
INS 'D2'
P1 Record number or '00' referencing the record referenced by curRecord
P2 See Table 74
Lc field Present for encoding Nc > 0
```
```
Data field
```
```
Bits b8 to b1 of P2 set to 11111000 One or more record handling DO‘7F76‘
Bits b8 to b1 of P2 not set to
11111000 Record to be written
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2 See '6A81', '6A82', '6A83, '6A84', '6A85'Table 6 and Table^7 when relevant, e.g. '63CX' (see 11.4.2), '6581', '6700', '6981', '6982', '6986',
```
#### Table 74 — Coding of P2 in the write record command and the update record command with

#### even INS code

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
x x x x x
(Not all one) - - - Short EF identifier according to Table^70
```
```
Not all one
```
```
0 x x P1 set to '00'
0 0 0 — First record
0 0 1 — Last record
0 1 0 — Next record
0 1 1 — Previous record
Not all one 1 0 0 Record number in P1
1 1 1 1 1 0 0 0 P1 set to ‘00‘ and one or more record handling DO‘7F76’ in the command data field
NOTE Any other value is RFU.
```
#### If the records are simple-tlv data objects (see 6.2), then Fig ure 10 illustrates the command data field.

#### Figure 10 — APDU data field (one complete record nesting a simple-tlv data object)

#### 11.4.5 update record command

#### Table 75 shows the update record C-RP. The command initiates the update of a specific record with

#### the bytes given in the command data field. When P1 set as ‘00’, the command shall set curRecord on the

#### successfully updated record.

#### If applied to an EF supporting a linear or cyclic structure with records of fixed size, then the command

#### shall be aborted if the record size after updating would be different from the size of the existing record.

#### If applied to an EF supporting a linear structure with records of variable size, then the command may

#### be carried out when the record size after updating is different from the size of the existing record.

#### If applied to an EF supporting a cyclic structure with records of fixed size, the “previous” option (bits 3,

#### 2 and 1 of P2 set to 011) behaves as append record.


#### If the record referenced by P1 and P2 is in the record LCS DEACTIVATED, the command is processed

#### with warning '6287' without changing the record content.

#### If INS = 'DC' and if the records are simple-tlv data objects (see 6.2), then Fig ure 10 illustrates the

#### command data field.

#### If INS = 'DD', then the command partially updates the record referenced by P1. The command data field

#### shall contain an offset DO'54' for indicating the first byte to be updated in the record and a DO'53' ('73'

#### is deprecated for this use) for encapsulating the updating data.

#### If INS = ‘DC‘ and bits b8 to b1 of P2 are set to 11111000 (i.e. P2 = ‘F8‘), then this command may update

#### multiple records in different EFs. The command data field contains one or more record handling DO‘7F76‘

#### each containing one file reference DO‘51‘ and one or more sets of an integer DO‘02‘ and a discretionary

#### data DO‘53‘. The value field of DO‘51‘ contains a file identifier or a short EF identifier indicating the

#### record structure EF under the DF referenced by curDF. This field also may contain a relative path or an

#### absolute path. The value field of DO‘02‘ is a target record number in the file referenced by DO‘51‘.The

#### value field in DO‘53‘ is the updating data for the target record. DO‘02‘ may indicate record number over

#### 254. This command can be performed only when all addressed records are stored in record structure

#### EF(s), addressed records are present and activated, and when the security status satisfies the security

#### attributes. If at least one addressed record is not updated, any of addressed record is not updated. The

#### VA shall not be changed in case P2 = ‘F8‘.

#### Table 75 — update record command-response pair

```
CLA As defined in 5.4.1
INS 'DC' or 'DD'
P1 Record number or '00' referencing the record referenced by curRecord
P2 See Table 74 (INS = 'DC') or Table 76 (INS = 'DD')
Lc field Present for encoding Nc > 0
```
```
Data field
```
```
INS = ‘DC‘ and bits b8 to b1 of P2 set to 11111000 One or more record handling DO‘7F76‘
INS = 'DC' and bits b8 to b1 of P2 not set to
11111000 Updating data
INS = 'DD' Offset DO and discretionary DO for encapsulating the updating data -
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2 See '6A81', '6A82', '6A83, '6A84', '6A85'Table 6 and Table^7 when relevant, e.g. '63CX' (see 11.4.2), '6581', '6700', '6981', '6982', '6986',
```
#### Table 76 — Coding of P2 in the update record command with INS = 'DD'

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
x x x x x - - - Short EF identifier according to Table 70
```
- - - - - 1 x x **Record number in P1**
- - - - - 1 0 0 — Replace
- - - - - 1 0 1 — Logical AND
- - - - - 1 1 0 — Logical OR
- - - - - 1 1 1 — Logical XOR
NOTE Any other value is RFU.


#### 11.4.6 append record command

#### Table 77 shows the append record C-RP. The command initiates either the writing of a new record at

#### the end of a linear structure, or at the beginning of a cyclic structure. The command shall set curRecord

#### on the successfully appended record.

#### If the command applies to a linear structure full of records, then the command is aborted because there

#### is not enough memory space in the file.

#### If the command applies to a cyclic structure full of records, then the record with the highest record

#### number is deleted. All other record numbers are incremented by one. The appended record becomes

#### record number one. If the record with the highest record number is in the record LCS deactivated the

#### command is processed with warning '6287' without changing any record content or record number.

#### If the records in the EF have record life cycle, the LCS of the appended record shall be set to activated

#### unless otherwise specified.

#### If the records are simple-tlv data objects (see 6.2), then Fig ure 10 illustrates the command data field.

#### If bits b8 to b1 of P2 are set to 11111000 (i.e. P2 = ‘F8‘), then this command may append multiple records

#### to different EFs. The command data field contains one or more record handling DO‘7F76‘ containing one

#### file reference DO‘51‘ and one or more discretionary data DO‘53‘. The value field of DO‘51‘ contains a file

#### identifier or a short EF identifier indicating the record structure EF under the DF referenced by curDF.

#### This field also may contain a relative path or an absolute path. The value field of DO‘53‘ is the record to

#### be appended. This command can be performed only when all addressed EFs are record structure and

#### have enough space for appending record, and when the security status satisfies the security attributes.

#### If at least one of the records is not appended, any of records is not appended to the addressed EFs. The

#### VA shall not be changed in case P2 = ‘F8‘.

#### Table 77 — append record command-response pair

```
CLA As defined in 5.4.1
INS 'E2'
P1 '00' (any other value is invalid)
P2 See Table 78 with bits 3 to 1 set to 000 (any other value is RFU)
Lc field Present for encoding Nc > 0
```
```
Data field
```
```
Bits b8 to b1 of P2 set to 11111000 One or more record handling DO‘7F76‘
Bits b8 to b1 of P2 not set to
11111000 Record to be appended
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2 See '6A81', '6A82', '6A83, '6A84', '6A85'Table 6 and Table^7 when relevant, e.g. '63CX' (see 11.4.2), '6287' 6581', '6700', '6981', '6982', '6986',
```
#### Table 78 — Coding of P2 in the append record command with INS = 'DD'

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
x x x x x
(Not all one) - - - Short EF identifier according to Table^70
Not all one 0 0 0 Command data field containing record to be appended
1 1 1 1 1 0 0 0 One or more record handling DO’7F76’
NOTE Any other value is RFU.
```

#### 11.4.7 search record command

#### Table 79 shows the search record C-RP. If bits b8 to b1 of P2 are not set to 11111000 (i.e. P2 = ‘F8‘),

#### this command initiates a simple or enhanced or proprietary search on records stored within one

#### addressed EF. The search can be limited to records with a given identifier or to records with a number

#### greater or smaller than a given number. It can be performed in increasing or in decreasing order of

#### record numbers. The search starts either from the first byte of the records (simple search), or from a

#### given offset within the records (enhanced search), or from the first occurrence of a given byte within

#### the records (enhanced search). The response data field gives the numbers of the records matching the

#### search criteria within an EF supporting records. The command shall set curEF and curRecord on the

#### first record matching the search criteria even if the record number is used in P1.

#### If bits b8 to b1 of P2 are set to 11111000 (i.e. P2 = ‘F8‘), this command initiates a search on records

#### stored within one or more addressed EFs (search through multiple EFs). Two options are provided for

#### search through multiple EFs such as simple and enhanced search through multiple EFs. The command

#### data field contains one record handling DO‘7F76‘. The search covers all activated records in all

#### the EFs addressed by file reference DOs. The response data field gives one or more record handling

#### DO‘7F76‘ each containing one file reference DO‘51‘ with one or more integer DO‘02‘. DO‘51‘ gives file

#### reference to an EF storing the record matching the search criteria. Value field of DO‘02‘ is the record

#### number indicating the record matching the search criteria. DO‘02‘ may indicate record number over

#### 254. This command can be performed on each activated record in each EF when the security status

#### satisfies the security attribute. If the command data references missing files or files with incompatible

#### file structure, the command shall be aborted with the respective return code from Table 5 or 6 (e. g.

#### command incompatible with file structure '6981', file not found '6A82', etc.).

#### For simple search through multiple EFs, record handling DO‘7F76‘ contains one or more file reference

#### DO‘51‘ and one discretionary data DO‘53‘ (see Table 82 ). The value field of each DO‘51‘ contains a file

#### identifier or a short EF identifier indicating the record structure EF under the DF referenced by curDF.

#### This field also may contain a relative path or an absolute path. The value field of DO‘53‘ is a search

#### string. The search covers all activated records in all the EFs addressed by file reference DOs.

#### For enhanced search through multiple EFs, record handling DO‘7F76‘ contains one or more file reference

#### DO‘51‘, one optional record selection DO’A0‘, one search configuration DO’A1‘, and one search string

#### DO’A3‘ (see Table 83 ).

#### The record selection DO’A0‘ in a record handling DO‘7F76‘ contains either one or more record number

#### range DO’B0‘ or one record number list DO’B1‘ (see Table 8 4). One record number range DO’B0‘ contains

#### two DO‘02‘. The first DO‘02‘ encodes the start record number to search and the second DO‘02‘ encodes

#### the number of records to search from the start record number. The value 0 of the first data object

#### indicates the last record. The value 0 of the second data object indicates that all records from the start

#### record number are searched. The search order ascending or descending from the start record number

#### is indicated in a search configuration parameter DO‘80‘ (see Table 86 ) in a search configuration DO’A1‘

#### (se e Table 85 ). The absence of a record selection indicates that all records in all addressed EFs are

#### searched.

#### The search configuration DO’A1‘ in a record handling DO‘7F76‘ contains one configuration parameter

#### DO‘80‘ and one optional search window DO’B0‘ (see Table 85 ). A search configuration parameter

#### indicates search order, step-width for searching, and search termination (see Table 86 ). A search

#### window contains two DO‘02‘. The first DO‘02‘ encodes the offset indicating the search starting position

#### in the records. The second DO‘02‘ encodes the number of bytes for searching from the offset in the

#### records. The value 0 of this data object indicates all bytes from the offset in the records are searched.

#### If the first DO‘02‘ is empty, it indicates the number of bytes indicated by the second DO‘02‘ at the end

#### of the records are searched, e.g. ‘B0 05 02 00 02 01 03‘ encodes the last 3 bytes of the records are

#### searched. The length of a search window shall be equal or longer than a search string. The search starts

#### from the beginning of a search window and ends when the end of a search string reaches to the end of a

#### search window.

#### The search string DO’A3‘ in a record handling DO‘7F76‘ contains either one search string interval DO’B0‘

#### or one search string set DO’B1‘ (see Table 87 ). A search string interval contains one search string lower

#### bound DO‘81‘ and one search string upper bound DO’82’. The value field of these DOs are interpreted


#### as a binary representation of the lower/upper bound value. A search string set contains one or more

#### sets of one single search string DO‘81‘ and one optional binary filter DO‘5F71‘. The single search string

#### in a DO’81’ and the corresponding binary filter in a DO’5F71’ shall have the same length. If present,

#### the binary filter DO'5F71' follows immediately subsequent to the related single search string DO'81'. If

#### more than one DO'81' is present, the search is successful, if at least one match is found (logical OR).

#### In an EF supporting records of variable size with linear structure, the search shall not take into account

#### the records shorter than the search string. In an EF supporting records of fixed size with linear or cyclic

#### structure, if the search string is longer than the records, then the card shall abort the command.

#### Records with a record LCS set to deactivated shall be ignored during the search.

#### Table 79 — search record command-response pair

```
CLA As defined in 5.4.1
INS 'A2'
P1 Record number or record identifier or '00' referencing the record referenced by curRecord
P2 See Table 8 0
Lc field Present for encoding Nc > 0
Bits b8 to b4 of P2 not set to 11111 and bits b3 and
b2 of P2 not set to 11, simple search Search string
Data field Bits b8 to b4 of P2 not set to 11111 and bits b3 to b1 of P2 set to 110, enhanced search Search indication (2 bytes, see by search string Table^81 ) followed
Bits b8 to b1 of P2 set to 11111000, search
through multiple EF One record handling DO‘7F76‘
Bits b8 to b4 of P2 not set to 11111 and bits b3 to
b1 of P2 set to 111, proprietary search Proprietary
Le field Absent for encoding Ne = 0, present for encoding Ne > 0
```
```
Data field
```
```
Bits b8 to b1 of P2 set to 11111000, search
through multiple EF
```
```
Absent, or one or more record handling
DO‘7F76‘
Others Absent or record number(s)
SW1-SW2 See Table 6 and Table 7 when relevant, e.g. '6282', '6982'
NOTE 1 The response data field is absent either because the Le field is absent, or because no match is found.
NOTE 2 The response data field does not give record identifiers because it is possible that they are not unique.
```
#### In an enhanced search (bits 3, 2 and 1 of P2 set to 110), the command data field consists of a search

#### indication on two bytes followed by a search string. Table 81 specifies the first search indication byte.

#### According to the first byte of the search indication, the second byte is either an offset or a value, i.e.

#### the search in the records shall start either from this offset (see 11.4.2) or after the first occurrence of

#### this value.


#### Table 80 — Coding of P2 in the search record command

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
x x x x x
(Not all one) - - - Short EF identifier according to Table^70
0 x x Simple search with record identifier in P1
0 0 0 — Forward from first occurrence
0 0 1 — Backward from last occurrence
0 1 0 — Forward from next occurrence
Not all one 0 1 1 — Backward from previous occurrence
1 0 x Simple search with record number in P1
1 0 0 — Forward from P1
1 0 1 — Backward from P1
1 1 0 Enhanced search
1 1 1 Proprietary search
```
```
1 1 1 1 1 0 0 0
```
**Search through multiple EFs**
P1 set to ‘00’
NOTE Any other value is RFU.

#### Table 81 — Coding of the first byte of the search indication

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 0 0 0 0 - - - The subsequent byte is an offset (start from that position)
0 0 0 0 1 - - - The subsequent byte is a value (start after the first occurrence)
```
- - - - - 0 x x **Record identifier in P1**
- - - - - 0 0 0 — Forward from first occurrence
- - - - - 0 0 1 — Backward from last occurrence
- - - - - 0 1 0 — Forward from next occurrence
- - - - - 0 1 1 — Backward from previous occurrence
- - - - - 1 x x **Record number in P1**
- - - - - 1 0 0 — Forward from P1
- - - - - 1 0 1 — Backward from P1
- - - - - 1 1 0 — Forward from next record
- - - - - 1 1 1 — Backward from previous record
NOTE Any other value is RFU.

#### Table 82 — Record handling for simple search through multiple EFs

```
Tag Value Occurrence
‘7F76‘ Record handling DOs
‘51‘ File reference DO At least once
‘53‘ Discretionary DO Once, mandatory
```

#### Table 83 — Record handling for enhanced search through multiple EFs

```
Tag Value Occurrence Note
‘7F76‘ Record handling DOs
‘51‘ File reference DO At least once
‘A0 ‘ Record selection DOs Once, optional See Table 8 4
‘A 1‘ Search configuration DOs Once, mandatory See Table 85
‘A 3 ‘ Search string DOs Once, mandatory See Table 87
```
#### Table 84 — Record selection for enhanced search through multiple EFs

```
Tag Value Occurrence
‘A0 ‘ Record selection DOs
‘B0‘ Record number range DOs At least once
Choice
between
those
```
```
‘02‘ Start record number Once
‘02‘ Number of records to search Once
‘B1‘ Record number list DOs Once
‘02‘ Record number At least once
```
#### Table 85 — Search configuration for enhanced search through multiple EFs

```
Tag Value Occurrence Note
‘A 1‘ Search configuration DOs
‘80‘ Search configuration parameter Once, mandatory See Table 86
‘B0‘ Search window DOs Once, optional
‘02‘ Offset Once
‘02‘ Number of bytes Once
```
#### Table 86 — Coding of search configuration parameter

**b8 b7 b6 b5 b4 b3 b2 b1 Meaning**
x - - - - - - - Search order
0 - - - - - - - Search in record number ascending order
1 - - - - - - - Search in record number descending order

- x - - - - - - Step-width for search
- 0 - - - - - - Byte-wise
- 1 - - - - - - Search string-wise, i.e. the length of search string is the step-wise^
- - x x - - - - Configuration for search termination
- - 0 0 - - - - Search all addressed records in all addressed EFs
- - 0 1 - - - - Terminate search for one EF after first matching
- - 1 0 - - - - RFU
- - 1 1 - - - - Terminate search for all EFs after first matching
- - - - x x x x 0000 (any other value is RFU)


#### Table 87 — Search string for enhanced search through multiple EFs

```
Tag Value Occurrence
‘A 3 ‘ Search string DOs
‘B0‘ Search string interval DOs Once
‘81‘ Search string lower bound Once, mandatory
‘82‘ Search string upper bound Once, mandatory
Choice
between
those
```
```
‘B1‘ Search string set DOs Once
```
```
‘81‘ Single search string At least once
```
##### ‘5F71‘

```
Binary filter providing a binary
mask to be used in a logical AND
operation onto the data to be
compared
```
```
Optional for each DO‘81‘
```
#### 11.4.8 erase record (s) command

#### Table 8 8 shows the erase record (s) C-RP. If bits b8 to b4 of P2 are not set to 11111, the command

#### sets one or more records of an EF to the logical erased state, either the record referenced by P1, or the

#### sequence of records from P1, sequentially, up to the end of the file. Erased records shall not be deleted

#### and may still be accessible by write record and update record commands.

#### If bits b8 to b1 of P2 are set to 11111000 (i.e. P2 = ‘F8‘), the command sets one or more records in

#### different EFs referenced by the command data field to the logical erase state. The command data field

#### contains one or more record handling DO‘7F76‘ each containing one file reference DO‘51‘ and one or

#### more integer DO‘02‘. The value field of DO‘51‘ contains a file identifier or a short EF identifier indicating

#### the record structure EF under the DF referenced by curDF. This field may also contain a relative path or

#### an absolute path. The value field of DO‘02‘ is a record number. DO‘02‘ may indicate record number over

#### 254. This command can be performed only when all addressed records are stored in record structure

#### EF(s), addressed records are present and activated, and when security status satisfies the security

#### attributes. If the command data references missing file(s) or file(s) with incompatible file structure or

#### missing record(s), the command shall be aborted with the respective return code from Table 5 or 6 (e. g.

#### command incompatible with file structure '6981', file not found '6A82', record not found ‘6A83‘, etc.). If

#### at least one addressed record is not set to the logical erase state, any of addressed record may not be

#### set. The VA shall not be changed in case P2 = ‘F8‘.

#### If any record referenced by P1 and P2, or the command data field is in record LCS deactivated, the

#### command is processed with warning, SW1-SW2 as '6287' without changing any record content.

#### The VA shall not be changed by this command.


#### Table 88 — erase record (s) command-response pair

```
CLA As defined in 5.4.1
INS '0C'
P1 Record number
P2 See Table 8 9
Lc field Absent for encoding Nc = 0, present for encoding Nc > 0
```
```
Data field Bits b8 to b4 of P2 not set to 11111 Absent
Bits b8 to b1 of P2 set to 11111000 One or more record handling DO‘7F76‘
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2 See Table 6 and Table 7 when relevant, e.g. '6287', '63CX' (see 11.4.2), '6581', '6700', '6981', '6982',
'6986', '6A81', '6A82', '6A83, '6A84', '6A85'
```
#### Table 89 — Coding of P2 in the erase record (s) command

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
x x x x x - - - Short EF identifier according to Table 70
(Not all one)
```
```
Not all one
```
```
1 x x Record number in P1
1 0 0 — Erase record P1
1 0 1 — Erase all records from P1 up to the last
1 1 1 1 1 0 0 0 P1 set to ‘00‘ and one or more record handling DO‘7F76’ in the command data field
NOTE Any other value is RFU.
```
#### 11.4.9 activate record (s) command

#### Table 90 shows the activate record (s) C-RP. The command sets the record(s) referenced by P1 and

#### P2, or the command data field to the record LCS activated. If at least one addressed record that is not

#### already in the state activated is not activated, any of addressed records is not activated. The VA shall

#### not be changed by this command.

#### If bits b8 to b1 of P2 are set to 11111000 (i.e. P2 = ‘F8‘), the command indicates file references and

#### record numbers for records to be activated. The command data field contains one or more record

#### handling DO‘7F76‘ each containing one file reference DO‘51‘ and one or more integer DO‘02‘. The value

#### field of DO‘51‘ contains a file identifier or a short EF identifier indicating the record structure EF under

#### the DF referenced by curDF. This field may also contain a relative path or an absolute path. The value

#### field of DO‘02‘ is a record number. DO‘02‘ may indicate record number over 254. If the command data

#### references missing file(s) or file(s) with incompatible file structure or missing record(s), the command

#### shall be aborted with the respective return code from Table 5 or 6 (e.g. command incompatible with file

#### structure '6981', file not found '6A82', record not found ‘6A83‘, etc.).

#### If at least one EF referenced by P2 or the command data field does not havet record life cycle, the

#### command shall be aborted with SW1-SW2 as '6981'.

#### If some of addressed records are already activated and the rest of addressed records are transited

#### successfully, the status bytes '9000' is returned.

#### For the activation of all records in the record LCS deactivated, the activate (file) command may be

#### used. Independent from the modification of an optionally present file LCS (see 7. 4 .10), all records will be

#### activated.


#### Table 90 — activate record (s) command-response pair

```
CLA As defined in 5.4.1
INS '08'
P1 Record number
P2 See Table 91
L c field Absent for encoding Nc = 0, present for encoding Nc > 0
```
```
Data field Bits b8 to b4 of P2 not set to 11111 Absent
Bits b8 to b1 of P2 set to 11111000 One or more record handling DO‘7F76‘
L e field Absent
```
```
Data field Absent
SW1-SW2 See Table 6 and Table 7 when relevant, e.g. '6981', '6982', '6986', '6A82', '6A83'
```
#### Table 91 — Coding of P2 in activate record (s) or deactivate record (s) commands

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
x x x x x – – – Short EF identifier according to Table 70
(Not all one)
```
- – – – – 1 x x Record number in P1
- – – – – 1 0 0 — Activate or deactivate record P1
- – – – – 1 0 1 — Activate or deactivate all records from P1 to the last
1 1 1 1 1 0 0 0 P1 set to ‘00‘ and one or more record handling DO‘7F76’ in the command data field
NOTE Any other value is RFU.

#### 11.4.10 deactivate record (s) command

#### Table 92 shows the diactivate record (s) C-RP. The command sets the record(s) referenced by P1 and

#### P2, or the command data field to the record LCS deactivated. If at least one addressed record that is

#### not already in the state deactivated is not activated, any of addressed records is not deactivated. The VA

#### shall not be changed by this command.

#### If bits b8 to b1 of P2 are set to 11111000 (i.e. P2 = ‘F8‘), the command indicates file references with

#### record numbers for records to be deactivated. The command data field contains one or more record

#### handling DO‘7F76‘ each containing one file reference DO‘51‘ and one or more integer DO‘02‘. The value

#### field of DO‘51‘ contains a file identifier or a short EF identifier indicating the record structure EF under

#### the DF referenced by curDF. This field may also contain a relative path or an absolute path. The value

#### field of DO‘02‘ is a record number. DO‘02‘ may indicate record number over 254. If the command data

#### references missing file(s) or file(s) with incompatible file structure or missing record(s), the command

#### shall be aborted with the respective return code from Table 5 or 6 (e.g. command incompatible with file

#### structure '6981', file not found '6A82', record not found ‘6A83‘, etc.).

#### If at least one EF referenced by P2 or the command data field does not have record life cycle, the

#### command shall be aborted with SW1-SW2 as '6981'.

#### If some of addressed record are already deactivated and the rest of addressed records are transited

#### successfully, the status bytes '9000' is returned.


#### Table 92 — deactivate record command-response pair

```
CLA As defined in 5.4.1
INS '06'
P1 Record number
P2 See Table 91
L c field Absent for encoding Nc = 0, present for encoding Nc > 0
```
```
Data field Bits b8 to b4 of P2 not set to 11111 Absent
Bits b8 to b1 of P2 set to 11111000 One or more record handling DO‘7F76‘
L e field Absent
```
```
Data field Absent
SW1-SW2 See Table 6 and Table 7 when relevant, e.g. '6981', '6982', '6986', '6A82', '6A83'
```
#### 11.4.11 compare record function

#### This function is supported by the compare command (see 11 .7.1).

### 11.5 Data object handling

#### 11.5.1 General...................................................................................................................................................................................

#### In this group of commands, SW1-SW2 set to '63CX' indicates a successful change of memory state, but

#### after an internal retry routine; 'X' > '0' encodes the number of retries; 'X' = '0' means that no counter is

#### provided.

#### 11.5.1.1 Coding of P1-P2 for even INS codes

#### Table 93 — Coding of P1-P2 for handling data objects with even INS codes

```
Value of P1-P2 Meaning
```
```
'0000' Dump a file (e.g. see^12 )
Retrieve a card-originated query from a card or send a reply to the card (see 12.6)
'0001' to '00FE' ber-tlv tag (one byte) in P2
'00FF' Special function (see Table 97 , Table 9 9, Table 10 0 and Table 101 )
'0100' to '01FF' Proprietary
'0200' RFU
'0201' to '02FE' simple-tlv tag in P2
'02FF' Special function (see text below)
'1F1F' to 'FFFF' ber-tlv tag (two bytes) in P1-P2
NOTE 1 Invalid ber-tlv tags in the range '01' to 'FE' and '1F1F' to 'FFFF' are RFU.
NOTE 2 Any other value is RFU.
```
#### If P1 is set to '00', then P2 from '01' to 'FE' shall be a ber-tlv tag on a single byte.

#### If P1 is set to '01', then P2 from '00' to 'FF' shall be an identifier for card internal tests and for proprietary

#### services meaningful within a given application.

#### If P1 is set to '02', then P2 from '01' to 'FE' shall be a simple-tlv tag. The value '0200' is RFU. The value

#### '02FF' is used either for obtaining all simple-tlv data objects readable in the context or for indicating

#### that the command data field is encoded in simple-tlv.


#### If P1-P2 lies from '1F1F' to 'FFFF', then they shall only encode a valid ber-tlv tag on two bytes.

NOTE Many values in the range '1F1F' to 'FFFF' are not valid ber-tlv tags (see Annex E).

#### 11.5.1.2 Coding of P1-P2 for odd INS codes

#### If bit b1 of INS is set to 1, then, except for the select data command, P1-P2 not set to '0000' or 'FFFF'

#### shall identify a file:

#### — If the first eleven bits of P1-P2 are set to 0 and if bits b5 to b1 of P2 are not all equal and if the card

#### and/or the file supports selection by short EF identifier, then bits b5 to b1 of P2 encode a short EF

#### identifier (a number from one to thirty). Otherwise, P1-P2 is a 2-byte file identifier.

#### — P1-P2 set to '3FFF' identifies the DF referenced by curDF.

#### P1-P2 set to '0000' identifies the EF referenced by curEF, unless the command data field provides a file

#### reference DO'51' for identifying a file.

#### P1-P2 set to 'FFFF' identifies the template referenced by curConstructedDO, unless the command data

#### field provides referencing of another template (see arguments 1, 2 and 3 in Table 94 ).

#### 11.5.1.3 Data fields

#### If bit b1 of INS is set to 0, if a DO is requested or provided within the template referenced by

#### curConstructedDO, then the payload shall contain the value field of the data object, i.e., either the

#### referred data element in the case of a simple-tlv data object or a primitive ber-tlv data object, or the

#### referred template in the case of a constructed DO.

#### Irrespective of bit b1 in INS, if a set of DOs is provided or if the content of an EF is requested, then the

#### appropriate data field shall contain the DO(s).

#### 11.5.1.4 Access to the extension of the template referenced by curConstructedDO

#### When a template is extended by tagged wrappers (see 8.4.9), this extension is only valid for get data

#### and get next data commands. All other commands handling DOs by their tag only are limited to

#### the base template. Automatic resolution of tagged wrappers (see 8.4.9) shall not modify the template

#### referenced by curConstructedDO.

#### If the template contains one or several wrapper(s), 8.4.8 describes how to recover DOs expected to be

#### relevant to the template.

#### 11.5.1.5 Execution or rejection conditions

#### Any command of this group shall be aborted if the parameters which select a DO to be accessed do not

#### match the actual structures within the card, e.g.:

#### — if applied to a structure (DF or EF) not supporting data objects;

#### — if the parameters do not match the actual data object structure.

#### It can be performed only if the security status satisfies the security conditions defined by the application

#### within the context for the function.

#### 11.5.2 select data command

#### 11.5.2.1 General

#### Table 95 shows the select data C-RP. Provided that it does not modify the LCS of a DO, the select data

#### is always granted.


#### The functions of this command are

#### — to set a selected DO, i.e. the target of the command, as curDO;

#### — to set reference data to be compared e.g. with comparison data by a subsequent compare command

#### (se e 11 .7.1);

#### — to modify the VA (see 7. 2 .1 ) if the DO to be selected does not belong to the current VA of a template

#### referenced by curConstructedDO. If the command transmits

#### — an application identifier DO'4F', and no file reference DO'51', it selects an application DF [see

#### 7.2.2 rule d)];

#### — no DO'4F', but a DO'51', it selects a file [see 7.2.2 rule e) or f )];

#### — a DO'4F' and a DO'51', it selects an application DF, [see 7.2.2 rule d)], and a file [see 7.2.2

#### rule e) or f )];

#### — a record number (see argument 3 in Table 94 ) it modifies curRecord [see 7.2.2 rule g)];

#### — an offset (see argument 3 in Table 94 ), it modifies curDataString [see 7.2.2 r u le h)].

#### Table 94 — Value of the general reference DO'60' (General reference template)

```
Arg. Nested DOs Comment
1 application identifier DO'4F' Optional
```
```
2 file reference DO'51' (see Table 8 )
```
```
Optional, even number of bytes. Valid if the path matches the
file structure of the current application, or of the application
referenced by a DO'4F'.
```
(^3) betweenChoice
Record number DO'02'
followed by Length DO'02'
Optional. References a record or a virtual DO'7F70' the value
of which is a record in an EF
Offset DO'54' followed by
Length DO'02'
Optional. References a DataString or a virtual DO'7F70' the
value of which is a DataString in a transparent EF.
(^4) betweenChoice
tag list DO'5C' Nests one tag present in the template referenced by curConstructedDO. Argument 4, mandato-
ry in DO referencing.
Applies to the template
referenced by cur-
ConstructedDO or to
the value field of the
transiently selected
DO set by the previous
arguments
extended header DO'4D'
or '5F61' (see 8.4.5 for the
rationale of a choice)
The value of the extended header
starts with a tag present in the
template referenced by curCon-
structedDO.
DO'5F8400' containing a
masked tag References a DO by a masked tag.
filter DO'7F71' References a constructed DO by its content

##### 5, 6, 7,

##### ...

```
arbitrary number of masked tag
DO'5F8400' and/or filter DO'7F71' in any
order; the result of applying a mask or
filter to a set of DO is a subset; the result
of applying all masks and all filters is the
intersection of all of those subsets
```
```
DO'5F8400' references a DO by a
masked tag; DO'7F71' references a
constructed DO by its content.
```
```
Optional if the DO ref-
erenced by argument 4
is constructed.
```

#### Table 95 — select data command-response pair

```
CLA As defined in 5.4.1
INS 'A5'
```
```
P1
```
```
< 'F0' Occurrence number of an instance.
'F0' Select the parent of the DO referenced by curConstructedDO
> 'F0' RFU
P2 See Table 96
Lc field Absent for encoding Nc = 0, present for encoding Nc > 0
```
```
Data field
```
```
May be empty if P1='F0'. If P1 is not ‘F0’ at least argument 4 of a general reference DO'60' (see
Table 94 ). Other arguments are optional.
All arguments shall be in the same order as in the general reference template.
Le field Absent for encoding Ne = 0, present for encoding Ne > 0 if response data are required by P2 (see Table 96 )
```
```
Data field Absent or information according to P2.
SW1-SW2 See '6A88' (DOs not found, i.e., referenced data not found)Table 6 and Table^7 when relevant, e.g., '6202' to '6280', '6281', '6700', '6981', '6982', '6985', '6A81',
```
#### Table 96 — Coding of P2 in select data command

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 0 0 - - - x x Next occurrence in the template referenced by curConstructedDO in search direction after skipping P1 occurrences
0 0 0 - - - 0 0 — Search forward from first DO
0 0 0 - - - 0 1 — Search backward from last DO
0 0 0 - - - 1 0 — Search forward from curDO
0 0 0 - - - 1 1 — Search backward from curDO
0 0 0 x x x - - Response data field requirements (see 7.4.2 and Table 9)
0 0 0 0 0 1 - - Return the data control information (DO'62')
0 0 0 0 1 0 - - Return the tag list of the template referenced by curConstructedDO (DO'5C') (dir function)
```
```
0 0 0 1 0 0 - - Return the tag list of the template referenced by curConstructedDO (DO'5C') (view function)
```
##### 0 0 0 1 1 0 - -

```
Return the tag list of the template referenced by curConstructedDO (DO'5C')
(dir function) followed by the tag list of the template referenced by curCon-
structedDO (DO'5C') (view function)
NOTE Any other value is RFU.
```
#### Except when P1 is set to 'F0', processing this command involves a sequence of searches for a match

#### within value field of the transiently selected DOs. The search for the last match will take place:

#### — in the last transiently selected constructed DO (highest generation) defined by the arguments, when

#### the last tag references either a primitive DO, or a constructed DO with the options "first" or "last". If

#### a match is found, the selected DO is a child of the last transient constructed DO;

#### — in the parent DO of the last transiently selected constructed DO (highest but one generation), when

#### the last tag references a constructed DO with the options "next" or "previous". If a match is found,

#### the selected DO is a sibling of the last transient constructed DO;

#### In the following examples, the value field of the transiently selected constructed DO in which the last

#### match will take place:

#### P1-P2='0000' selects the first occurrence of a DO within the value field of the transiently selected DO.

#### P1-P2='0100' selects the second occurrence of a DO within the value field of the transiently selected DO.


#### P1-P2='0101' selects the penultimate occurrence of a DO within the value field of the transiently

#### selected DO.

#### P1-P2='0001' selects the last occurrence of a DO within the value field of the transiently selected DO.

#### P1-P2='0102' selects either the second next occurrence of a primitive DO within the value field of the

#### transiently selected DO or the second next sibling of the DO referenced by curConstructedDO.

#### A failed select data C-RP (SW1 in interval [‘64’, ‘6F’], see Table 7 ) does not modify the current VA.

#### 11.5.2.2 Basic target definition

#### Basic target definition uses arguments 1, 2 and 4. If the target, i.e. the DO to be selected:

#### — is not contained in the current application, the data field shall include an application identifier DO'4F';

#### — is not contained in the current file after possible transient application selection, the data field shall

#### include a file reference DO'51' when file referencing applies in the application.

#### The tag of the target shall be either:

#### — encapsulated in a tag list DO'5C', or

#### — defined by an extender header list DO'4D' or '5F61' (see 8.4.5 for the reasons for a choice), or

#### — defined by a masked tag DO'5F8400', or

#### — defined by the content of a constructed DO by a filter DO'7F71'.

#### Conditional argument 3 references a virtual DO'7F70' the value of which is either a record in an EF

#### structured in records, or a DataString in a transparent EF. The transiently selected DO'7F70' shall

#### become the DO referenced bycurConstructedDO if the mandatory argument does not reference a

#### constructed DO.

#### 11.5.2.3 Referencing by masked tag DO and filter DO

#### If the command references one constructed DO, setting curConstructedDO, a conditional argument 5,

#### masked tag DO'5F8400' or filter DO'7F71' may be present.

#### If the masked tag DO'5F8400' is present, the command should return a tag list DO'5C' nesting the

#### concatenation of all tags of the template matching the masked tag. A masked tag nests two data

#### elements of the same length, i.e. <mask value> followed by <target tag>. A match with tag <matching

#### tag> happens when:

#### <mask value> AND <matching tag> = <mask value> AND <target tag>

#### If the filter DO'7F71' is present, the command shall succeed if and only if the value of the filter DO'7F71'

#### is either:

#### — a constructed DO belonging to the value field of the transiently selected DO; this DO becomes

#### current; or

#### — a pruned-tree (see 8.2.3) of a constructed DO belonging to the value field of the transiently selected

#### DO; this DO becomes current.

#### 11.5.2.4 get data control parameters function

#### When required by bit b3 set to 1 in P2, the response payload is a DO'62' (see Table 11 ) relevant to the

#### (transiently or finally) DO referenced by curDO, after possible modification of the data LCS. If DO'62' is

#### not available, CP DOs may be present under a tag reserved for the tag allocation authority (see 8.3.4).


#### 11.5.2.5 dir function

#### When required by bit b4 set to 1 in P2, the command should return a tag list DO'5C' nesting the

#### concatenation of all tags of the template referenced by curConstructedDO (possibly including a template

#### extension) set by the command.

#### An actual tag list DO may either be present in the template, or dynamically generated by the

#### implementation. In both cases,

#### — the tags shall be present irrespective of the security attributes or value of data LCS of the

#### corresponding DO;

#### — if several instances of the same DO are present, the tag shall be repeated;

#### — if present, wrapper DOs shall always appear.

#### If the implementation resolves the indirections, the local tags of the DOs defined in the wrappers may

#### appear in the tag list (which displays the extended template). If not, they shall not (the tag list displays

#### the base template).

#### 11.5.2.6 view function

#### When required by bit b5 set to 1 in P2, the command should return a tag list DO'5C' nesting the same

#### concatenation of tags as in the DIR function, but, according to its needs, an application may exclude the

#### tags of e.g.:

#### — DOs not readable under the current security status;

#### — DOs not in activated state;

#### — tagged wrappers when automatic resolving of those is granted (see 8.4.9).

#### 11.5.2.7 File-related functions

#### When argument 4 is absent in the command data field, and argument 3 is present, a successful select

#### data command shall

#### — set curRecord in case argument 3 contains a record number, or

#### — set the DataString referenced by argument 3 as curDataString in case argument 3 contains an

#### offset DO.

#### When arguments 3 and 4 are absent in the command data field, arguments 1 and 2 support the selection

#### of an application, of a file in the current application, or file within a given application.

#### 11.5.3 get data/get next data commands — even INS codes

#### 11.5.3.1 General

#### Table 97 shows the get data/next get data - even INS codes C-RP. The main function of those

#### commands with even INS code is the retrieval of the value field of a DO within the current context (e.g.

#### DF referenced by curDF). It may be the content of an EF supporting DOs.

#### If there are several occurrences of a tag in the template referenced by curConstructedDO, this clause

#### does not define which DO is returned by a successful get data except cyclic management applying

#### because that depends on the definition or the nature or the content of the DO. get next data has a

#### precise behaviour (see 11.5.3.4).

#### A required DO or data element shall be absent from the response when the security status does not

#### match its security attributes.


#### Table 97 — get data/get next data command-response pair (even INS codes)

```
CLA As defined in 5.4.1
```
```
INS
```
```
'CA' get data
'CC' get next data
P1-P2 See erenced by curConstructedDOTable^93 , if the special value '00FF' is used the command obtains all DOs from the template ref-
Lc field Absent for encoding Nc = 0
Data field Absent
Le field Present for encoding Ne > 0,
```
```
Data field 0, 1 or more data bytes according to P1-P2.
SW1-SW2 See '6A88' (data objects not found, i.e., referenced data not found)Table 6 and Table^7 when relevant, e.g., '6202' to '6280', '6281', '6700', '6981', '6982', '6985', '6A81',
```
#### 11.5.3.2 select function

#### After a successful get data command of a constructed DO, this DO becomes the DO referenced by

#### curConstructedDO.

#### A successful get next data command shall impact neither the DO referenced by curDO, nor the

#### template referenced by curConstructedDO.

#### 11.5.3.3 get data control parameters function

#### When the argument of an even INS get data/get next data is the CP template tag '62', the response

#### payload is a concatenation of CP DOs (see Table 11 ) attached to the DOs in the same template. If DO'62'

#### is not available, CP DOs may be present under a tag reserved for the tag allocation authority (see 8.4.4).

#### 11.5.3.4 Specific functions of get next data and pointer handling

#### When there are several occurrences of the same tag in the template, successive get next data

#### commands shall return their values sequentially. The order in which the values are recovered shall be

#### the same as the order of those tags recovered by a dir or view function (see 11.5.2.5 or 11.5.2.6).

#### Contrary to get data, a successful get next data command shall not impact the VA. The handling of

#### multiple instances implies the following.

#### — A template is seen as an ordered list of DOs at the interface between a card and an interface device.

#### The term "ordered list" implies that this list has a first and a last element. Each list element, except

#### the last, has a next element. Each list element, except the first, has a previous element.

#### — A pointer is attached to a logical channel. The default value of this pointer is to be unset. The pointer

#### is set by a get next data, put data, put next data or update data command (see 11.5.6, 11.5.7

#### and 11.5.8). This pointer shall be unset if any command different from a command setting it (see

#### previous sentence) is transmitted on the same logical channel. The transmission of a command on a

#### logical channel should not impact the pointer on another logical channel.

#### When a sequence of DOs supports cyclic management, a get data or get next data command shall

#### recover first the most recent instance. A further get next data shall recover the remaining most recent

#### instance, etc...

#### When all data elements or DOs have been transmitted by the card in successive get next data

#### responses, a further get next data shall be rejected by SW1-SW2 = '6A88'.


#### 11.5.4 get data/get next data commands — odd INS codes

#### 11.5.4.1 General

#### Table 98 shows the get data/next get data - odd INS codes C-RP. The main function of those commands

#### with odd INS code is the retrieval of the value field of one or several DOs according to the arguments of

#### the command. The target selection is very close to the select data selection, except that:

#### — the command may return several DOs, whereas a select data selects a single DO;

#### — argument 2 of the select data may be replaced by a file identifier in P1-P2, functionally equivalent

#### to a file reference DO containing one file identifier. If this option is used, the command data field

#### shall not feature argument 1 (DO'4F').

#### When a get data/get next data requires one (or several) constructed DO(s), all DOs nested within

#### shall be present in the response, except:

#### 1) when no DO with the required tag is available in the template;

#### 2) when the security status does not match its security attributes;

#### 3) if not explicitly required when the argument of the command is an extended header list.

#### A get data/get next data command may not be rejected if one or several required DOs are unavailable

#### for one of those reasons. It shall be rejected only if no DO is available.

#### If there are several occurrences of a tag in the template referenced by curConstructedDO, this clause

#### does not define which DO is returned by a successful get data except cyclic management applying

#### because that depends on the definition or the nature or the content of the DO. get next data has a

#### precise behaviour (see 11.5.3.4).

#### Table 98 — get data/get next data command-response pair (odd INS codes)

```
CLA As defined in 5.4.1
```
```
INS
```
```
'CB' get data
'CD' get next data
```
##### P1-P2

```
'0000' Current file, except if the data field references a file.
'FFFF' template referenced by curConstructedDO or value field of the transiently selected DO possibly set by the data field
o t h e r
values
```
```
File identifier or short EF identifier (see 11.5.1.2)
The data field contains neither an application identifier DO'4F' nor a file reference DO'51'.
Lc field Present for encoding Nc > 0
Data field A tag list data object (tag’5C’), or a header list data object (tag’5D’), or an extended header list data object (tag’4D’, tag’5f61’), or a masked tag data object (tag’5F8400’), or a filter data object (tag’7F71’)
Le field Present for encoding Ne > 0
```
```
Data field 0, 1 or more data bytes
SW1-SW2 See '6A88' (data objects not found, i.e., referenced data not found)Table 6 and Table^7 when relevant, e.g., '6202' to '6280', '6281', '6700', '6981', '6982', '6985', '6A81',
```
#### 11.5.4.2 Mandatory argument

#### The command data field shall end with either a tag list DO'5C' (see 8.4.3) or an extended header list

#### DO'4D' or DO'5F61' (see 8.4.5), a masked DO'5F8400' or a filter DO'7F71' (see 11.5.2.3).

#### — In the tag list case, the response data field shall be the concatenation of the DOs referenced in the tag

#### list, in the same order. The order may be different from the order of the DOs in the template. When


#### several DOs within the template have the same tag, all those DOs shall be returned. One or more DOs

#### may be absent for security status reasons. An empty tag list requires all the available DOs.

#### — In the extended header list case, the response data field shall be the concatenation of the DOs derived

#### from the extended header list according to 8.4.6 and 8.4.7.

#### — In the masked tag case or in the filter case, the response data field shall be the concatenation of the

#### matching DOs.

#### 11.5.4.3 select function

#### If a get data command with P1-P2 not equal to 'FFFF' references a file, the side effect of its success shall

#### be to set this file as the file referenced by curFile and the value field of the root DO'7F70' referenced by

#### curConstructedDO.

#### A successful get data shall not impact the VA, if

#### — P1-P2 set to 'FFFF',

#### — argument 1 and/or argument 3 present,

#### — argument 4 different from DO'4D' or DO'5C'.

#### 11.5.4.4 dir and view functions

#### The dir/view function is supported by an odd INS get data/get next data when its argument is:

#### — '5C 01 5C' (tag '5C' nested in a tag list DO); the response payload should be a tag list DO'5C' nesting

#### the response payload defined in 11.5.2.5 or 11.5.2.6;

#### — '5C 01 5D' (tag'5D' nested in a tag list DO); the response payload should be a header list DO'5D'

#### nesting the response payload defined in 11.5.2.5 or 11.5.2.6.

#### The choice between the DIR and VIEW function is out of scope of this document.

#### 11.5.4.5 get data control parameters function

#### When the argument of an odd INS get data is '5C 01 62' (tag '62' (CP template tag) nested in a tag list

#### DO), the response payload should be a DO'62'.

#### 11.5.4.6 Specific functions of get next data (INS = 'CD')

#### The properties of get next data (INS='CD') with respect to get data (INS='CB') are identical to those

#### of get next data (INS='CC' ) with respect to get data (INS='CA', see 11.5.3.4), except that the C-RPs

#### with odd INS codes return DOs, the C-RPs with even INS codes return data elements (values of DOs).

#### 11.5.5 General properties of put data/put next data/update data commands

#### Those commands initiate the modification of the DO referenced by curConstructedDO, by transmitting

#### one or several DO(s), possibly constructed. put/put next/update data with bit b1 of INS:

#### — set to 0 shall only operate in the template referenced by curConstructedDO;

#### — set to 1 sets the transient template as the value of the virtual root DO'7F70', selected according to

#### P1-P2 not equal to 'FFFF', before the actual handling of the DO(s). The value field of the transiently

#### selected DO shall become the template referenced by curConstructedDO if the command succeeds.

#### If the pointer is set by a successful get next data or put next data C-RP (see 11.5.3.4) it defines which

#### instance shall be affected by an update data or put data C - R P.


#### If the pointer is unset (see 11.5.3.4) curDO (see 7. 2 .1) defines which DO is affected by an update data or

#### put data C - R P.

#### Whereas put data and update data commands may include several DOs in the command data field, a

#### put next data command shall feature one and only one DO in the command data field.

#### 11.5.6 put data command

#### Table 9 9 shows the put data C-RP. The put data command may have the behaviour and codings

#### defined for update data (r esp put next data). If INS is set to 'DB' and P1-P2 is set to 'FFFF', the

#### following rules apply:

#### — If put next data is supported, a put data of a DO the tag of which already exists in the template

#### shall replace an existing DO by a new one.

#### — If update data is supported, a put data shall ensure that the whole transmitted DO is added to the

#### template. This may result in a duplication of instances within the template.

#### When the Lc field is absent, the even INS put data command shall add an empty DO or replace an

#### existing DO by an empty DO of the same tag as indicated by P1-P2.

#### Table 99 — put data command-response pair

```
CLA As defined in 5.4.1
INS 'DA' or 'DB'
```
##### P1-P2

##### INS = 'DA'

```
See Table 93 , if the special value '00FF' is used the command data field contains a
concatenation of DOs to be added to or replaced in the template referenced by cur-
ConstructedDO
INS = 'DB' File identifier or short EF identifier (see 11.5.1.2)
Lc field Present for encoding Nc > 0, absent for encoding Nc = 0
```
```
Data field INS = 'DA' Data bytes according to P1-P2, or absent to delete the value of a DO.
INS = 'DB' Concatenation of DOs
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2 See '6A80', '6A81', '6A84', '6A85'Table 6 and Table^7 when relevant, e.g., '63CX' (see 11.5.1), '6581', '6700', '6981', '6982', '6985',
```
#### 11.5.7 put next data command

#### Table 10 0 shows the put next data C-RP. The command initiates the addition of one DO within the

#### template referenced by curConstructedDO. If a DO with the same tag as a DO to be inserted already

#### exists in the template, it shall add this new instance of the DO within the template. If the number of

#### instances has not reached its maximum value, put next data shall add the transmitted DO to the

#### template referenced by curConstructedDO, and set the pointer on the DO which has been put. The

#### outcome of this command depends on the structure of the DO as given by the data descriptor byte (see

#### Table 14 ). If the structure is of type

#### — "no information given" and the number of instances has reached its maximum value, put next data

#### shall be rejected with SW1-SW2='6A84"; otherwise the new DO is inserted at an arbitrary position

#### in the ordered list of DO;

#### — "linear management" and the number of instances has reached its maximum value, put next data

#### shall be rejected with SW1-SW2='6A84"; otherwise if the pointer is

#### — unset, then the new DO shall be appended after the last element of the list;


#### — set, then the new DO shall be inserted such that it becomes the previous list element with

#### respect to the pointed DO;

#### — "cyclic management" and the pointer is

#### — unset, then the new DO shall become the first element of the list;

#### — set, then the new DO shall be inserted such that it becomes the next list element with respect to

#### the pointed DO.

#### Furthermore, if the structure is of type "cyclic management" and after inserting the new DO into the

#### ordered list the number of instances is greater than the maximum value then the DO nearest to the end

#### of the ordered list having the same tag as the inserted one shall be deleted.

NOTE 1 The rules for insertion of a new DO are such that with linear and cyclic management a new DO can be
inserted at any position in the ordered list.

NOTE 2 If the pointer is unset then the cyclic management behaves as the append record for EFs with cyclic
structure.

NOTE 3 If the structure is of cyclic management and the pointer points to the last element and the number
of instances has reached its maximum value then the rules imply that inserting a new DO has no effect to the
ordered list.

NOTE 4 If the instances are explicitly numbered, the handling of the instance number (see Table 11 ) is
dynamic.

NOTE 5 This version of the standard does not define how the maximum number of instances could be seen at
the card's interface.

#### If several DOs are transmitted, the command shall be aborted (SW1-SW2 = '6A80'), without changing

#### anything in the template referenced by curConstructedDO.

#### Table 100 — put next data command-response pair

```
CLA As defined in 5.4.1
INS 'D8' or 'D9'
```
```
P1-P2
```
```
INS = 'D8' See Tableto be added to the template referenced by curConstructedDO^93 , if the special value '00FF' is used the command data field contains a DO
INS = 'D9' File identifier or short EF identifier (see 11.5.1.2)
Lc field Present for encoding Nc > 0
```
```
Data field
```
```
INS = 'D8' Data bytes according to P1-P2
INS = 'D9' One DO
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2 See '6A80', '6A81', '6A84', '6A85'Table 6 and Table^7 when relevant, e.g., '63CX' (see 11.5.1), '6581', '6700', '6981', '6982', '6985',
```
#### 11.5.8 update data command

#### Table 101 shows the update data C-RP.


#### Table 101 — update data command-response pair

```
CLA As defined in 5.4.1
INS 'DE' or 'DF'
```
##### P1-P2

##### INS = 'DE'

```
See Table 93 , if the special value '00FF' is used the command data field contains a
concatenation of DOs to be processed within the template referenced by curCon-
structedDO
INS = 'DF' File identifier or short EF identifier (see 11.5.1.2)
Lc field Present for encoding Nc > 0, absent for encoding Nc = 0 (see below)
```
```
Data field
```
```
INS = 'DE' Data bytes according to P1-P2, or absent to delete the value of a DO^
INS = 'DF' One DO
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2 See '6A80', '6A81', '6A84', '6A85'Table 6 and Table^7 when relevant, e.g., '63CX' (see 11.5.1), '6581', '6700', '6981', '6982', '6985',
```
#### For each DO indicated in the data field, the command shall perform either:

#### a) the modification of a DO, within the template referenced by curConstructedDO; if several instances

#### of a DO exist, and:

#### 1) one of them is the DO referenced by curDO, it shall be updated;

#### 2) if the DO referenced by curDO is not one of the instances, this document does not define which

#### instance of the DO is updated; or

#### b) the deletion of a DO's value field, with the same conditions as above when several instances exist;

#### updating a non-empty DO with an empty DO replaces the existing DO by an empty one; or

#### c) the creation of a DO, within the template referenced by curConstructedDO, if no DO with the same

#### tag already exists.

#### Updating a primitive DO replaces the existing DO by the transmitted DO.

#### To update a constructed DO (see F. 3), all templates present in the transmitted DO shall be processed

#### successively, starting with the lowest generation number. The DOs already present in the template shall

#### be modified, and the DOs not present in the template shall be created in the template. If one or several

#### DOs to be modified are constructed, the procedure shall be repeated at the next generation, and so on.

NOTE This updates DOs within a constructed DO without the need to retransmit the whole constructed DO.

#### 11.5.9 compare data function

#### This function is supported by the compare command (see 11 .7.1).

### 11.6 Basic security handling

#### 11.6.1 General................................................................................................................................................................................

#### The security-related procedures, supported by the commands described in this clause, often involve an

#### ordered sequence including those commands, and commands described in ISO/IEC 7816-8. The use of

#### security attribute extensions (see 9. 3 .7. 2) supports the description of such sequences at the interface.

#### The commands of this group reserve P1-P2 for referencing an algorithm and some related reference data

#### (e.g. a key). If there is a current key and a current algorithm, then the command may implicitly use them.


#### P1 — Unless otherwise specified, P1 references the algorithm to use: either a cryptographic algorithm

#### or a biometric algorithm (see ISO/IEC 7816-11). P1 set to '00' means that no information is given, i.e.

#### either the reference is known before issuing the command, or the command data field provides it.

#### P2 — Unless otherwise specified, P2 qualifies reference data according to Table 102. P2 set to '00'

#### means that no information is given, i.e. either the qualifier is known before issuing the command, or the

#### command data field provides it. The qualifier may be for example a password number or a key number

#### or a short EF identifier.

#### Table 102 — Coding of the reference data qualifier in P2

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 0 0 0 0 0 0 0 No information given
0 - - - - - - - Global reference data (e.g. MF specific password or key)
1 - - - - - - - Specific reference data (e.g. DF specific password or key)
```
- x x - - - - - 00 (any other value is RFU)
- - - x x x x x Qualifier, i.e. number of the reference data or number of the secret

NOTE A manage security environment command can set an algorithm reference and/or a multi-byte
reference data qualifier (see Table 52 ).

#### In this group of commands, SW1-SW2 set to '6300' or '63CX' indicates that the verification failed,

#### 'X' >= '0' encodes the number of further allowed retries. SW1-SW2 set to '6A88' means “reference data

#### not found”.

#### 11.6.2 internal authenticate command

#### Table 103 shows the internal authenticate C-RP. The command initiates the computation of

#### authentication data by the card using the challenge data sent by the interface device and a relevant

#### secret (e.g. a key) stored in the card.

#### — If the relevant secret is attached to the MF, then the command may be used to authenticate the card

#### as a whole.

#### — If the relevant secret is attached to another DF, then the command may be used to authenticate that DF.

#### Any successful authentication may be subject to completion of prior commands (e.g. verify , select) or

#### selections (e.g. the relevant secret).

#### The card may record the number of times the command is issued, in order to limit the number of further

#### uses of the relevant secret or the algorithm.

NOTE The response data field can include data useful for further security functions (e.g. random number).

#### Table 103 — internal authenticate command-response pair

```
CLA As defined in 5.4.1
INS '88'
P1-P2 See 11.6.1 and Table 102
Lc field Present for encoding Nc > 0
Data field Authentication-related data (e.g. challenge)
Le field Present for encoding Ne > 0
```
```
Data field Authentication-related data (e.g. response to a challenge)
SW1-SW2 See '6983', '6984', '6A81', '6A82', '6A86', '6A88' (see Table 6 and Table^7 when relevant, e.g. '6300' (see 11.6.111.6.1) ), '63CX' (see 11.6.1), '6581', '6700', '6982',
```

#### 11.6.3 get challenge command

#### Table 10 4 shows the get challenge C-RP. The command requires the issuing of a challenge (e.g. a random

#### number for a cryptographic authentication or a sentence to prompt for a biometric authentication using

#### voiceprints) for use in a security-related procedure (e.g. external authenticate command). The

#### challenge is valid at least for the next command; this clause specifies no further condition.

#### Table 104 — get challenge command-response pair

```
CLA As defined in 5.4.1
INS '84'
P1 See 11.6.1
P2 '00' (any other value is RFU)
Lc field Absent for encoding Nc = 0
Data field Absent
Le field Present for encoding Ne > 0
```
```
Data field Challenge
SW1-SW2 See Table 6 and Table 7 when relevant, e.g. '6700', '6A86' (see 11.6.1)
```
#### 11.6.4 external authenticate command

#### The functions of this command can be performed only if the security status satisfies the security

#### attributes for this operation.

#### This command has several flavours. Table 105 shows the external authenticate C-RP whereas

#### Table 106 shows the C-RP of the mutual authenticate function. The command conditionally updates

#### the security status using the result (yes or no) of the computation by the card based on a challenge

#### previously issued by the card (e.g. by a get challenge command), a key possibly secret stored in the

#### card and authentication data transmitted by the interface device.

#### Any successful authentication requires the use of the last challenge obtained from the card. The card

#### may record unsuccessful authentications (e.g. to limit the number of further uses of the reference data).

#### The absence of command data field may be used either to retrieve the number 'X' of further allowed

#### retries (SW1-SW2 set to '63CX'), or to check whether the verification is required or not (SW1-SW2 set

#### to '9000').

#### mutual authenticate function — The mutual authenticate function uses the same functionalities

#### as external and internal authenticate commands. It is based upon a previous get challenge

#### command and a key, possibly secret, stored in the card. The card and the interface device share

#### authentication-related data, including two challenges: one issued by the card, another one issued by the

#### interface device.

NOTE The command can be used for implementing authentication as specified in ISO/IEC 9798-2 and
ISO/IEC 9798-3.


#### Table 105 — external authenticate command-response pair

```
CLA As defined in 5.4.1
INS '82'
P1-P2 See 11.6.1 and Table 102
Lc field Absent for encoding Nc = 0, present for encoding Nc > 0
Data field Absent or authentication-related data (e.g. response to a challenge)
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2 See '6983', '6984', '6A81', '6A82', '6A86', '6A88' (see Table 6 and Table^7 when relevant, e.g. '6300' (see 11.6.111.6.1) ), '63CX' (see 11.6.1), '6581', '6700', '6982',
```
#### Table 106 — Command-response pair for mutual authenticate function

```
CLA As defined in 5.4.1
INS '82'
P1-P2 See 11.6.1 and Table 102
Lc field Present for encoding Nc > 0
Data field Authentication-related data
Le field Present for encoding Ne > 0
```
```
Data field Authentication-related data
SW1-SW2 See '6983', '6984', '6A81', '6A82', '6A86', '6A88' (see Table 6 and Table^7 when relevant, e.g. '6300' (see 11.6.111.6.1) ), '63CX' (see 11.6.1), '6581', '6700', '6982',
```
#### 11.6.5 general authenticate command

#### Table 107 shows the general authenticate C-RP. The command refines the external, internal and

#### mutual authenticate functions; namely, either an entity in the outside world authenticates an entity

#### in the card (internal authenticate function), or an entity in the card authenticates an entity in the

#### outside world (external authenticate function), or both (mutual authenticate function).

#### While appropriate for authentication mechanisms involving challenge-response pairs, the external and

#### internal authenticate commands preclude authentication mechanisms involving witness-challenge-

#### response triples [see ISO/IEC 9798 (all parts)[8]] and more generally multi-step authentication protocols.

#### Those require two or more general authenticate C-RPs: such C-RPs may be chained (see 5.3.3).

#### The function (either internal, or external, or mutual authenticate) can be performed only if the

#### security status satisfies the security attributes for this operation. Any successful authentication may

#### be subject to completion of prior commands (e.g. verify, select) or selections (e.g. the relevant secret).

#### The result (yes or no) of a control performed by the card may conditionally update the security status.

#### The card may record the number of times the function is issued, in order to limit the number of further

#### uses of the relevant secret or the algorithm. The card may record unsuccessful authentications, e.g. to

#### limit the number of further uses of the reference data.


#### Table 107 — general authenticate command-response pair

```
CLA As defined in 5.4.1
INS '86' or '87'
P1-P2 See 11.6.1 and Table 102
Lc field Present for encoding Nc > 0
Data field Authentication-related data
Le field Absent for encoding Ne = 0, present for encoding Ne > 0
```
```
Data field Absent (either due to the absence of Lfunction, or if the process is aborted), or authentication-related datae field, e.g. the last command of an external authenticate^
```
```
SW1-SW2 See '6983', '6984', '6A81', '6A82', '6A86', '6A88' (see Table 6 and Table^7 when relevant, e.g. '6300' (see 11.6.111.6.1) ), '63CX' (see 11.6.1), '6581', '6700', '6982',
```
#### Table 108 — Dynamic authentication DOs for witness-challenge-response triples

```
Tag Value
'7C' Set of dynamic authentication DOs with the following tags
'80' Witness (e.g. one or more positive numbers less than the public modulus in use)
'81' Challenge (e.g. one or more numbers, possibly 0 less than the public exponent in use)
'82' Response (e.g. one or more positive numbers less than the public modulus in use)
'83' Committed challenge (e.g. the hash-code of a large random number including one or more challenges)
'84' Authentication code (e.g. the hash-code of one or more data fields and a witness DO)
'85' A public key for key agreement
'86' Enciphered data
'06' OID (see text below)
'A0' Identification data template
NOTE Under tag '7C', ISO/IEC JTC 1/SC 17 reserves any other DO of the context-specific class, if no OID specifies the context
otherwise.
```
#### When present, each data field shall contain an interindustry template referenced by tag '7C'.

#### The default context of the general authenticate command(s) regarding the cryptographic protocol

#### in use is reserved for witness-challenge-response triples (see C.2). In this case in the dynamic

#### authentication template, the context-specific class is reserved for dynamic authentication DOs as listed

#### in Table 10 8.

#### In this case respective context specific DOs shall be sent in the C-RPs, embedded in a template with Tag

#### '7C' (see Table 10 8).

#### If the general authenticate command(s) are used for a multi-step authentication protocol (see C.3),

#### the respective protocol OID or algorithm reference being associated with an OID shall be included in a

#### preceded manage security environment command (see 11.6.11) in the AT and/or shall be contained in

#### the template with Tag '7C' indicating the protocol specific interpretation of the additionally embedded

#### context specific DOs sent in the C-RPs.

#### For the default context, the following rules apply within the interindustry template for dynamic

#### authentication.

#### — If a DO is empty in a template, then it shall be complete in the template in the next data field.

#### — In the first command data field, the template indicates the dynamic authentication function as

#### follows.

#### — A witness request, e.g. an empty witness, denotes an internal authenticate function.


#### — A challenge request, e.g. an empty challenge, denotes an external authenticate function.

#### — The absence of empty DO denotes a mutual authenticate function. Then unless the card

#### aborts the process, the template in the response data field shall contain the same DOs as the

#### template in the command data field. The mutual authenticate function allows two entities

#### to agree on a session key using a pair of “exponential” data elements referenced by tag '85' (see

#### key agreement techniques in ISO/IEC 11770-3[13]).

#### The dynamic authentication may protect data fields exchanged during a session. Both entities maintain

#### a current hash-code, updated by including one command or response data field at a time. The DO'84'

#### conveys an authentication code resulting from updating the current code by including a witness DO'80'.

#### The verifier successively reconstructs a witness and an authentication code: if the reconstructed

#### witness is not 0 and if the two codes are identical, then the authentication is successful.

#### For the default context, C.2 illustrates general authenticate C-RPs for implementing internal,

#### external and mutual authenticate functions, with extensions to data field authentication and key

#### agreement.

#### 11.6.6 verify command

#### Table 109 — verify command-response pair

```
CLA As defined in 5.4.1
INS '20' or '21'
'00' Normal operation
P1 'FF' set verification status to “not verified”, see last paragraph of this clause
any other value RFU
P2 See Table 102
Lc field Absent for encoding Nc = 0, present for encoding Nc > 0
```
```
Data field INS = '20' Verification data or absent
INS = '21' Verification data DO, and, conditionally, extended header list
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2 See '6982', '6983', '6984', '6A81', '6A82', '6A86', '6A88' (see Table 6 and Table^7 when relevant, e.g. '6286', '6300' (see 11.6.1)11.6.1), '63CX' (see 11.6.1), '6581', '6700',
```
#### Table 10 9 shows the verify C-RP. The command initiates the comparison in the card of stored reference

#### data with verification data sent from the interface device (e.g. password) or from a sensor on the card

#### (e.g. fingerprint). The security status may be modified as a result of a comparison. The card may record

#### unsuccessful comparisons (e.g. to limit the number of further uses of the reference data).

#### If INS = '20', the command data field is normally present for conveying verification data. The absence of

#### command data field is used to check whether the verification is required (SW1-SW2 = '63CX' where 'X'

#### encodes the number of further allowed retries), or not (SW1-SW2 = '9000').

#### If INS = '21', the command data field shall convey a verification data DO (e.g. tag '5F2E', see

#### ISO/IEC 7816-11), normally not empty. The presence of an empty verification data DO and an extended

#### header list (tag '4D', see 8.4.5) expresses that the verification data come from a sensor on the card. The

#### extended header list references the verification data DO.

#### With both INS values, P1='FF' shall only be used with Lc and command data field absent. The command

#### shall set the verification status of the relevant reference data as "not verified".


#### 11.6.7 change reference data command

#### Table 110 shows the change reference data C-RP. The command either replaces reference data

#### stored in the card with new reference data sent from the interface device, or initiates their comparison

#### with verification data sent from the interface device and then conditionally replaces them with new

#### reference data sent from the interface device. It can be performed only if the security status satisfies

#### the security attributes for this command.

#### Table 110 — change reference data command-response pair

```
CLA As defined in 5.4.1
INS '24' or '25'
P1 '00' or '01' (any other value is RFU)
P2 See Table 102
Lc field Present for encoding Nc > 0
```
```
Data field
```
##### INS = '24'

```
P1 = '00' Verification data followed without delimiter by new reference data
P1 = '01' New reference data
```
```
INS = '25'
```
```
P1 = '00' Verification data DO followed by new reference data DO
P1 = '01' New reference data DO
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2 See '6983', '6984', '6A81', '6A82', '6A86', '6A88' (see Table 6 and Table^7 when relevant, e.g. '6300' (see 11.6.111.6.1) ), '63CX' (see 11.6.1), '6581', '6700', '6982',
```
#### 11.6.8 enable verification requirement command

#### Table 111 shows the enable verification requirement C-RP. The command switches on the

#### requirement to compare reference data with verification data. It can be performed only if the security

#### status satisfies the security attributes for this command.

#### Table 111 — enable verification requirement command-response pair

```
CLA As defined in 5.4.1
INS '28'
P1 '00' or '01' (any other value is RFU)
P2 See Table 102
Lc field Absent for encoding Nc = 0, present for encoding Nc > 0
```
```
Data field
```
```
P1 = '00' Verification data
P1 = '01' Absent
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2 See '6983', '6984', '6A81', '6A82', '6A86', '6A88' (see Table 6 and Table^7 when relevant, e.g. '6300' (see 11.6.111.6.1) ), '63CX' (see 11.6.1), '6581', '6700', '6982',
```
#### 11.6.9 disable verification requirement command


#### Table 112 — disable verification requirement command-response pair

```
CLA As defined in 5.4.1
INS '26'
P1 '00', '01' or 100xxxxx where xxxxx is a reference data number (any other value is RFU)
P2 See Table 102
Lc field Absent for encoding Nc = 0, present for encoding Nc > 0
```
```
Data field P1 = '00' or P1 = 100x xxxx Verification data
P1 = '01' Absent
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2 See '6983', '6984', '6A81', '6A82', '6A86', '6A88' (see Table 6 and Table^7 when relevant, e.g. '6300' (see 11.6.111.6.1) ), '63CX' (see 11.6.1), '6581', '6700', '6982',
```
#### Table 112 shows the disable verification requirement C-RP. The command switches off the

#### requirement to compare reference data with verification data, and possibly switches on the requirement

#### to compare other reference data with verification data. It can be performed only if the security status

#### satisfies the security attributes for this command.

#### 11.6.10 reset retry counter command

#### Table 113 shows the reset retry counter C-RP. The command either resets the reference data retry

#### counter to its initial value, or changes reference data on completion of a reset of the reference data

#### retry counter to its initial value. It can be performed only if the security status satisfies the security

#### attributes for this command.

#### Table 113 — reset retry counter command-response pair

```
CLA As defined in 5.4.1
INS '2C' or '2D'
P1 '00', '01', '02' or '03' (any other value is RFU)
P2 See Table 102
Lc field Absent for encoding Nc = 0, present for encoding Nc > 0
```
```
Data field
```
##### INS = '2C'

```
P1 = '03' Absent
P1 = '00' Resetting code followed without delimiter by new reference data
P1 = '01' Resetting code
P1 = '02' New reference data
```
##### INS = '2D'

```
P1 = '03' Absent
P1 = '00' Resetting code DO followed by a new reference data DO
P1 = '01' Resetting code DO
P1 = '02' New reference data DO
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2 See '6983', '6984', '6A81', '6A82', '6A86', '6A88' (see Table 6 and Table^7 when relevant, e.g. '6300' (see 11.6.111.6.1) ), '63CX' (see 11.6.1), '6581', '6700', '6982',
```

#### 11.6.11 manage security environment command

#### Table 114 shows the manage security environment C-RP. The command prepares secure messaging

#### (se e Clause 10 ) and security commands (e.g. external, internal and general authenticate, see also

#### perform security operation in ISO/IEC 7816-8). The command supports the following functions:

#### — set , i.e. setting or replacing one component of the current SE (see 10.3.3);

#### — store , i.e. saving the current SE under the SEID given in P2;

#### — restore , i.e. replacing the current SE by an SE stored in the card and identified by the SEID

#### given in P2;

#### — erase , i.e. erasing an SE stored in the card and identified by the SEID given in P2;

#### — reset , i.e. restoring the default SE after DF or application DF selection;

#### — get se, i.e. retrieving all control reference DOs pertaining to the current SE;

#### — get crt, i.e. retrieving one control reference template pertaining to the current SE.

#### key derivation function — The usage of a master key concept may require the derivation of a key in

#### the card containing the master key. Table 117 shows the usage of the manage security environment

#### command for deriving a key. It is assumed that the master key and the algorithm are implicitly selected

#### in the card (otherwise, the manage security environment command can additionally select a key and

#### an algorithm).

NOTE Depending on the algorithm reference, the data for deriving a key from a master key can be part of
the input data of the subsequent command (e.g. external authenticate). In this case the usage of the manage
security environment command for deriving the key is not necessary.

#### Table 114 — manage security environment command-response pair

```
CLA As defined in 5.4.1
INS '22'
P1 See Table 115
P2 See Table 116
Lc field Absent for encoding Nc = 0, present for encoding Nc > 0
Data field get, store, restore, erase, reset Absent
set Control reference DOs
```
```
Le field
```
```
set, store, restore, erase, reset Absent for encoding Ne = 0
get Present for encoding Ne > 0
```
```
Data field
```
```
get se Concatenation of control reference DOs
get crt One control reference template
other Absent
SW1-SW2 See Table 6 and Table 7 when relevant, e.g. '6600', '6987', '6988, '6A88' (see 11.6.1)
```

#### Table 115 — Coding of P1 in the manage security environment command

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
```
- - - 1 - - - - Secure messaging in command data field
- - 1 - - - - - Secure messaging in response data field
- 1 - - - - - - Computation, decipherment, internal authentication and key agreement
1 - - - - - - - Verification, encipherment, external authentication and key agreement
- - - - 0 0 0 1 set
1 1 1 1 0 0 1 0 store
1 1 1 1 0 0 1 1 restore
1 1 1 1 0 1 1 1 reset
1 1 1 1 0 1 0 0 erase
0 0 0 0 1 0 0 0 get crt
0 0 0 0 0 0 0 0 get se
NOTE Any other value is RFU.

#### Table 116 — Coding of P2 in the manage security environment command

```
Value Meaning
'XX' SEID with from interval ['01' .. 'FE'] without 'EF' (see 10.4.4) if P1 indicates store, restore or erase
'A4', 'A6',
'AA', 'B4',
'B6', 'B8'
```
```
Tag of CRT with the meaning from Table 55 present in the command data field
if P1 indicates set or get crt
'00' if P1 indicates get se or reset
NOTE Any other value is RFU.
```
#### Table 117 — Command-response pair for key derivation function

```
CLA As defined in 5.4.1
INS '22'
P1 'X1' ( set , see Table 115 )
P2 CRT tag (e.g. 'A4' if an fol low s) external authenticate follows, or 'B4' if a verify cryptographic checksum^
Lc field Present for encoding Nc > 0
Data field {'94' - L - Data for deriving a key (mandatory)}; SM DOs may be present
Le field Absent for encoding Ne = 0
```
```
Data field Absent
SW1-SW2See Table 6 and Table 7 when relevant, e.g. '6600', '6987', '6988, '6A88' (reference data not found)
```
### 11.7 Miscellaneous

#### 11.7.1 compare command

#### Table 118 shows the compare C-RP. The command initiates a comparison of comparison data with

#### reference data, which will be either the value of a primitive DO, or the contents of a record, or the

#### contents of a DataString. The reference data may be set by execution of select data command with a

#### general reference template or addressed by compare command with a general reference template (see

#### Table 94 ). The card shall interpret any individual element relevant for the comparison as a binary coded

#### number. When an interval is provided in the command or response data, the endpoints of that interval

#### shall have the same type as the data to which they are compared.


#### Table 118 — compare command-response pair

```
CLA As defined in 5.4.1
INS '33'
```
##### P1

```
'00' compare binary function, reference value is located in an EF supporting data units
'01' compare record function, reference value is located in an EF supporting record
'02 compare data function, reference value is located in a DO
other RFU
```
##### P2

```
Operation qualifier (for details see below)
'00' comparison defined by OID
'01' equal
'02' greater than
'03' less than
'04' not equal
'05' element of interval [lowerEndpoint, upperEndpoint]
'06' not element of interval [lowerEndpoint, upperEndpoint]
'07' the reference value shall belong to the set of finite values defined by the command
'08' the reference value shall not belong to the set of finite values defined by the command
['09' .. '7F'] RFU
['80' .. 'FF'] Proprietary
Lc field Present for encoding Nc > 0
```
```
Data field
```
```
DO'06' OID conditional, present if and only if P2='00'
```
```
Condition-
al choice
between
```
```
General reference template DO'60' as defined in Table 94.
DO'78' followed by a DO with a tag '70' to '72' or tags '74' to '77' (see 8.3.5), nesting
application defined DOs for referencing the target of the command.
Object locator DO'7F72' as defined Table 38
Wrapper DO'63' (see 8.4.8).
The data field optionally ends with comparison data encapsulated in DO'53' or DO'73'
Le field Absent for encoding Ne = 0, or present for encoding Ne > 0
```
```
Data field Absent or present (see below)
SW1-SW2 See Table 6 and Table 7 when relevant, e.g. '6282', '6340', '6982'
```
#### The comparison data shall be:

#### — either transmitted in the command data field,

#### — or known by the card.

#### By definition the reference value is the number coded in the reference data and the comparison value is

#### the number coded in the comparison data.

#### The function of the command (compare binary or compare record or compare data) shall be coded

#### in P1 set to the values '00', '01', '02' respectively.

#### The type of the operation is defined by P2 (operation qualifier):

#### — P2 = '00': the comparison function is defined by an OID DO'06' in the data field.

#### — P2 = '01': the comparison is successful if the reference value is equal to the comparison value.

#### — P2 = '02': the comparison is successful if the reference value is greater than the comparison value.

#### — P2 = '03': the comparison is successful if the reference value is less than the comparison value.


#### — P2 = '04': the comparison is successful if the reference value is not equal to the comparison value.

#### — P2 = '05': the comparison is successful if the reference value is within the closed interval defined by

#### the command.

#### — P2 = '06': the comparison is successful if the reference value is not within the closed interval defined

#### by the command.

#### — P2 = '07': the comparison is successful if the reference value is element of the finite set of values

#### defined by the command.

#### — P2 = '08': the comparison is successful if the reference value is not element of the finite set of values

#### defined by the command.

#### — P2 values from interval ['09' .. '7F'] are RFU.

#### — P2 values from interval ['80' .. 'FF'] are proprietary.

#### The result is indicated by the status bytes in the command response. SW1-SW2 set to '6340' indicates

#### that the comparison is unsuccessful.

#### If the comparison data is given in the command data field, then for P2 equals

#### — '01' or '02' or '03' or '04' the value shall be given in the value field of DO'53';

#### — '05' or '06' the closed interval shall be provided in the value field of DO'73'; in this case the DO'73'

#### shall contain nothing but two DOs'80'; the first DO'80' shall contain the lower endpoint of the

#### interval; the second DO'80' shall contain the upper endpoint of the interval;

#### — '07 or '08' the set shall be provided in the value field of DO'73'; in this case each value of the set shall

#### be given in the value field of a DO'53'.

#### When the command is successful, an optional response data field may be present when P2='05' or

#### '06'. When present, it shall be the concatenation of two DO'80' defining the endpoints of the closed

#### interval within which one element matches (P2='05') or within which no element matches (P2='06') the

#### comparison data.

#### 11.7.2 get attribute command

#### Table 119 shows the get attribute C-RP. The command get attribute retrieves one object attribute

#### of the referenced security object, if the access conditions for the respective operations are satisfied. The

#### respective security object shall be referenced by a data object locator in the data field of the command.

#### If an EF or a DO is referenced by the command an empty attribute reference is mandatory in the object

#### locator template. The respective attribute may be related to a dedicated security environment or to a

#### dedicated service provided by the referenced security object. The relevant attribute is retrieved as a

#### ber-tlv object in the data field of the response APDU.


#### Table 119 — get attribute command-response pair

```
CLA As defined in 5.4.1
INS '34' or '35'
P1-P2 '0000'
Lc field Present for encoding Nc > 0
```
```
Data field
```
```
INS = '34' Value field of object locator DO’7F72’ (see Table 38 )
INS = '35 Object locator DO'7F72' (see Table 38 )
Le field Present for encoding Ne > 0
```
```
Data field Attribute coded in ber-tlv
SW1-SW2 See Table 6 and Table 7 when relevant
```
### 11.8 Transmission handling

#### 11.8.1 get response command

#### Table 120 shows the get response C-RP. The command transmits (part of ) response APDUs (see 5.3.4).

#### Table 120 — get response command-response pair

```
CLA As defined in 5.4.1
INS 'C0'
P1-P2 '0000' (any other value is RFU)
Lc field Absent for encoding Nc = 0
Data field Absent
Le field Present for encoding Ne > 0
```
```
Data field Absent in any error case, or (part of) a response APDU according to Ne
SW1-SW2 See by a subsequent Table 6 and Tableget response^7 when relevant, e.g. '61XX' ('XX' encodes the number of extra bytes still available ), '6281', '6700', '6A81', '6A82', '6A86', '6CXX'
```
#### 11.8.2 envelope command

#### Table 121 shows the envelope C-RP. With INS = 'C2', the command, or a chain of such commands

#### transmits a payload which shall be a command APDU.

NOTE 1 The description from ISO/IEC 7816-4:1995 is moved to ISO/IEC 7816-3.

#### With INS= 'C3', the command, or a chain of such commands transmits a payload which shall be a DO.

#### Particular uses are:

#### — When the DO is DO'52' (command to perform), it has the same functionality as 'C2', except that the

#### response shall be a concatenation of DOs. If the response specified by the nested command is not, it

#### shall be nested in DO'53'.

#### — When the DO is DO'06' (object identifier), the success of the command (SW1-SW2 = '9000') means

#### that the card is ready to start a procedure defined by the document referenced by this object

#### identifier. This procedure, or script, shall comply with the standard APDU syntax. The end of the

#### procedure shall be defined in the procedure.

EXAMPLE 1 In order to use IP datagrams at the interface, the specification referred to by the OID defines the
encapsulation of those datagrams in command and response payloads.


EXAMPLE 2 In order to use at the interface the command syntax derived from the API defined by [ 1 ], the ber-
tlv marshalled requests and confirmations (payloads), also defined in [ 1 ], are encapsulated in the command
data fields of envelope C-RPs with INS= 'C3'.

NOTE 2 Annex B shows the usage of the envelope command for secure messaging.

#### Table 121 — envelope command-response pair

```
CLA As defined in 5.4.1
INS 'C2' or 'C3'
P1-P2 '0000' (any other value is RFU)
Lc field Present for encoding Nc > 0
Data field INS = 'C2' (Part of ) a command APDU
INS = 'C3' DO or DO fragment
Le field Absent for encoding Ne = 0, present for encoding Ne > 0
```
```
Data field (Part of) a response APDU (INS = 'C2'), or (parts of) DO'53' (INS = 'C3' with DO'52'), or absent
SW1-SW2 See Table 6 and Table 7 when relevant, e.g. '6700'
```
## 12 Application-independent card services

### 12.1 General

#### The purpose of card services is to provide interchange mechanisms between a card and an interface

#### device knowing nothing about each other except that they both comply with this document. Card

#### services result from any combination of historical bytes (see 12.2.2), the contents of EF.DIR and EF .ATR/

#### INFO (see 12.3.2 and 12.3.3) and sequences of commands. Unless otherwise specified, every command

#### APDU uses CLA set to '00', i.e. no command chaining, no secure messaging and the basic logical channel.

#### There is no need for an application to comply with this clause once it has been identified and selected

#### in the card. An application may use other mechanisms compatible with this document for achieving

#### similar functions. Therefore such solutions may not guarantee interchange.

#### Interindustry information may also be recovered by the commands sent on additional logical channels

#### than the basic logical channel. Furthermore in such commands any Ne may be used. This statement is

#### related to the paragraph before as well as the information retrieval in 12.2.2.1, 12.2.3, 12.3.2, 12.3.3

#### and 12.5.

### 12.2 Card identification

#### 12.2.1 General................................................................................................................................................................................

#### This service allows the interface device to identify the card and to deal with it. The historical bytes (see

#### 12.2.2) provide a generic support to card identification. The card provides information to the outside

#### world on its logical content directly, e.g. through the card service data byte (see Table 124 ), and/or

#### indirectly, e.g. through the initial access data (see 12.2.2.6) indicating an access to a file implicitly

#### selected immediately after enabling a physical interface (see 5.1). Consequently, the data available at

#### this point, i.e. the initial data string (see 12.2.3), may not be subsequently retrievable. The waiting time

#### management provides the information regarding application waiting time to the outside world (see

#### 12.2.4).


#### 12.2.2 Historical bytes

#### 12.2.2.1 Purpose and retrieval

#### The historical bytes (string of up to 15 bytes, as defined in ISO/IEC 7816-3) indicate operating

#### characteristics of the card. When a card answers to reset, the Answer-to-Reset may contain

#### historical bytes.

#### When the physical interface does not allow a card to answer to reset, e.g. if it is accessed by Universal

#### Serial Bus or by radio frequency, the get data command (see 11.5.3) may retrieve:

#### — historical bytes as the value of DO'5F52'. The command APDU is: '00CA 5F52 0F'. For practical use,

#### DO'5F52' should belong to the template referenced by curConstructedDO after enabling a physical

#### interface (see 5.1).

#### — the Answer-To-Reset as the value of DO'5F51'. The command APDU is: '00CA 5F51 20'. For practical

#### use, DO'5F51' should belong to the template referenced by curConstructedDO after enabling a

#### physical interface (see 5.1).

#### 12.2.2.2 Structure and compact-tlv data objects

#### The first historical byte is the “category indicator byte”. If the category indicator byte is set to '00'

#### or '8X', then Table 122 summarizes the format of the historical bytes. Any other value indicates a

#### proprietary format.

#### If the first historical byte is set to:

#### — '00' the remaining historical bytes shall consist of optional consecutive compact-tlv data objects

#### followed by a mandatory status indicator (see 12.2.2.11);

#### — '80' the remaining historical bytes shall consist of optional consecutive compact-tlv data objects;

#### the last one may carry a status indicator in compact-tlv format (see 12.2.2.11).

#### Any interindustry DO consisting of a tag field set to '4X', a length field set to '0Y' and a value field of Y

#### bytes can be converted into a compact-tlv data object consisting of a byte set to 'XY' called “compact

#### header” and a value field of Y bytes.

#### Any interindustry data element defined hereafter (see 12.2.2.3 to 12.2.2.10) may be present in EF .ATR/

#### INFO (see 12.3.3). If present in EF .ATR/ INFO, it shall appear in a DO, i.e. a tag field set to '4X', a length

#### field set to '0Y' and a value field of Y bytes.

#### Table 122 — Category indicator byte

```
Value Meaning
'00' A status indicator shall be present as the last three historical bytes (see 12.2.2.11)
'80' A status indicator may be present in a compact-tlv data object (one, two or three bytes, see 12.2.2.11)
'81' to
'8F'
```
##### RFU

```
NOTE 1 Any other value indicates a proprietary format.
NOTE 2 ISO/IEC 7816-4:2005 defined another category indicator byte ‘01’ with a coding and meaning outside the scope of
this document. In this document this value is part of the proprietary format.
```
#### 12.2.2.3 Country or issuer indicator

#### Referenced by a compact header set to either '1Y' or '2Y', this interindustry data element is a country or

#### issuer indicator (see also tags '41' and '42' in Table 17 ). Table 123 shows the country or issuer indicator.


#### Table 123 — Country or issuer indicator

```
Compact header Value
'1Y' Country code (see ISO 3166-1[2]) and optional national data
'2Y' Issuer identification number (see ISO/IEC 7812-1[3]) and optional issuer data
```
#### A country indicator consists of a country code (three quartets with values from '0' to '9', see

#### ISO 3166-1[2]) followed by subsequent data (at least one quartet). The relevant national standardization

#### body shall choose those subsequent data (odd number of quartets).

#### An issuer indicator consists of an issuer identification number (see ISO/IEC 7812-1[3]) possibly followed

#### by subsequent data. The card issuer shall choose those subsequent bytes if any (for encoding, e.g. a

#### Primary Account Number).

NOTE In ISO/IEC 7812-1, an issuer identification number can consist of an odd number of quartets with a
value from '0' to '9'. Then it was mapped into a byte string by setting bits b4 to b1 of the last byte to 1111.

#### 12.2.2.4 Application identifier

#### Referenced by a compact header set to 'FY', this interindustry data element is an application identifier

#### (AID, see 12.3.4, see also tag '4F' in Table 17 ). If present in the historical bytes or in the initial data

#### string (see 12.2.3), an AID denotes an implicitly selected application (see 12.3.6.2).

#### 12.2.2.5 Card service data

#### Referenced by a compact header set to '31', this interindustry data element indicates methods available

#### in the card for supporting services described in this clause. Table 124 shows the card service data byte.

#### If present in the historical bytes or in the initial data string (see 12.2.3), the card service data byte

#### indicates whether EF.DIR and/or EF .ATR/ INFO (see 12.3.2 and 12.3.3) are present or not, and how to

#### access them. The absence of card service data byte in the historical bytes and in the initial data string

#### indicates that the card supports only the implicit application selection (default value).

#### Table 124 — Coding of the card service data byte

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
x x - - - - - - Application selection
1 - - - - - - - — by full DF name
```
- 1 - - - - - - — by partial DF name
- - x x - - - - **DOs available**
- - 1 - - - - - — in EF.DIR (see 12.3.2)
- - - 1 - - - - — in EF .ATR/ INFO (see 12.3.3)
- - - - x x x - **EF.DIR and EF .ATR/ INFO access services**
- - - - 1 0 0 - — by the read binary command (transparent structure)
- - - - 0 0 0 - — by the read record (s) command (record structure)
- - - - 0 1 0 - — by the get data command ( ber-tlv s t r uc t u r e)
- - - - any other value - RFU
- - - - - - - 0 **Card with MF**
- - - - - - - 1 **Card without MF**

#### 12.2.2.6 Initial access data

#### Referenced by a compact header set to '4Y', this interindustry data element indicates a command APDU

#### assumed to be the first command after enabling a physical interface (see 5.1). The command APDU is

#### specified in 12.2.3.


#### 12.2.2.7 Card issuer's data

#### Referenced by a compact header set to '5Y', this interindustry data element is not defined in

#### ISO/IEC 7816 (all parts)[4]. The card issuer defines a length, a structure and a coding.

#### 12.2.2.8 Pre-issuing data

#### Referenced by a compact header set to '6Y', this interindustry data element is not defined in

#### ISO/IEC 7816 [4]. The card manufacturer defines a length, a structure and a coding for a card

#### manufacturer, an integrated circuit name, an integrated circuit manufacturer, a ROM mask version,

#### an operating system version, etc. This interindustry data element may contain an integrated circuit

#### manufacturer identifier (see ISO/IEC 7816-6).

#### 12.2.2.9 Card capabilities

#### Referenced by a compact header set to '71', '72' or '73', this interindustry data element consists of up to

#### three software function tables. If the length of the data element is

#### — one byte, then the data element shall consist of the first software function table (see Table 125 );

#### — two bytes, then the data element shall consist of the first software function table as first byte (see

#### Table 125 ) and the second software function table as second byte (see Table 126 );

#### — three bytes, then the data element shall consist of the first software function table as first byte

#### (se e Table 125 ), the second software function table as second byte (see Table 126 ) and the third

#### software function table as third byte (see Table 127 ).

#### Content of the software function tables:

#### — The first software function table indicates selection methods supported by the card.

#### — The second software function table is the “data coding byte”. The data coding byte may also be

#### present as the second byte in the file CP referenced by tag '82' (see Table 11 ).

#### — The third software function table indicates the ability to chain commands, to handle extended Lc

#### and Le fields and to manage logical channels.

#### Table 125 — Coding of the first software function table (selection methods)

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
x x x x x - - - DF selection (see 7.3)
1 - - - - - - - — by full DF name
```
- 1 - - - - - - — by partial DF name
- - 1 - - - - - — by path
- - - 1 - - - - — by file identifier
- - - - 1 - - - Implicit DF selection
- - - - - 1 - - Short EF identifier supported
- - - - - - 1 - Record number supported
- - - - - - - 1 Record identifier supported


#### Table 126 — Coding of the second software function table (data coding byte)

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
1 - - - - - - - EFs of ber-tlv structure supported
```
- x x - - - - - **Behaviour of write functions**
- 0 0 - - - - - — One-time write
- 0 1 - - - - - — Proprietary
- 1 0 - - - - - — Write OR
- 1 1 - - - - - — Write AND
- - - - x x x x **Data unit size in quartets** (power of 2, e.g. 0001 = 2 quartets = one byte, default value) (from one to 32 768 quartets, i.e. 16 384 bytes)^
- - - x - - - - **Value 'FF' for the first byte of ber-tlv tag fields** (see 8.1.2)
- - - 0 - - - - — Invalid (used for padding, default value)
- - - 1 - - - - — Valid (long private tags, constructed encoding)

#### Table 127 — Coding of the third software function table

#### (command chaining, length fields and logical channels)

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
1 - - - - - - - Command chaining (see 5.3.3)
```
- 1 - - - - - - **Extended Lc and Le fields (see 5.1)**
- - 1 - - - - - **Extended Length Information in EF .ATR/ INFO**
- - - x x - - - **Logical channel number assignment (see 5.4.2 and 11.2)**
- - - 1 - - - — by the card
- - - 1 - - - — by the interface device
- - - 0 0 - - - Only basic logical channel available
    **Maximum number of logical channels (see 5.4.1)**
- - - - - y z t — y, z and t not all set to 1 means 4y+2z+t+1, i.e. from one to seven
    — y = z = t = 1 means eight or more

#### 12.2.2.10 Application Family Identifier

#### Referenced by a compact header set to '91', this interindustry data element consists of one byte defined

#### in ISO/IEC 14443-3[14].

#### 12.2.2.11 Status indicator

#### If the category indicator byte is set to '00', then the last three historical bytes shall be a status indicator,

#### namely a card LCS (1 byte) followed by two processing status bytes denoted SW1-SW2.

#### If the category indicator byte is set to '80', then an interindustry data element referenced by a compact

#### header set to '81', '82' or '83' may be present as a status indicator on one, two or three bytes (any other

#### length is RFU) at the end of the historical bytes.

#### — If the length is one, then the data element is a card LCS.

#### — If the length is two, then the data element is SW1-SW2.

#### — If the length is three, then the data element is LCS followed by SW1-SW2.

#### LCS shall be interpreted according to 7. 4 .10 and Table 15 ; the value '00' indicates that the status is not

#### reported. SW1-SW2 shall be interpreted according to 5.6, Table 6 and Table 7 ; the value '0000' indicates

#### that the status is not reported.


#### 12.2.3 Initial data string recovery

#### Referenced by a compact header set to '4Y' in the historical bytes (see 12.2.2) or by tag '44' in EF .ATR/

#### INFO (see 12.3.3), the interindustry data element called “initial access data” indicates a command APDU.

#### — If the length is one, then the command APDU is a read binary command (see 11.3.3) as follows: CLA

#### INS P1 P2 set to '00B0 0000' and an Le field set to the first and only byte of initial access data.

#### — If the length is two, then the first byte of initial access data indicates the structure (bit b8) and the

#### short EF identifier (bits b5 to b1) of the EF to read, according to Table 128.

#### — If bit b8 of the first byte is set to 1, then the command APDU is a read binary command (see

#### 11.3.3) as follows: CLA INS set to '00B0'. If the bits b5 to b1 are set to 00000 then P1 shall be set

#### to '00' otherwise P1 shall be set to the first byte of initial access data, P2 set to '00' and an Le

#### field set to the second byte of initial access data.

#### — If bit b8 of the first byte is set to 0, then the command APDU is a read record (s) command (see

#### 11.4.3) as follows: CLA INS P1 set to '00B2 01', P2 consisting of bits b8 to b4 set to bits b5 to b1 of

#### the first byte of initial access data (indicating an EF referenced by curEF or a short EF identifier)

#### and bits b3 to b1 set to 110, and an Le field set to the second byte of initial access data.

#### — If the length is five or more, then the command APDU consists of the Y bytes of initial access data.

#### The command APDU shall be submitted to the card. If the process is completed, then the response data

#### field is a string of interindustry DOs every application might be interested in, called the “initial data

#### string”.

#### Table 128 — Coding of the first byte of initial access data when the length is two

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
x - - - - - - - EF structure
0 - - - - - - - Record structure
1 - - - - - - - Transparent structure
```
- x x - - - - - 00 (any other value is RFU)
- - - 0 0 0 0 0 Current EF
- - - not all equal Short EF identifier

#### 12.2.4 Waiting time management

#### 12.2.4.1 General

#### The waiting time management service provides the information regarding application waiting time

#### depending on respective cases, e.g. each command, each operation, and each amount of data. By using

#### this information, an application on an IFD detects an unresponsive ICC without any negotiation, as an

#### alternative to using a single waiting time defined on a transmission protocol (See ISO/IEC 7816-3 and

#### ISO/IEC 14443-4).

#### The application waiting time is the maximum delay between the leading edge of a character transmitted

#### by an ICC and the leading edge of the previous character transmitted by an IFD.

#### This information is available under application waiting time management information DO‘7F75‘ in

#### the EF .ATR/INFO and/or in the FCI of any application DF. Table 129 indicates four formats for this

#### information.

#### The rationale for handling the waiting time defined in ISO/IEC 7816-3 in correlation with the execution

#### time information by an application on an IFD is out of the scope of this document. Annex I shows an

#### example of waiting time extension procedure defined in ISO/IEC 7816-3 and application waiting time

#### procedure defined in 12.2.4.


#### Table 129 — Application waiting time data objects under application waiting time management

#### information DO‘7F75‘

```
Tag Length Value
‘81‘ Va r. Application waiting time management information in compact format
‘A 1‘ Va r. Application waiting time management data elements in expanded format
‘82‘ Va r. Application waiting time management information in proprietary format
‘A 2 ‘ Va r. Application waiting time management data elements in proprietary format
```
#### 12.2.4.2 Compact format

#### In compact format, an application waiting time management information consists of a command

#### indicator field followed by a concatenation of 2-byte application waiting time management factors. Each

#### bit of bits b7 to b1 indicates whether the application waiting time management factor for each command

#### is present, i.e. a bit as 1 means present and a bit as 0 means absent. shows the first byte of command

#### indicator. Subsequent bytes of command indicator are RFU.

#### An application waiting time management factor consists of 1-byte base time and 1-byte unit time. The

#### maximum application waiting time is derived from base time plus result of multiplying unit time by

#### data length of command processing (see arithmetic expression below). A base time is the part of each

#### command execution time independent from data length of command processing. A unit time is 1 byte

#### data processing time for each command, e.g. reading 1 byte data, updating 1 byte data, or verifying 1

#### byte data.

#### T max = T b + (T u × L d )

#### where

#### T max is maximum application waiting time [ms];

#### T b is base time [ms];

#### T u is unit time [ms/B];

#### L d is data length [B].

#### Table 130 — Coding of the first byte of command indicator

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
x - - - - - - - Presence of next command indicator
0 - - - - - - - Last command indicator byte
1 - - - - - - - Next command indicator byte available
```
- x x x x x x x Presence of application waiting time management factor for each
    command
- 1 - - - - - - read binary
- - 1 - - - - - update binary
- - - 1 - - - - read record (s)
- - - - 1 - - - update record
- - - - - x x x RFU

#### 12.2.4.3 Expanded format

#### In expanded format, an application waiting time management information consists of a concatenation

#### of a command header description DO‘81‘ followed by an application waiting time management factor

#### DO’A0‘. A value field of a command header description DO‘81‘ is composed of a mandatory command


#### header description byte followed by an optional CLA byte, INS byte, P1 byte and P2 byte depending on

#### the value of the command header description byte. Table 131 shows the command header description

#### byte (the first byte of the value field of DO‘81‘).

#### Table 131 — Coding of command header description byte

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 0 0 0 x x x x The command header description includes
0 0 0 0 1 - - - — (CLA), i.e. the value of CLA
0 0 0 0 - 1 - - — (INS), i.e. the value of INS
0 0 0 0 - - 1 - — (P1), i.e. the value of P1
0 0 0 0 - - - 1 — (P2), i.e. the value of P2
The value of CLA shall encode zero as the number for logical channel with the meaning that the description is independent
from logical channels.
NOTE Any other value is RFU.
```
#### Table 132 lists application waiting time management factor DOs with context-specific class tag. Each

#### application waiting time management factor is associated to the specific arithmetic expression. Two

#### application waiting management factor DOs associated to one arithmetic expression (see 12.2.4.2) are

#### provided.

#### Table 132 — Waiting time management factor DOs

```
Tag Length Value
‘80‘ Va r. Base time
‘81‘ Va r. Unit time
```
### 12.3 Application identification and selection

#### 12.3.1 General................................................................................................................................................................................

#### This service allows the interface device to know what applications are supported by the card, if any, as

#### well as how to identify and select them.

#### Two specific EFs provide a generic support to application identification and selection, namely EF.DIR

#### and EF .ATR/ INFO. They contain a set of DOs. In these EFs, erased or modified DOs may induce padding

#### before, between and after DOs (see 8.1.2) in the response data fields of read binary/record(s)

#### commands.

#### 12.3.2 EF.DIR

#### This EF indicates a list of applications supported by the card. It contains a set of application templates

#### (se e 12.3.5) and/or application identifier DOs (see 12.3.4), in any order. It determines which commands

#### shall be performed in order to select the indicated applications.

#### If an MF and an EF.DIR are present, EF.DIR shall have the MF as parent file and its path shall be

#### '3F002F00'. At MF level, the short EF identifier 30, i.e. 11110 in binary, references EF.DIR.

#### If an MF is not present, EF.DIR may be present and should be addressable by file identifier '2F00' after

#### enabling a physical interface (see 5.1).

NOTE The command (sequence) for retrieving the content depends on the structure of EF.DIR (e.g. see
Table 124 ) and can be known implicitly by an application in the outside world.

#### If EF.DIR supports DO handling, or if its contents are not stored in a file, a card may provide its contents

#### by the get data command (see 11.5.3) The response data to the command '00CB 2F00 02 5C00 00' is the

#### concatenation of all DOs which are present in EF.DIR, or would be present if EF.DIR does not actually exist.


#### If the card provides this service, the command should be successful at least immediately after enabling

#### a physical interface (see 5.1).

#### 12.3.3 EF .ATR/ INFO

#### This EF indicates operating characteristics of the card. It contains a set of interindustry DOs which cannot

#### be nested in EF.DIR, either because not relevant to application selection, or because there is no EF.DIR.

NOTE 1 EF .ATR/ INFO was called EF.ATR in the 2nd edition of this document. As some contactless cards do not
provide an ATR, this terminology was misleading in the contactless card world. The new terminology EF .ATR/
INFO is recommended. It can still be called EF.ATR in contact card standards or specifications, and can now be
called EF.INFO in contactless card standards and specifications.

#### If an MF and an EF .ATR/ INFO are present, EF .ATR/ INFO shall have the MF as parent file and its path

#### shall be '3F002F01'.

#### If an MF is not present, an EF .ATR/ INFO may be located within an application with its application DF as

#### parent. Its file identifier shall be '2F01', unless defined otherwise by the application.

NOTE 2 The command (sequence) for retrieving the content depends on the structure of EF .ATR/ INFO (e.g.
see Table 124 ) and can be known implicitly by an application in the outside world.

#### If EF .ATR/ INFO supports DO handling, or if its contents are not stored in a file, a card may

#### provide its contents by the get data command (see 11.5.3). The response data to the command

#### '00CB 2F01 02 5C00 00' is the concatenation of all DOs which are present in EF .ATR/ INFO, or would be

#### present if EF .ATR/ INFO does not actually exist.

#### If the card provides this service, the command should be successful at least immediately after enabling

#### a physical interface (see 5.1).

NOTE 3 Information presented in an ATR at interface enabling can supersede information from EF .ATR/ INFO,
if present.

#### 12.3.4 Application identifier

#### Referenced by a compact header set to 'FY' in the historical bytes (see 12.2.2.4), or by tag '4F' in the

#### initial data string (see 12.2.3), in EF .ATR/ INFO, in EF.DIR and in the management data of any DF (see

#### 7. 4), this interindustry data element identifies an application.

#### An application identifier (AID) consists of up to sixteen bytes. Bits b8 to b5 of the first byte indicate a

#### category according to Table 133.

#### Table 133 — Categories of application identifiers

```
Value Category Meaning
'0' to '9' - Reserved for backward compatibility with ISO/IEC 7812-1[3] (see Annex D)
'A' International International registration of application providers according to ISO/IEC 7816-5
'B', 'C' - RFU
'D' National National (ISO 3166-1[2]) registration of application providers according to
I S O/ IEC 7816 -5
'E' Standard Identification of a standard by an object identifier according to ISO/IEC 8825-1
'F' Proprietary No registration of application providers
```
#### Fig ure 11 shows an international AID. It consists of a registered application provider identifier

#### (international RID) on five bytes and optionally, a proprietary application identifier extension (PIX) on

#### up to eleven bytes.

#### — The international RID shall uniquely identify an application provider (see ISO/IEC 7816-5).

#### — Bits b8 to b5 of the first byte shall be set to 1010, i.e. the first quartet shall be set to 'A'.


#### — Each one of the subsequent nine quartets shall be set from '0' to '9'.

#### — The extension has a free encoding. It allows the application provider to identify its different

#### applications.

#### Figure 11 — International AID

#### Figure 12 shows a national AID. It consists of a registered application provider identifier (national RID)

#### on five bytes and optionally, a proprietary application identifier extension (PIX) on up to eleven bytes.

#### — The national RID shall uniquely identify an application provider (see ISO/IEC 7816-5).

#### — Bits b8 to b5 of the first byte shall be set to 1101, i.e. the first quartet shall be set to 'D'.

#### — The subsequent three quartets (from '0' to '9') shall form a country code (see ISO 3166-1[2]).

#### — The recommended value of each one of the last six quartets is from '0' to '9'.

#### — The extension has a free encoding. It allows the application provider to identify its different

#### applications.

#### Figure 12 — National AID

#### Figure 13 shows a standard AID. It consists of up to sixteen bytes. The first byte shall be set to 1110

#### 1000, i.e. to 'E8'. The values 'E0' to 'E7' and 'E9' to 'EF' are RFU. An object identifier (see ISO/IEC 8825-1)

#### shall follow for identifying a standard specifying an application (see examples in Annex A, e.g.

#### ISO/IEC 7816-11, personal verification through biometric methods, ISO/IEC 7816-15, cryptographic

#### information application). An application identifier extension (specified according to the identified

#### standard) may follow for identifying different implementations.

#### Figure 13 — Standard AID

#### F ig u r e 14 shows a proprietary AID. It consists of up to sixteen bytes. Bits b8 to b5 of the first byte

#### shall be set to 1111, i.e. to 'F'. In the proprietary category, as application providers are not registered,

#### different application providers may use the same AID.

#### Figure 14 — Proprietary AID

#### WARNING — An AID being shorter than five bytes conforms to this document. Some

#### implementations may require AIDs to be at least five bytes long. This should be taken into

#### account when assigning an AID.


#### 12.3.5 Application template and related data elements

#### Referenced by tag '61', this interindustry template may be present in EF .ATR/ INFO (see 12.3.3), in

#### EF.DIR (see 12.3.2) and in the management data of any DF (see 7. 4).

#### — Such a template shall contain one and only one application identifier. If several application identifiers

#### are valid names for the same DF, then each one should be present in a different application template.

#### — Such a template may optionally contain other interindustry DOs relating to the application as listed

#### in Table 134 and defined hereafter.

#### Table 134 — Interindustry DOs for application identification and selection

```
Tag Value
'4F' Application identifier
'50' Application label
'51' File reference
'52' Command APDU
'53', '73'Discretionary data, discretionary template
'5F50' Uniform resource locator (see IETF RFC 1738[23] and IETF RFC 2396[24])
'61' Set of application-related DOs
'79' This DO indicates a coexistent tag allocation scheme
```
#### The following interindustry data elements provide a generic support to application identification and

#### selection.

#### Application label — Referenced by tag '50', this interindustry data element is not defined in

#### ISO/IEC 7816 (all parts)[4]. The application provider defines it for use at the man-machine interface, e.g.

#### a trademark to display.

#### File reference — Referenced by tag '51' (see 7. 3. 2)

#### Discretionary data (or template) — Referenced by tag '53' (or '73'), this interindustry data element

#### (or template) consists of relevant data elements (or nests DOs) defined by the application provider.

#### Uniform resource locator — Referenced by tag '5F50', this interindustry data element is a uniform

#### resource locator (URL) as defined in IETF RFC 1738[23] and IETF RFC 2396 [24]. It points to part of the

#### software required in the interface device to communicate with the application in the card.

#### 12.3.6 Application selection

#### 12.3.6.1 General

#### The card shall support at least one of the following application selection methods.

#### 1) Implicit application selection

#### 2) Application selection using an application identifier (AID, see 12.3.4 ) as DF name

#### 3) Application selection using EF.DIR or EF .ATR/ INFO

#### 12.3.6.2 Implicit application selection

#### If an application is implicitly selected as a consequence of enabling a physical interface, then an

#### application identifier should be present in the historical bytes (see 12.2.2) or in the initial data string

#### (se e 12.2.3). Such a presence denotes an implicitly selected application. If an application is implicitly

#### selected with no application identifier in the historical bytes and in the initial data string, then an

#### application identifier shall be present in EF .ATR/ INFO (see 12.3.3).


#### 12.3.6.3 Application selection using AID as DF name

#### A multi-application card shall support the select command with P1='04', P2='00' and a data field

#### containing 5 to 16 bytes with the AID of an application that may reside on the card. The command shall

#### complete successfully if the AID of an application the card holds matches the data field.

#### If the card capabilities (see 12.2.2.9 and Table 125 ) specify the card supports selection by truncated

#### AID it shall support the select command with P1='04', P2='00' or '02'. In this case the command shall

#### complete successfully if the first part of the AID of any application it holds matches the data field. If

#### multiple AIDs in the card match the input data, the order in which each of these applications is actually

#### selected after completion of the command is implementation-dependent. If the command completes

#### successfully with a partial match of the AID it shall return the full AID of the selected application in the

#### file control or management data (as DO'84' or DO'4F').

#### The card may support a mechanism for an application to specify a requirement for a full match of the

#### AID in order to be successfully selected. The select command shall fail if the application AID matches a

#### truncated AID as the only selectable application in the card, or ignore the application if other application

#### AIDs match and can be selected.

NOTE The order in which applications in the card are selected by consecutive select commands with
P1='02' can be static or dynamic, e.g. based on which application was selected most recently in a previous session.

#### In a multi-application card an application in the card shall be identified by

#### — a single AID in the proprietary, national or international category, and/or

#### — one or more AIDs in the standard category.

#### If the application is selected by specifying an AID in the standard category, the AID returned by the

#### select command is the AID in the proprietary, national or international category, if such an AID is

#### specified for the application.

#### 12.3.6.4 Application selection using EF.DIR or EF .ATR/ INFO

#### For a multi-application interface device, the use of EF.DIR or EF .ATR/ INFO may be more efficient than

#### the previous method.

#### — If an application identifier DO is not part of an application template and not accompanied by a file

#### reference or command-to-perform DO, then the selection shall use AID as DF name.

#### — If an application identifier DO is part of an application template together with a file reference DO

#### (se e 7. 3. 2), the value field of which consists of two or more bytes, then the selection by path shall be

#### performed according to 12.4.

#### — If an application identifier DO is part of an application template together with one or more command-

#### to-perform DOs, then the application selection is done by the indicated command(s). If several, they

#### shall be performed in the order presented in the template.

### 12.4 Selection by path

#### This service allows selection of EFs and DFs having file identifiers by using a path, i.e. a file reference

#### DO (see 7. 3. 2) consisting of three or more bytes.

#### — When the length is even, the path is either absolute or relative depending on whether the first two

#### bytes are set to '3F00' or not. The last two bytes identify either a DF or an EF.

#### — For a path to a DF, the selection should be done by one or more select commands, with CLA INS

#### P1 P2 Lc set to '00A4 0100 02'.

#### — For a path to an EF, if the length is four or more, the selection should be done by one or more

#### select commands, with CLA INS P1 P2 Lc set to '00A4 0100 02'. The last and possibly only


#### selection uses the last two bytes of the path (an EF identifier) with CLA INS P1 P2 Lc set to '00A4

#### 0200 02'.

#### — When the length is odd, the path is qualified. It consists of either an absolute path without '3F00', or

#### a relative path without the identifier of the DF referenced by curDF, followed by a byte to use as P1

#### in one or more select commands. The value of P1 fixes the selection method.

#### — If the value of P1 is '08' or '09', then the card shall support a select command where the qualified

#### path specifies P1, Lc and the data field and where P2 is set to '00'.

#### — In the other cases, the card shall support one or more select commands with P1 set to the

#### last byte of the qualified path and P2 Lc set to '0002'. Every file along the path shall be selected

#### sequentially.

### 12.5 Data retrieval

#### This service allows the interface device to retrieve interindustry data elements used for interchange.

#### Interindustry DOs should be retrieved directly or indirectly from the Answe-To-Reset or the historical

#### bytes (see 12.2.2), the initial data string (see 12.2.3), EF .ATR/ INFO (see 12.3.3) and EF.DIR (see 12.3.2),

#### in that order, when present. These interindustry DOs shall be interpreted according to tag allocation

#### schemes (see 8.3). Standards are entitled to recommend or mandate retrieval of interindustry DOs by

#### get data (se e 11.5.3).

### 12.6 Card-originated byte string

#### 12.6.1 General................................................................................................................................................................................

#### This service allows the card to originate byte strings. For clarity, this clause defines a query as (part

#### of) a card-originated byte string and a reply as (part of) a response byte string sent by an entity in the

#### outside world; for example, a complete set of queries may form a command APDU and a complete set of

#### replies a response APDU, thus allowing communication service from card to interface device and also,

#### from card to card, possibly through a network.

#### This clause specifies the following three features.

#### — How the card shall use SW1-SW2 as a trigger indicating that the card wants to issue a query, for

#### which the card possibly expects a reply.

#### — How the interface device shall use the get data command with even INS code (see 11.5.3) for

#### retrieving a query from the card and the put data command with even INS code (see 11.5.6) for

#### transmitting a reply, if any, to the card. Such get data and put data commands shall set P1-P2 to

#### '0000' (see Table 93 ).

#### — How queries and replies shall be formatted.

#### 12.6.2 Triggering by the card

#### SW1-SW2 set to '62XX' with the value of 'XX' from '02' to '80' means that the card has a query of 'XX'

#### bytes that the interface device should retrieve and for which the card possibly expects a reply.

#### SW1-SW2 set to '64XX' with the value of 'XX' from '02' to '80' means that the card aborted the command;

#### a possible completion of the command is conditioned by the recovery of a query of 'XX' bytes, for which

#### the card possibly expects a reply.

#### If present in the historical bytes with a value such as above, SW1-SW2 shall be interpreted as above.

#### If a put data command (see 12.6.2, dash 2) for transmitting a reply is aborted with SW1-SW2 set to

#### '64XX', then

#### — with '64XX' from '6402' to '6480', the card wants to send at least one more query of 'XX' bytes;


#### — with '64XX' set to '6401', the card is expecting an immediate reply.

#### 12.6.3 Queries and replies

#### For retrieving a query of 'XX' bytes available in the card, the interface device shall send a get data

#### command with INS set to 'CA', P1-P2 set to '0000' and an Le field set to 'XX'.

#### — SW1-SW2 set to '62XX' with the value of 'XX' from '02' to '80' means that the interface device should

#### retrieve a further query of 'XX' bytes and concatenate it to the already retrieved query before

#### processing the card-originated byte string in the outside world.

#### — SW1-SW2 set to '9000' means that the card-originated byte string is complete; it may be processed

#### in the outside world.

#### For transmitting a reply to the card, the interface device shall send a put data command with INS set

#### to 'DA', and P1-P2 set to '0000'. If the response byte string is too long for a single command, then several

#### put data commands shall be chained (see 5.3.3). Each put data command transmits a reply and the

#### concatenation of the replies is the response byte string.

#### 12.6.4 Formats

#### The value of the first byte of the card-originated byte string indicates a format as follows.

#### — If the first byte is set to 'FF', then the subsequent bytes shall encode an initial protocol identifier

#### according to ISO/IEC TR 9577[5]; the byte strings shall comply with the indicated protocol.

#### — Otherwise (i.e. when the first byte is not set to 'FF'), the card-originated byte string and the response

#### together shall form a C-RP.

#### All conditions are relevant to the transmission protocol indicated by the card, except for the proper

#### use of get data command, put data command and status bytes SW1-SW2. This clause makes no

#### assumption on the need for a response and on the entity responsible for the contents of the possible

#### response.

### 12.7 General feature management

#### 12.7.1 General................................................................................................................................................................................

#### This service allows the card to inform the external world about existing features on the card in a

#### generic way. A template (DO'7F74') which is possibly extendable in the future by adding additional sub-

#### templates is located in the card, e.g. in the EF .ATR/ INFO (see 12.3.3) and/or in the FCI of any application

#### DF. In general the information may apply to all applications. Values specified in application FCI apply

#### to that application only, possibly superseding values specified in the EF .ATR/ INFO. EF .ATR/ INFO or an

#### application FCI shall not contain more than one instance of DO'7F74'. The information may be retrieved

#### by reading EF .ATR/ INFO or in the response data field of a command selecting an application.

#### This service supports the retrieval of condensed information about installed features and applications.

#### An interface device may retrieve additional information about installed features and applications as

#### defined by other standards.

#### 12.7.2 On-card services

#### This service allows the card to inform the external world about existing on-card features. Nested in the

#### feature management template this sub-template consists of a sequence of consecutive octets of bits.

#### Each bit indicates an on-card feature/mechanism. A set bit indicates the existence of this feature on the

#### card. Table 135 shows already predefined on-card services.


#### 12.7.3 Interface services

#### International standards define a great variety of interfaces which might be active in parallel. The

#### communication mechanisms of each protocol do not offer any possibilities to indicate the existence and

#### the parallel usage of multi interfaces. This sub-template in the feature management template offers the

#### information about existing protocols and the way of communication handling (see Table 135 ).

#### Table 135 — Template for general features management DO'7F74'

```
Tag Length Meaning
'81' Va r. Sub-template identifier for on-card services
Feature-list [0..n], expandable
b8 b7 b6 b5 b4 b3 b2 b1 Meaning of bits in the first byte
1 - - - - - - - Display
```
- 1 - - - - - - Biometric Input Sensor
- - x x x x x x 000000 (any other value is RFU)
'82' Va r. Sub-template identifier for interface services
Communication feature-list [0..n], expandable
**b8 b7 b6 b5 b4 b3 b2 b1 Meaning of bits in the first byte**
1 - - - - - - - simultaneous uses of indicated interfaces possible
0 - - - - - - - activation of at most one of the indicated interfaces possible
- - - - - - - 1 T=0 according to ISO/IEC 7816-3
- - - - - - 1 - T=1 according to ISO/IEC 7816-3
- - - - - 1 - - contactless according to ISO/IEC 14443[14]
- - - - 1 - - - USB according to ISO/IEC 7816-12
- - - 1 - - - - SWP according to ETSI TS 102 613, TS 102 622
- - 1 - - - - - Application waiting time management information
- x - - - - - - 0 (any other value is RFU)

#### 12.7.4 Profile services

#### This document defines short cut services for applications, e.g. application selection by AID or path (see

#### 12.3.6.3 and 12.4). Many applications, especially supporting legacy versions, are requested to supply

#### different hardware chips with a variety of features. Terminals of these applications need to identify the

#### application and the possible feature set of the card in a very fast way.

#### This identification is provided by the profile service (see Table 136 ), e.g. in an EF.DIR.

#### Table 136 — Application profile indicators encapsulated in a discretionary data objects DO’73’

```
Tag Value
'73' Application profile indicators
```
#### 12.7.5 Provision of additional information

#### Detailed information on e.g. peripherals or protocols may be present in the general feature management

#### template. This information shall be provided in a constructed DO having a tag within the context

#### specific class. Tag and content of which may be defined in other standards or specifications.


### 12.8 APDU management

#### 12.8.1 Extended length information

#### The presence of extended length information (DO'7F66') is indicated in the third software function

#### table of the card capabilities (see Table 127 ).

#### DO'7F66' may be present in EF .ATR/ INFO (see 12.3.3) and/or in the FMD of any Application DF. In the

#### former case, the information applies to all applications. Values specified in the application FMD only

#### apply to that application, possibly superseding values specified in the EF .ATR/ INFO.

#### EF .ATR/ INFO shall contain at most one instance of DO'7F66'; an application FMD shall contain at most

#### one instance of DO'7F66'. All DOs nested in DO'7F66' have a variable length.

#### The command- and response-APDU size limitations are defined by two integers, each nested in a DO'02'.

#### Under tag '7F66':

#### — The first DO'02' shall contain a positive integer. The number of bytes in a command APDU shall not

#### exceed this number.

#### — The second DO'02' shall contain a positive integer. If the card does not support response chaining

#### for a particular C-RP then in such a C-RP Ne shall be set such that the number of bytes in a response

#### APDU does not exceed this number.

#### 12.8.2 List of supported INS codes

#### An INS list DO'5F63' may be present in EF .ATR/ INFO (see 12.3.3) and/or in the FMD of any Application

#### DF. In the former case, the information applies to all applications. Values specified in application FMD

#### only apply to that application, possibly superseding values specified in the EF .ATR/ INFO.

#### If DO'5F63' is present then EF .ATR/ INFO or any application FMD shall contain at most one instance.

#### The INS list DO'5F63' nests a concatenation of INS codes supported by the card or application.


## Annex A (informative) Examples of object identifiers and tag allocation schemes

**A.1 Object identifiers**

#### For ISO standards, the first byte is '28', i.e. 40 in decimal (see ISO/IEC 8825-1). One or more series of

#### bytes follow; bit b8 is set to 0 in the last byte of a series and to 1 in the previous bytes, if there is more

#### than one byte. The concatenation of bits b7 to b1 of the bytes of a series encodes a number. Each number

#### shall be encoded on the fewest possible bytes, that is, the value '80' is invalid for the first byte of a

#### series. The first number is the number of the standard; the second number, if present, is the part in a

#### multi-part standard.

#### As a first example, {iso(1) standard(0) ic-cards(7816)} references ISO/IEC 7816 (all parts)[4].

#### — 7816 is equal to '1E88', i.e. 0001 1110 1000 1000, i.e. two blocks of seven bits: 0111101 0001000.

#### — After insertion of the appropriate value of bit b8 in each byte, the encoding of the first series is

#### therefore 1011 1101 0000 1000, equal to 'BD08'.

#### The data element '28 BD08' may be used in AIDs of standard category (see 12.3.4).

#### AID = 'E8 28 BD08 0B XX ... XX' (ISO/IEC 7816-11 specifies the application identifier extension 'XX ...

#### XX').

#### AID = 'E8 28 BD08 0F XX ... XX' (ISO/IEC 7816-15 specifies the application identifier extension 'XX ...

#### XX').

#### As a second example, {iso(1) standard(0) e-auth(9798) part(5)} references ISO/IEC 9798-5. The first

#### series is obtained as follows.

#### — 9798 is equal to '2646', i.e. 0010 0110 0100 0110, i.e. two blocks of seven bits: 1001100 1000110.

#### — After insertion of the appropriate value of bit b8 in each byte, the encoding of the first series is

#### therefore 11001100 01000110, equal to 'CC46'.

#### The data element '28 CC46 05 02' references the second mechanism in ISO/IEC 9798-5, i.e. GQ2. Such an

#### identifier may be conveyed in a DO (tag '06', universal class, see ISO/IEC 8825-1).

#### DO = {'06 05 28 CC 46 05 02'}

#### As a third example, {iso(1) standard(0) country-codes(3166) part(1)} references ISO 3166-1. The first

#### series is obtained as follows.

#### — 3166 is equal to 'C5E', i.e. 1100 0101 1110, i.e. two blocks of seven bits: 0011000 1011110.

#### — After insertion of the appropriate value of bit b8 in each byte, the encoding of the first series is

#### therefore 1001 1000 0101 1110, equal to '985E'.

#### The data element is '28 985E 01' (the first series is '01'). It may be conveyed in a DO.

#### DO = {'06 04 28 98 5E 01'}


**A.2 Tag allocation schemes**

### A.2.1 Example of standard tag allocation scheme

#### DO1 = {'59 02 95 02'}

#### DO2 = {'5F 24 03 97 03 31'}

#### DO1 (tag '59', card expiration date) encodes February 1995 as card expiration date (see ISO/IEC 7816-6).

#### DO2 (tag '5F24', application expiration date) encodes March 31st 1997 as application expiration date.

### A.2.2 Example of compatible tag allocation scheme

#### DO1 = {'78 06' {'06 05 28 81 8C 5D 03'}}

#### DO2 = {'5F 24 03 97 03 31'}

#### DO3 = {'70 04' {'42 02 XX XX'}}

#### DO4 = {'67 06' {'5F 29 03 XX XX XX'}}

#### DO1 (tag '78', compatible tag allocation authority) indicates a compatible tag allocation scheme for DOs

#### defined in ISO/IEC 18013-3[17] referenced by its object identifier (it is ’818C5D’). If DO1 appears either

#### in the initial data string (see 12.2.3), or in EF .ATR/ INFO (see 12.3.3), then the tag allocation authority is

#### valid for the entire card. If DO1 appears in the management data of a DF (see 7. 4), then the tag allocation

#### authority is valid within that DF.

#### DO2 (tag '5F24', interindustry application expiration date) encodes March 31st 1997 as application

#### expiration date.

#### DO3 (tag '70', interindustry template according to the included tag allocation authority) contains a DO,

#### tag '42', defined in ISO/IEC 18013-3[17].

#### DO4 (tag '67', authentication data template) contains the interchange profile DO, tag '5F29'.

### A.2.3 Another example of compatible tag allocation scheme

#### DO1 = {'5F 24 03 97 03 31'}

#### DO2 = {'70 0C' {'06 05 28 81 8C 5D 03'} {'42 04 XX XX XX XX'}}

#### DO3= {'67 06' {'5F 29 03 XX XX XX'}}

#### DO1 (tag '5F24', application expiration date) encodes March 31st 1997 as application expiration date.

#### DO2 (tag '70', interindustry template defined according to the included object identifier) contains a DO,

#### tag '06', which specifies that the subsequent DO, tag '42', is defined in ISO/IEC 18013-3[17].

#### DO3 (tag '67', interindustry authentication data template) contains the interchange profile DO, tag

#### '5F29'. Note that it cannot contain DOs defined in ISO/IEC 18013-3[17], because of the choice not to

#### transmit the interindustry DO with tag '78'.

### A.2.4 Example of coexistent tag allocation scheme

#### DO1 = {'79 05' {'06 03 28 XX XX'}}

#### DO2 = {'7E 06' {'5F 24 03 97 03 31'}}

#### DO3 = {'70 06' {'XX XX XX XX XX XX'}}

#### DO1 (tag '79', coexistent tag allocation authority) indicates a coexistent tag allocation scheme defined in

#### a standard referenced by an object identifier starting with '28', therefore an ISO standard. Mandatory

#### in such a scheme, DO1 shall appear either

#### — in the initial data string (see 12.2.3) or in EF .ATR/ INFO (see 12.3.3) if the tag allocation authority is

#### valid for the entire card, or

#### — in the management data of a DF (see 7. 4) if the tag allocation authority is valid within that DF.


#### DO2 (tag '7E') is an interindustry template for nesting interindustry DOs. Note that the interindustry

#### DO “application expiration date”, tag '5F24', is present, encoding March 31st 1997 as application

#### expiration date.

#### DO3 (tag '70', interindustry template to be interpreted according to the tag allocation authority

#### indicated in template '79') can only be interpreted according to the standard indicated in the object

#### identifier.


## Annex B (informative) Examples of secure messaging

**B.1 Cryptographic checksum**

#### This annex shows the use of secure messaging (see Clause 10 ) and cryptographic checksums (see

#### 10.3.3.2) for each of the four cases of C-RPs defined in ISO/IEC 7816-3.

#### In the examples, the notation T* means that bit b1 of the last byte of the tag field is set to 1 (an odd tag

#### number), i.e. that the SM DO shall be included in the computation of a data element for authentication.

#### In the examples, the notation CLA* means the use of secure messaging in the data fields: in CLA (see

#### 5.4.1), either bits b8, b7 and b6 set to 000 and bit b4 set to 1, or bits b8, b7 and b6 set to 011.

#### In the examples, the notation CLA** means that bits b8, b7 and b6 of CLA are set to 000 and bits b4

#### and b3 to 11, i.e. that the command header shall be included in the computation of a data element for

#### authentication.

#### Alternatively the header may be encapsulated in a DO with tag '89', i.e. an SM DO to be included in the

#### computation of a data element for authentication.

#### Figure B.1 shows Case 1 unsecured C-RP. Case 1 shows how bit b3 in the first coding of CLA (see Table 2 )

#### mandates the protection of the command header by a cryptographic checksum, and how the function

#### is optionally supported when using the second coding of CLA (see Table 3 ). In Case 1, protection of

#### course applies. The use of bit b3 in the first coding of CLA it is not shown in other cases, to simplify

#### the examples, and because the outcome is always the same: add one block at the beginning of the data

#### covered by the cryptographic checksum of a command APDU.

#### Figure B.1 — Case 1 unsecured C-RP - No command data, noresponse data

#### Figure B.2 shows Case 1 secure command APDU in case of status bytes not protected. The assumption

#### is made that the command header is to be protected, as it is the only item to protect in this C-RP.

#### Figure B.2 — Case 1 secured command APDU in case of status bytes not protected

#### If the length of the cryptographic checksum is four bytes, then the new Lc field is set to '06' (top line) or

#### '0C' (bottom line).

#### New data field = One or two DOs = conditional {T* - L - Command header} then {T - L - Cryptographic

#### checksum}


#### Data covered by the cryptographic checksum:

#### — first coding of CLA, one block = [CLA** INS P1 P2 Padding]

#### — second coding of CLA, one block = [{T* - L - Command header} - Padding]

#### Figure B.3 shows Case 1 secured response APDU in case of status bytes not protected.

#### Figure B.3 — Case 1 secured response APDU in case of status bytes not protected

#### Figure B.4 shows Case 1 secured command APDU in case of status bytes protected.

#### Figure B.4 — Case 1 secured command APDU in case of status bytes protected

#### New data field = One or two DOs =

#### conditional {T - L - Command header} always ending with {T - L - Cryptographic checksum}

#### The difference with case 1.a is the New Le field = '00', because the cryptographic checksum belongs to

#### response data which shall be required by the presence of Le. The data covered by the cryptographic

#### checksum are the same as in case 1.a.

#### Figure B.5 shows Case 1 secured response APDU in case of status bytes protected.

#### Figure B.5 — Case 1 secured response APDU in case of status bytes protected

#### New data field = Two DOs = {T* - L - SW1-SW2} - {T - L - Cryptographic checksum}

#### Data covered by the cryptographic checksum = One block = [{T* - L - SW1-SW2} – Padding]

#### Figure B.6 shows Case 2 unsecured C-RP.

#### Figure B.6 — Case 2 unsecured C-RP - No command data, response data

#### Figure B.7 shows Case 2 secured command APDU.


#### Figure B.7 — Case 2 secured command APDU

#### New data field = Two DOs = {T* - L - Ne } - {T - L - Cryptographic checksum}

#### Data covered by the cryptographic checksum = One block = [{T* - L - Ne } - Padding].

NOTE If the original Le field is '00' or '000000', the value field may be absent, i.e. the respective DO will be
'97 00' (see 10.5).

#### Figure B.8 shows Case 2 secured response APDU.

#### Figure B.8 — Case 2 secured response APDU

#### New data field = Three DOs =

#### {T* - L - Plain value} - {T* - L - SW1-SW2} - {T - L - Cryptographic checksum}

#### Data covered by the cryptographic checksum = one or more blocks, depending on the plain value, e.g.:

#### — One block = [{T* - L - Plain value} {T* - L - SW1-SW2} - Padding]

#### — Two blocks = [{T* - L - Plain value, start] - [Plain value, end} - {T* - L - SW1-SW2} - Padding]

#### Fig ure B.9 shows Case 3 unsecured C-RP.

#### Figure B.9 — Case 3 unsecured C-RP - Command data, no response data

#### Fig ure B.10 shows Case 3 secured command APDU in case of status bytes not protected.

#### Figure B.10 — Case 3 secured command APDU in case of status bytes not protected

#### New data field or new command payload = Two DOs

#### = {T* - L - Plain value} - {T - L - Cryptographic checksum}

#### Data covered by the cryptographic checksum = one or more blocks, depending on the plain value:

#### 1. [{T* - L - Plain value} - Padding]

#### 2. [{T* - L - Plain value}] - [Padding]

#### 3. [{T* - L - Plain value, start] - [Plain value, end} - Padding]


#### In example 1, with 8-byte blocks, the maximum L in the plain value DO is 5, in which case the block ends

#### with one byte of padding.

#### In example 2, with 8-byte blocks, L in the plain value DO is 6. The DO fills the block, which shall be

#### followed by a full block of padding.

#### In example 3, with 8-byte blocks, L in the plain value DO is between 7 and 13, to leave at least one byte

#### of padding at the end of the second block.

#### Fig ure B.11 shows Case 3 secured response APDU in case of status bytes not protected.

#### Figure B.11 — Case 3 secured response APDU in case of status bytes not protected

#### Figure B.12 shows Case 3 secured command APDU in case of status byes protected.

#### Figure B.12 — Case 3 secured command APDU in case of status bytes protected

#### New data field or new command payload = Two DOs

#### = {T* - L - Plain value} - {T - L - Cryptographic checksum}

#### Data covered by the cryptographic checksum =one or more blocks, depending on the plain value.

#### 4. [{T* - L - Plain value}- Padding]

#### 5. [{T* - L - Plain value, start}] - [Padding]

#### 6. [{T* - L - Plain value, start] - [Plain value, end} - Padding]

#### In example 4, with 8-byte blocks, the maximum L in the plain value DO is 5, in which case the block ends

#### with one byte of padding.

#### In example 5, with 8-byte blocks L in the plain value DO is 6. The DO fills the block, which shall be

#### followed by a full block of padding.

#### In example 6, with 8-byte blocks L in the plain value DO is between 7 and 13, to leave at least one byte of

#### padding at the end of the second block.

#### Figure B.13 shows Case 3 secured response APDU is in case of status bytes protected.

#### Figure B.13 — Case 3 secured response APDU in case of status bytes protected

#### New data field = Two DOs = {T* - L - SW1-SW2} - {T - L - Cryptographic checksum}

#### Data covered by the cryptographic checksum = One block = [{T* - L - SW1-SW2} - Padding]

#### F ig u r e B .14 shows Case 4 unsecured C-RP.


#### Figure B.14 — Case 4 unsecured C-RP - Command data, response data

#### Figure B.15 shows Case 4 secured command APDU.

#### Figure B.15 — Case 4 secured command APDU

#### New data field or new command payload = Three DOs

#### = {T* - L - Plain value} - {T* - L - Ne} - {T - L - Cryptographic checksum}

#### Data covered by the cryptographic checksum are the same as in case 3b.

#### Fig ure B.16 shows Case 4 secured response APDU.

#### Figure B.16 — Case 2 secured response APDU

#### New data field = Three DOs =

#### {T* - L - Plain value} - {T* - L - SW1-SW2} - {T - L - Cryptographic checksum}

#### Data covered by the cryptographic checksum = One or more blocks =

#### [{T* - L - Plain value} - {T* - L - SW1-SW2} – Padding]

**B.2 Cryptograms**

#### The use of cryptograms with and without padding (see 10. 3.2) is shown in command and response data

#### fields. Instead of the plain value DOs in the previous examples, DOs for confidentiality shall be used as

#### follows.

#### 1) Case a — Plain value not encoded in ber-tlv

#### Data field = {T - L - Padding-content indicator byte - Cryptogram}

#### Plain value conveyed by the cryptogram = One or more blocks =

#### Plain value not encoded in ber-tlv, possibly padded according to the indicator byte

#### 2) Case b — Plain value encoded in ber-tlv

#### Data field = {T - L - Cryptogram}

#### Plain value conveyed by the cryptogram = String of enciphered bytes =

#### DOs (padding depending on the algorithm and its mode of operation)


**B.3 Control references**

#### The use of control references (see 10.4.2 and 10.4.3) is shown.

#### Command data field = {T - L - Control reference template},

#### where control reference template = {T - L - File reference} - {T - L - Key reference}

**B.4 Response descriptor**

#### The use of response descriptor (see 10.4.5) is shown.

#### Command data field = {T - L - Response descriptor}

#### where response descriptor = {T (Plain value) - '00' - T (Cryptographic checksum) - '00'}

#### Response data field = {T - L - Plain value} - {T - L - Cryptographic checksum}

**B.5 envelope command**

#### The use of the envelope command (see 11.8.2) is shown.

#### Command data field = {T - L - Padding-content indicator byte - Cryptogram}

#### Plain value conveyed by the cryptogram =

#### Command APDU (starting by CLA* INS P1 P2), padding according to the indicator byte

#### Response data field = {T - L - Padding-content indicator byte - Cryptogram}

#### Plain value conveyed by the cryptogram =

#### Response APDU, padding according to the indicator byte

**B.6 Synergy between secure messaging and security operations**

#### The example explains how to use a security module card (SMC) that performs security operations for

#### producing a secured command APDU to send to a user card (USC) and for processing the corresponding

#### secured response APDU received thereon from the USC, i.e. for producing and processing data fields in

#### SM format. The example illustrates the synergy between the two approaches: — the atomic approach

#### by security operations (see ISO/IEC 7816-8) and — the global approach by secure messaging (see

#### Clause 10 ).

#### The example assumes that the USC and the SMC have completed a mutual authentication procedure,

#### based e.g. on card verifiable certificates. The authentication procedure includes a key transport or key

#### agreement mechanism so that after this procedure, two symmetric keys are available in the USC and in

#### the SMC:

#### 1. a symmetric session key for computing cryptographic checksums, and

#### 2. a symmetric session key for computing cryptograms.

#### The authentication procedure initialises one or more counters in the USC and the SMC. The example

#### does not show the maintenance and the use of such counters by the USC and the SMC.

#### All the C-RPs for the SMC are PSO commands, not using secure messaging, but using SM DOs (and the

#### SM keys set by MSE commands).


#### All the C-RPs for the USC use secure messaging and the command headers are included in the

#### computation of cryptographic checksums, i.e. CLA is switched to CLA**.

NOTE The cryptographic operations performed by the commands pso compute cc, pso verify cc and
pso encipher can require an input which has a length being a multiple of the block length of the cryptographic
algorithm. In order to fulfill this requirement padding applies. This padding is applied inside the SMC.
Furthermore the SMC removes padding bytes before responding to a pso decipher command. Thus padding at
the end of input or output data does not occur in the figures and statements below.

#### Fig ure B.17 shows the general principles for producing a secured command APDU.

#### Figure B.17 — Producing a secured command APDU

#### Figure B.18 shows the general principles for processing a secured response APDU.

#### Figure B.18 — Processing a secured response APDU

#### The following scenario explains the computation of a digital signature (DS) whereby the usage of the

#### private signature key requires the successful presentation of a password. The scenario proceeds in

#### three steps.


#### Step 1 — Password verification

#### 1.1 Command to SMC: mse set <CCT, {'83'-'01'-'81'}>

#### — The reference of the session key for computing cryptographic checksums is '81' in the example.

#### SMC response: OK

#### 1.2 Command to SMC: mse set <CT, {'83'-'01'-'82'}>

#### — The reference of the session key for computing cryptograms is '82' in the example.

#### SMC response: OK

#### 1.3 Command to SMC: pso encipher <Password>

#### SMC response: <CG (Password)>

#### 1.4 Command to SMC: pso compute cc <CLA**-INS-P1-P2 - Padding - {'87'-L-PCI-CG (Password)} -

#### {'97'-L- Ne } >

#### SMC response: <CC>

#### — Now the interface device constructs the secured verify command APDU.

#### 1.5 Command to USC: verify < {'87'-L-PCI='01'-CG (Password)} - {'97'- L- Ne } - {'8E'-'04'-CC}>

#### USC response: < {'99'-'02'-SW1-SW2} - {'8E'-'04'-CC}>

#### 1.6 Command to SMC: pso verify cc < {'80'-'04'-('99'-'02'-SW1-SW2)} - {'8E'-'04'-CC}>

#### SMC response: OK

#### Step 2 — Hash code computation

#### 2.1 Command to SMC: pso compute cc <CLA**-INS-P1-P2 - Padding - {'81'-L-({'90'-L-Intermediate

#### Hash} - {'80'-L-Last block})} - {'97'- L- Ne } >

#### SMC response: <CC>

#### 2.2 Command to USC: pso hash <{'81'-L1 (=4+L2+L3)-({'90'-L2- Intermediate Hash} - {'80'-L3-Last

#### block})} - {'8E'-'04'-CC}>

#### — The USC stores the hash code as an internal result for computing the digital signature later on.

#### USC response: <{'99'-'02'-SW1-SW2} - {'8E'-'04'-CC}>

#### 2.3 Command to SMC: pso verify cc <{'80'-'04'-({'99'-'02'-SW1-SW2})} - {'8E'-'04'-CC}>

#### SMC response: OK

#### Step 3 — Digital signature computation

#### 3.1 Command to SMC: pso compute cc <CLA**-INS-P1-P2 - Padding - {'97'-'01'-'00'}>

#### SMC response: <CC>

#### 3.2 Command to USC: pso compute ds <{'97'-'01'-'00'} - {'8E'-'04'-CC}>

#### USC response: <'81'-L-DS - '8E'-'04'-CC>

#### 3.3 Command to SMC: pso verify cc <{'80'-L1 (=2+L2)-('81'-L2-DS)} - {'8E'-'04'-CC}>

#### SMC response: OK


## Annex C

## (informative)

## Examples of authenticate functions by general authenticate

## commands

**C.1 General**

#### Two or more general authenticate C-RPs implement an authenticate function.

#### If chaining is used, then CLA is set to 0xx1 xxxx in the first command of the chain up to the penultimate

#### one and to 0xx0 xxxx in the last one: the other six bits shall remain constant within the chain (see 5.3.3).

#### INS P1 P2 is set to either '86 00 00', or '87 00 00'.

#### The value of the Lc field depends upon the DOs in the command data field. Depending upon whether a

#### response data field is expected or not, the Le field is either set to '00', or absent.

**C.2 GENERAL AUTHENTICATE using witness-challenge-response triples**

### C.2.1 General

#### This annex illustrates data fields of general authenticate commands implementing mechanisms

#### such as specified in ISO/IEC 9798-5[8], i.e. mechanisms using zero-knowledge techniques.

#### — A verifier knows a public problem and a claimant knows a secret solution to the public problem.

#### — As a result of the zero-knowledge protocol, the verifier is convinced that the claimant knows a

#### solution to the public problem. Moreover, the solution remains secret.

NOTE ISO/IEC 9798-5[8] specifies two GQ techniques.

— Being given a public RSA key where the exponent v is prime such as 257 = 2^8 +1, 65537 = 2^16 +1 or 2^36 +2^13 +1,
the GQ1 technique allows verifying an RSA signature without taking knowledge of its value, or alternatively,
proving knowledge of an RSA signature without revealing its value. As specified by the RSA signature
standard in use (e.g. see ISO/IEC 14888[15]), a format mechanism converts the claimant's identification
data (a template) into a public number G. The corresponding private number Q is the RSA signature of the
identification data. The claimant and the verifier know the public RSA key. The GQ1 protocol proves that the
claimant knows the RSA signature of his identification data.

— Being given a public modulus n, product of two prime factors, the GQ2 technique allows verifying the factors
without taking knowledge of them, or alternatively, proving knowledge of the factors without revealing
them. The mechanism involves a security parameter k > 0 and the first m prime numbers, named the m basic
numbers, such that k×m is from 8 to 36. Each public number is the square of a basic number: G = g^2. The
corresponding private number Q is a modular 2k+1-th root of G. If there is at least one basic number g such that
the Jacobi symbol of g with respect to n is –1 and if n is congruent to 1 mod 4, then the GQ2 protocol proves
that n is composite and that the claimant knows the factors.

#### The protocol typically exchanges three numbers, namely a witness, a challenge and a response.

#### — The claimant works in two steps: as a first step, the claimant privately selects a fresh random number

#### and converts it into a witness according to a “witness formula”; as a second step, having received a

#### challenge, the claimant gets the response to the challenge from the fresh random number and the

#### private number, according to a “response formula”, and then erases the fresh random number.


#### — The verifier reconstructs a witness from the challenge and the response, according to a “verification

#### formula”.

#### By definition, a triple consists of three numbers, namely, a witness, a challenge and a response, verifying

#### the verification formula. Any entity may randomly produce triples in “public mode”, from any challenge

#### and response. A judge or an observer cannot distinguish random triples produced in public mode, i.e.

#### by an entity not knowing the secret, and random triples produced in “private mode”, i.e. by an entity

#### knowing the secret.

#### This subclause illustrates three authenticate functions.

#### — internal authenticate function — A verifier in the outside world authenticates a claimant in

#### the card.

#### — external authenticate function — A verifier in the card authenticates a claimant in the

#### outside world.

#### — mutual authenticate function — Both entities authenticate each other.

### C.2.2 internal authenticate function

#### If the first data field conveys a witness request, namely, either an empty witness ('80 00'), or an empty

#### authentication code ('84 00'), then the function is internal authenticate.

#### Figure C.1 shows basic protocol of internal authenticate function (two C-RPs).

#### Figure C.1 — Basic protocol of internal authenticate function

#### Figure C.2 shows committed challenge protocol of internal authenticate function (two C-RPs).

NOTE The committed challenge ensures that the challenge and the witness are independently selected.

#### Figure C.2 — Committed challenge protocol of internal authenticate function


#### Figure C.3 shows extension to data field authentication protocol of internal authenticate function

#### (two C-RPs).

#### The card has hashed previously exchanged data fields: the result is a current hash-code. The card

#### includes its witness DO for getting an authentication code and transmits it with tag '84'.

#### Figure C.3 — Extension to data field authentication protocol of internal authenticate

#### function

### C.2.3 external authenticate function

#### If the first data field conveys a challenge request, namely, either an empty challenge ('81 00'), or an

#### empty committed challenge ('83 00'), then the function is external authenticate.

#### Figure C.4 shows basic protocol of external authenticate function (two C-RPs).

#### Figure C.4 — Basic protocol of external authenticate function

#### Figure C.5 shows committed challenge protocol of external authenticate function (three C-RPs).

#### Figure C.5 — Committed challenge protocol of external authenticate function


#### Figure C.6 shows extension to data field authentication of external authenticate function (two C-RPs).

#### A claimant has hashed previously exchanged data fields: the result is a current hash-code. It includes its

#### witness DO for getting an authentication code and transmits it with tag '84'.

#### Figure C.6 — Extension to data field authentication protocol of external authenticate

#### function

### C.2.4 mutual authenticate function

#### If the first data field conveys no empty DO, then the function is mutual authenticate; the outside

#### world requests the same DOs in the response data field as in the command data field.

#### Figure C.7 shows basic protocol of mutual authenticate function (three C-RPs).

#### Figure C.7 — Basic protocol of mutunal authenticate function

#### Figure C.8 shows committed challenge protocol of mutual authenticate function (four C-RPs)


#### Figure C.8 — Committed challenge protocol of mutual authenticate function

#### Fig ure C .9 shows extension to key agreement protocol of mutual authenticate function (four C-RPs)

#### A pair of exponential data elements allows the agreement of a session key (see ISO/IEC 11770 (all parts)[13]).

#### The first C-RP exchanges dynamic authentication templates nesting an “exponential” data element. In

#### the example, as no message has been previously exchanged during the session, the initial hash-code is

#### a null block. Then the command data field, i.e. the first dynamic authentication template, is included

#### for getting a current hash-code; then the response data field, i.e. the second dynamic authentication

#### template is included for updating the current hash-code; the current hash-code should be the same for

#### both entities. Finally a witness DO (not zero and not transmitted, different for each entity) is included

#### for getting an authentication code (different for each entity).

#### The second C-RP exchanges dynamic authentication templates nesting authentication codes with tag '84'.

#### Figure C.9 — Extension to key agreement protocol of mutual authenticate function


**C.3 GENERAL AUTHENTICATE for a multi-step authentication protocol**

### C.3.1 General

#### This subclause describes the usage of the general authenticate command for a multi-step

#### authentication protocol, i.e. the password based authentication scheme PACE v2 as described in

#### EN 419212 (all parts)[1].

#### Thereby a multi-step authentication protocol contains several authentication operations, at least one

#### or more general authenticate: PERFORM KEY AGREEMENT (PKA) operations which initiate the

#### generation, management and/or use of Diffie-Hellman key pairs and/or key parameters in the card, e.g.

#### to establish secure channel between ICC and external world by means of password authentication only.

#### According to the specific protocol in use one or more PKA operations are used to

#### — encipher and/or map a nonce;

#### — generate an asymmetric Diffie-Hellman (DH) key pair for key agreement; and/or

#### — pre-access an asymmetric DH key pair and/or key parameters previously generated in the card;

#### — store a DH public key from the interface device (IFD) based on the same global parameters in the card;

#### — process a key agreement; and

#### — provide respective ephemeral keys in the card, e.g. to be used for secure messaging.

#### The operation(s) are preceded by one or more manage security environment operation(s) in order

#### to set the respective object identifier as well as the key generation related parameters (e.g. algorithm

#### reference in the AT according to the protocol variant to be used (Authenticated Lightweight Key

#### Exchange (ALIKE) according to ISO/IEC 29192-4[22], Extended Access Control (EAC), PACE v2 according

#### to EN 419212 (all parts)[1]).

NOTE As defined in 10.4.3 within a control reference template a DO'80' is used to transfer a cryptographic
mechanism reference. In C.3.2 step 1 and in C.3.3 step 3 purposefully the cryptographic mechanism reference
is chosen to be identical to the value of the object identifier describing the authentication protocol by implicit
tagging.

#### One or more general authenticate C-RP(s) implement(s) an authentication operation.

#### — If chaining is used, see 5.3.3.

#### — INS P1 P2 is set to either '86 00 00', or '87 00 00'.

#### — The value of the Lc field depends upon the DOs in the command data field. Depending upon whether

#### a response data field is expected or not, the Le field is either set to '00', or absent.

### C.3.2 Use of general authenticate with even INS code ('86'): Password based

### authentication scheme PACE v2

#### Fig ure C .10 shows password based authentication scheme PACE v2 (five C-RPs).

#### general authenticate command is used for step 2 to 5. manage security environment command is

#### used for step 1.


#### Figure C.10 — Password based authentication scheme PACE v2

### C.3.3 Use of general authenticate with even INS code ('86'): Extended Access

### Control (EAC)

#### C.3.3.1 General

#### The EAC protocol is separated in two parts: Terminal Authentication (TA) allows the authentication

#### of the interface device or remote server, whereas Chip Authentication (CA) proves identity of the card.

#### Two versions are distinguished according EN 419212 (all parts)[1]:

#### — EACv1 refers to the sequence CA-TA;

#### — EACv2 refers to the sequence TA-CA.

#### The Terminal Authentication protocol first imports the public key of the interface device into the card

#### by means of card verifiable certificates. In a second step a challenge-response protocol is performed.


#### The Chip Authentication protocol specifies a Diffie-Hellman key agreement with establishment of a

#### secure channel.

#### C.3.3.2 Terminal Authentication protocol

#### Figure C.11 — Terminal authentication protocol of extended access control

#### C.3.3.3 Chip Authentication protocol

#### Figure C.12 shows chip authentication protocol of extended access control.


a

For EACv1 with TDES only the following command is still in use for step 1. In this case Step 2 will be omitted.
Step 1: Set SE (K AT)
Command data field { '91' – L – Ephemeral public key of IFD } EACv1 only with TDES
{ '84' – L – Reference of private key} EACv1 only with TDES

Response data field {} – absent

#### Figure C.12 — Chip authentication protocol of extended access control


## Annex D (informative) Application identifiers using issuer identification numbers

**D.1 Background information**

#### In ISO/IEC 7816-5, it was possible to use issuer identification numbers in application identifiers. This

#### annex indicates the format of such AIDs.

**D.2 Format**

#### In any AID where bits b8 to b5 of the first byte are set from '0' to '9', the first and possibly only field

#### shall be an issuer identification number according to ISO/IEC 7812-1[3].

NOTE In ISO/IEC 7812-1, an issuer identification number might consist of an odd number of quartets valued
from '0' to '9'. Then it was mapped into a byte string by setting bits b4 to b1 of the last byte to 1111.

#### If a proprietary application identifier extension is present, then a byte set to 'FF' shall separate the

#### two fields.

#### Figure D.1 shows an AID using an issuer identification number: it consists of up to sixteen bytes.

#### Figure D.1 — AID using an issuer identification number


## Annex E (informative) BER encoding rules

**E.1 ber-tlv tag fields**

#### Bits b8 and b7 of the first byte of the tag field indicate a class (see ISO/IEC 8825-1).

#### — The value 00 indicates a DO of the universal class.

#### — The value 01 indicates a DO of the application class.

#### — The value 10 indicates a DO of the context-specific class.

#### — The value 11 indicates a DO of the private class.

#### Bit b6 of the first byte of the tag field indicates an encoding (see E.3).

#### If bits b5 to b1 of the first byte of the tag field are not all set to 1, then they encode a tag number from

#### zero to thirty and the tag field consists of a single byte. Tag number 0 is precluded in the universal class.

#### Otherwise (bits b5 to b1 all set to 1), the tag field continues on one or more subsequent bytes.

#### — Bit b8 of each subsequent byte shall be set to 1, unless it is the last subsequent byte.

#### — Bits b7 to b1 of the first subsequent byte shall not be all set to 0.

#### — Bits b7 to b1 of the first subsequent byte, followed by bits b7 to b1 of each further subsequent byte,

#### up to and including bits b7 to b1 of the last subsequent byte encode a tag number.

#### Table E .1 shows the first byte of the tag field. The value '00' is invalid.

#### Table E.1 — First byte of ber-tlv tag fields in ISO/IEC 7816 (all parts)[4]

```
b8 b7 b6 b5 b4 b3 b2 b1 Meaning
0 0 - - - - - - Universal class, not defined in ISO/IEC 7816 (all parts)[4]
0 1 - - - - - - Application class, identification defined in this document
1 0 - - - - - - Context-specific class, defined in ISO/IEC 7816 (all parts)[4]
1 1 - - - - - - Private class, not defined in ISO/IEC 7816 (all parts)[4]
```
- - 0 - - - - - Primitive encoding
- - 1 - - - - - Constructed encoding
- - - Not all set to 1 Tag number from zero to thirty (short tag field, i.e. a single byte)
- - - 1 1 1 1 1 Tag number greater than thirty (long tag field, i.e. two or three bytes)

#### In tag fields of two or more bytes, the values '00' to '1E' and '80' are invalid for the second byte.

#### — In 2-byte tag fields, the second byte consists of bit b8 set to 0 and bits b7 to b1 encoding a number

#### greater than thirty. The second byte is valued from '1F' to '7F; the tag number is from 31 to 127.

#### — In 3-byte tag fields, the second byte consists of bit b8 set to 1 and bits b7 to b1 not all set to 0; the

#### third byte consists of bit b8 set to 0 and bits b7 to b1 with any value. The second byte is valued from

#### '81' to 'FF' and the third byte from '00' to '7F'; the tag number is from 128 to 16 383.


**E.2 ber-tlv length fields**

#### In short form, the length field consists of a single byte where bit b8 is set to 0 and bits b7 to b1 encode

#### the number of bytes in the value field. One byte can thus encode any number from zero to 127.

NOTE Any number from one to 127 is encoded in the same way in ber-tlv length field as in Lc and Le fields.
The encoding differs for zero, 128 and more. See for example, the coding of DOs in the get data command in 11.5.3.

#### In long form, the length field consists of two or more bytes. Bit b8 of the first byte is set to 1 and bits

#### b7 to b1 are not all equal, thus encoding the number of subsequent bytes in the length field. Those

#### subsequent bytes encode the number of bytes in the value field.

#### ISO/IEC 7816 (all parts)[4] supports length fields of one, two, ... up to five bytes (see Table E. 2). In

#### ISO/IEC 7816 (all parts)[4], the values '80' and '85' to 'FF' are invalid for the first byte of length fields.

#### Table E.2 — ber-tlv length fields in ISO/IEC 7816 (all parts)[4]

```
1 st byte 2 nd byte 3 rd byte 4 th byte 5 th byte N
1 byte '00' to '7F' - - - - 0 to 127
2 bytes '81' '00' to 'FF' - - - 0 to 255
3 bytes '82' '0000' to 'FFFF' - - 0 to 65 535
4 bytes '83' '000000' to 'FFFFFF' - 0 to 16 777 215
5 bytes '84' '00000000' to 'FFFFFFFF' 0 to 4 294 967 295
```
**E.3 ber-tlv value fields**

#### Bit b6 of the first byte of the tag field indicates an encoding of the value field:

#### — The value 0 indicates a primitive encoding of the DO, i.e. no information is provided on the coding of

#### the value field, even if the value field is encoded in ber-tlv.

#### — The value 1 indicates a constructed encoding of the DO, i.e. the value field, if present, is encoded in

#### ber-tlv. A non-empty value field is one DO, or a concatenation of DOs without padding.


## Annex F (informative) ber-tlv data object handling

**F.1 Generations and templates in a constructed DO**

#### Figure F.1 — Generations, DOs and templates in a constructed DO

#### Each line of Fig u r e F.1 contains one and only one DO. A DO uses two successive cells on the same line,

#### the leftmost cell contains the DO header (Tag, Length), and the rightmost cell contains its value.

#### The leftmost vertical bold line shows the template referenced by curConstructedDO after file selection,

#### or after selection of the virtual DO'7F70'. The template contains DO'T1' and 'T6', which appear

#### immediately on the right of a bold solid line. No Tn Ln tuple appears immediately on the right of a bold

#### dotted line; this dotted line shows that the template is not finished.

#### The DOs belonging to a line with this dotted border belong to the structure (file, record or

#### DataString) , but do not belong to the template, because they are nested in other constructed DOs, i.e.

#### do not belong to the 1st generation.

#### After selection of DO'T1', the template referenced by curConstructedDO is shown by a bold line,

#### starting on the immediate right of the cell holding "Value 1". This cell is framed by a bold border to

#### indicate that this value is a template, i.e. a concatenation of the DOs nested within the constructed

#### DO'T1', which make up the template referenced by curConstructedDO after selection of DO'T1'. This

#### template features five 2nd generation DOs, DO'T2', 'T3', 'T2', 'T14', 'T9'. The template also uses a dotted

#### bold line. The DOs belonging to a line with this dotted border belong to DO'T1' , but do not belong to

#### the template referenced by curConstructedDO after DO'T1' selection , because they are nested in

#### other constructed DOs, i.e. do not belong to 2nd generation.

#### There are two instances of DO'T2', with identical tags, but possibly different lengths and values. This is

#### allowed, but implies that handling of those DOs shall use DO ordering within this template. As the two


#### instances belong to the same template, the consistent use of tagging for referencing ensures that they

#### have the same meaning.

#### After selection of DO'T3', the template referenced by curConstructedDO is shown by a bold line. This

#### template features three 3rd generation DOs, DO'T4', 'T6', 'T5'.

#### After selection of DO'T9', the template referenced by curConstructedDO features two 3rd generation

#### DOs, DO'T4', 'T6'. Though in the same generation as the template referenced by curConstructedDO after

#### selection of DO'T3', it is a different template. The 3rd generation shows two instances of DO'T6', but they

#### belong to different templates and as such may have different meanings, except if further information

#### may be derived from e.g. the class of tag 'T6'.

**F.2 Referencing by an extended header list**

#### All examples shown in this subclause would result in the same byte strings with the two leftmost

#### columns deleted from all figures. The title of this subclause would then be "Referencing by an extended

#### header list". This emphasizes that the target DO shown in Fig u r e F. 2 and the first header of an extended

#### header shall match, i.e. have the same tag, in order to reference a non-empty byte string.

#### Figure F.2 — Target DO of all extended headers in this subclause

#### Figure F.3 — Extended header data element 1, including no skipped match on any primitive DO


#### Figure F.4 — Matches found with extended header 1 in a pruned-tree of DO'A1'

#### Fig u r e F.4 shows that only two first instances of DO'88' were matched by applying the extended

#### header list shown in Fig u r e F. 3. If the extended header is under tag '4D', one cannot include the second

#### instance without including the first. Truncation of the values of primitive DOs have been performed.

#### The referenced byte string is either:

#### — in data object format (the extended header list tagged by ‘5F61’):

#### {88 03 81 82 83} {88 02 84 85} {8E 03 E0 E1 E2} {A3 07 {84 01 46} {86 02 63 64}}, or

#### — in data element format (the extended header list tagged by ‘5F60’):

#### '81 82 83 84 85 E0 E1 E2' {84 01 46} {86 02 63 64}.

#### Fig u r e F. 5 shows how to include only the second instance of DO'A3':

#### Figure F.5 — Extended header data element 2, implicitly excluding a match on a constructed DO

#### Figure F.6 — Matches found with extended header 2 in a pruned-tree of DO'A1'

#### The first instance of DO'A3' is not referenced, because the first DO to be referenced was DO'8E', which

#### excludes referencing any DO before it, according to 8.4.7. Fig u r e F.7 shows an extended header which

#### will have the same outcome as the extended header of Fig u r e F. 5.

#### Figure F.7 — Redundant coding of extended header data element 2


#### In the case shown by Fig u r e F. 5, Fig u r e F. 6 and Fig u r e F.7, the referenced byte string is either:

#### — in data object format (the extended header list tagged by ‘5F61’):

#### {8E 03 E0 E1 E2} {A3 07 {84 01 46} {86 02 63 64}}, or

#### — in data element format (the extended header list tagged by ‘5F60’):

#### 'E0 E1 E2' {84 01 46} {86 02 63 64}.

#### Figure F.8 — Extended header data element 3, including a skipped match on a constructed DO

#### Figure F.9 — Matches found with extended header 3 in a pruned-tree of DO'A1'

#### In the case shown by Fig u r e F. 8 and Fig u r e F.9, the indication that a match with the first instance of DO

#### 'A3' shall be skipped becomes necessary, because no match may occur between matches with the two

#### instances of DO 'A3'. The referenced byte string is either:

#### — in data object format (the extended header list tagged by ‘5F61’): {A3 07 {84 01 46} {86 02 63 64}}, or

#### — in data element format (the extended header list tagged by ‘5F60’): {84 01 46} {86 02 63 64}.

#### Figure F.10 — Extended header data element 4, including a skipped match on a primitive DO

#### Figure F.11 — Matches found with extended header 4 in a pruned-tree of DO'A1'.

#### Fig u r e F.11 shows that only the second instance of DO'88' was matched by applying the extended header

#### list shown in Fig u r e F.10. The syntax of extended header 4 is not possible under tag '4D'. The referenced

#### byte string is either:

#### — in data object format (the extended header list tagged by ‘5F61’): {88 03 84 85 86}, or

#### — in data element format (the extended header list tagged by ‘5F60’): '84 85 86'.


**F.3 Use of the update data command**

#### This example makes the assumption that one and only one DO 'B1' is present in the VA. If more than one

#### instance of DO'B1' are present, updating one of them can be performed either:

#### — by selection of an instance by a select data C-RP, then updating the DOs in the next generation, or

#### — by setting a pointer on this instance by one or several get next data C-RPs.

#### Fig u r e F.12 shows a DO'B1' to be updated by an update data C-RP. Its tree structure is comprised of:

#### — A primitive DO'82' (2nd generation) and a constructed DO'B2' (2nd generation).

#### — The constructed DO'B2' (2nd generation) nests two primitive DOs '90' and '91', (3rd generation)

#### and one constructed DO'B3' (3rd generation).

#### — The constructed DO'B3' (3rd generation) nests two primitive DOs '84' and '86' (4th

#### generation).

#### Figure F.12 — DO'B1' to be updated

#### Fig u r e F.13 shows the argument of an update data command. It is a DO based on DO'B1'. It is a pruned-

#### tree where, with respect to the original DO'B1':

#### — some "branches" (DOs) may be present; those will be updated;

#### — some may be missing; those will not be updated, hence kept as in the original DO'B0';

#### — some may be added, they will be created.

#### Figure F.13 — Argument of the update data command

#### F ig u r e F.14 shows the content of DO'B1' after the success of the update data C-RP:

#### — In the 2nd generation, DO'82' is untouched, DO'B2' updated and DO'8E' created.

#### — In the 3rd generation, primitive DOs '90' and '91' are untouched and DO'B3' is updated.

#### — In the 4th generation, primitive DO'84' is now empty and DO'86' is updated. The new value

#### of DO'86' transmitted in the command (see Fig u r e F.13) replaces the previous value (see

#### Fig u r e F.12)


#### Figure F.14 — Updated DO'B1', where modified or added DOs show in bold type

**F.4 Security attribute for one DO**

#### Figure F.15 — Current template with DO'XY' and its security attribute (general layout)

#### Fig u r e F.15 illustrates the coding of the security attributes of a DO'XY' nested in a DO'UV'. The security

#### attribute DO'A0' is nested in the control parameters DO'62', which also nests a security parameters

#### template DO'AD'. DO'62' may contain other CP DOs not represented in the figure, because irrelevant in

#### this example.

#### The tag given in the tag list nested in the security attribute DO'A0' shall be significant, i.e point to a DO

#### under DO'UV', in other words a 1st generation DO if DO'UV' is selected. The DO'AD' referenced by its

#### number shall be under DO'62' under DO'UV'.


**F.5 Example of key referencing in a self-controlled DO**

#### Figure F.16 — Value of a self-controlled DO 'XY' with security attributes referencing three keys

NOTE Fig u r e F.16 does not indicate the length field of DOs, which would bring small information. Bold lines
indicate on the left the tag of a constructed DO, on the right the tag(s) of the DO(s) nested within.

#### Fig u r e F.16 illustrates the coding of the security attributes in a DO'XY' The security attribute DO'A0' is

#### nested in the control parameters DO'62', which also nests three instances of the SPT DO'AD'. DO'XY' and

#### DO'62' may contain other CP DOs not represented in the figure, because irrelevant in this example.


#### The tag(s) given in a non-empty tag list nested in the security attribute DO'A0' shall be significant, i.e.

#### point to a DO under DO'XY', in other words a 1st generation DO. The SPT DO'AD' belongs to the same

#### generation as the security attribute DO'A0' which references the DO'AD'.

NOTE A security attribute DO'A0' is nested in a DO'62'. A security attribute extension DO'A0' is nested in a
DO'AD'. Their syntaxes are different.


## Annex G (informative) Template extension by tagged wrapper

**G.1 General**

#### Template extension by tagged wrappers allows a card to emulate, within a given VA, one or several

#### "distant" DOs which do not actually belong to the VA (see 8.2.2, 8.4.8 and 8.4.9). This annex assumes

#### that the security status allows reading a distant DO by a get data C - R P. Figure G.1 shows both the

#### tagged wrapper created in a base template (e.g. by a put data command) and the outcome of this

#### tagged wrapper in the template extension. Only tags appear:

#### Figure G.1 — Syntax and outcome of a tagged wrapper

#### 1) Other tags are available to reference the DO (see 8.4.8).

#### 2) There are other means to set the transient VA (see 8.4.8).

#### 3) When elements of the transient VA belong to the current VA, there is no need to repeat them in the

#### tagged wrapper, only to confirm them when they are both absent (see following clauses).

**G.2 Referencing within the EF referenced by curEF**

#### The example below shows the content of an EF '12 34' (file identifier) under an application

#### DF 'A0 01 02 03 04' (application identifier). Figure G.2 shows the hexadecimal coding of tag and length

#### fields. Except in the value of the tagged wrapper, the values of the primitive DOs are not significant.


#### Figure G.2 — Contents of EF '12 34' under the application DF named 'A0 01 02 03 04'

#### The value of DO'B2' under DO'A2' consists of a base template (DOs '80', '81', '82', and '63') and a template

#### extension (DO'91'), because the tagged wrapper DO'63' references by an extended header the DO'80'

#### in the first generation (leftmost column). This DO'80' will be referenced by tag '91' in the template it

#### extends, here to avoid a collision of tags '80' possibly referencing different types. Tag '80' appears twice

#### in bold type, in the 1st generation (the DO belongs to the base template); and in the 5thgeneration (in an

#### extended header data element). The value 'XY' appears twice in bold type, in the 1st generation (where

#### it is defined); and in the 3rd generation, as the value of DO'91'. Tag '91' appears twice in bold type, in

#### the 4th generation where it is defined); and in the 3rd generation (the DO'91' belongs to the template

#### extension).

#### The empty file reference DO'51' states that the indirection is valid in the VA referencing DO'B2', which

#### nests the DO'63', thus confirms that the transient VA references the application 'A0 01 02 03 04', and the

#### EF '12 34'. When the DO referenced by curConstructedDO is DO'B2', DO'80' may be addressed locally by

#### tag '91':

#### — the command APDU '00 CA 00 91 00' will return 'XY 9000'.

#### — the command APDU '00 CB 00 00 03' {5C 01 91} '00' will return {91 01 XY} '9000'.

**G.3 Referencing within the application DF referenced by curAppDF, first example**

#### Figure G.3 — Alternative contents of EF '12 34' under the application DF named 'A0 01 02 03 04'


#### In Figure G.3 , the contents of EF '12 34' does not include the tagged wrapper, which may be present (if

#### valid) in any VA referencing the application DF 'A0 01 02 03 04', but not the EF '12 34': The syntax of a

#### tagged wrapper, referencing the same DO as in G.2, will be as shown in Figure G.4.

#### Figure G.4 — Syntax of a tagged wrapper referencing an EFincluding a tag list

#### As compared to Figure G.2:0037-1800-9621

#### — An explicit referencing of the EF states that the indirect reference is valid in EF '12 34'.

#### — As DO'80' belongs to the 1st generation in EF '1234' the extended header may be replaced by a tag list.

#### When issued from any VA referencing the application named 'A0 01 02 03 04' and the parent of the

#### tagged wrapper above, DO'80' may be addressed locally by tag '92':

#### — the command APDU '00 CA 00 92 00' will return 'XY 9000';

#### — the command APDU '00 CB 00 00 03' {5C 01 92} '00' will return {92 01 XY} '9000'.

#### An analogous (but not identical) function may be supported by another get data C-RP. When issued

#### from the same VA, the command APDU '00 CB 12 34 03' {5C 01 80 } '00' will return { 80 01 XY} '9000'.

#### The differences with the C-RP above are shown in bold type. In order to use this alternate solution, the

#### outside world shall know the file identifier '12 34', the tag '80' of the DO and its generation. All this can

#### depend on the implementation.

**G.4 Referencing in the application DF referenced by curAppDF, second example**

#### One wants to address DO'A0' under DO'62'. An extended header is necessary; this DO'A0' belongs to the

#### 2 nd generation in the EF. The tagged wrapper will be as shown in Figure G.5.

#### Figure G.5 — Syntax of a tagged wrapper referencing an EFincluding an extended header

#### The tag of DO'A0' under DO'62' has the standard meaning of security attribute for DOs. Addressing

#### it locally with the same tag, under another DO'62', avoids duplication of this security attribute, e.g. if

#### several EFs within an application DF use the same default security attribute for DOs.

#### When issued from any VA referencing the application named 'A0 01 02 03 04' and the tagged

#### wrapper above,

#### — the command APDU '00 CA 00 A0 00' will return {5C 00} {8B 08 B1 B2 B3 B4 B5 B6 B7 B8} '9000';

#### — the command APDU '00 CB 00 00 03' {'5C 01 A0'} '00'

#### will return {A0 0C {5C 00} {8B 08 B1 B2 B3 B4 B5 B6 B7 B8}} '9000'.


**G.5 Referencing out of the application DF referenced by curAppDF**

#### The current VA does not reference the application DF 'A0 01 02 03 04'. Therefore, referencing the

#### application and the EF is necessary. For referencing the same DO as in the first example of G.3 , the

#### tagged wrapper will be as shown in Figure G.6.

#### Figure G.6 — Syntax of a tagged wrapper referencing an application DF and an EFincluding a

#### tag list

#### When issued from any VA including the tagged wrapper above,

#### — the command APDU '00 CA 00 92 00' will return 'XY 9000';

#### — the command APDU '00 CB 00 00 03' {5C 01 92} 00' will return {92 01 XY} '9000'.

**G.6 Warnings**

#### Indirect referencing of a DO belonging to a template extension may result in circular referencing.

#### Using tagged wrappers trades complexity of commands against complexity in data. Thus, care shall be

#### taken when choosing the tag by which a distant DO may be seen locally, in order to avoid addressing:

#### — a constructed DO by a tag indicating a primitive one, which is awkward, but possible;

#### — a primitive DO by a tag indicating a constructed one; this will result in a DO or a template of

#### invalid syntax;

#### — a standard DO, of a defined type, by another tag which does not indicate this type; this implies that

#### the specification or standard using this mentions the type;

#### — a DO by a tag which is already used in the same template as the tagged wrapper, without being

#### aware of the duplication of instances.


## Annex H (informative) Parsing an extended header against its target DO

#### The procedure described in this annex accounts for three use cases of an extended header:

#### — complete extended headers built according to 8.4.5 , knowing the referenced constructed DO, or

#### — built according to 8.4.5, knowing a previous value of the referenced DO, updated since; this may

#### result in different structures for the extended header and its target DO, or

#### — built without redundant references to DOs to be skipped, in order to shorten the extended header.

#### To follow the procedure, display the extended header and the target DO as in Annex F: one header per

#### line in the header table, one DO per line in the DO table. The order of lines shows the order of headers

#### and DOs, the generations show as column shifts. The following rules shall apply sequentially, unless "Go

#### to..." is mentioned:

#### 1) If at least one table is empty, the procedure is completed.

#### 2) If the extended header is meant to reference only one DO, the procedure is completed if a non-

#### skipped match (L≠'80' in the header) with a primitive DO, or a complete match (L='80' in the

#### header) with a constructed DO is achieved.

#### 3) Read the first (topmost) line in the header table and search a match of the header in the DO table.

#### Unless stated otherwise [see 8)], the search shall be done in the first (topmost) line of the DO table.

#### 4) If a match (same tag, same generation) is achieved, go to 10).

#### 5) If the DO generation is lower than the header generation, go to 7).

#### 6) If searching has not reached the last line of the DO table, search continues in the next line. Go to 1).

```
NOTE 1 When searching a template, DOs in higher generations or with the wrong tag are ignored.
```
#### 7) If the searched match was on a primitive DO, delete the line from the header table. Go to 1).

```
NOTE 2 The referenced DO was never in the searched template or got deleted after a match [see 10)].
```
#### 8) If the searched match was on a constructed DO, either skipped (L='00' in the header) or complete

#### (L='80' in the header), delete the line from the header table. Go to 1).

```
NOTE 3 The referenced DO was never in the searched template or got deleted after a match [see 10)].
```
#### 9) Delete from the header table the lines referencing the constructed DO and its contents. Go to 1).

```
NOTE 4 The referenced constructed DO was never in the searched template or got deleted after a match
[see 10)]. The references to its contents become useless.
```
#### 10) Apply 8.4.6. Delete the matching line from both tables. In the DO table, delete all lines above, if any.

```
NOTE 5 Any contribution of those deleted DOs to the byte string would not match the order mandated by
the extended header.
```
#### 11) If a match with a primitive DO was achieved, go to 1).

#### 12) If a skipped match (L='00' in the header) or a complete match (L='80' in the header) with a constructed

#### DO was achieved, delete from the DO table all lines of the value of the matching DO. Go to 1).


#### 13) If another match with a constructed DO was achieved, go to 1).

```
NOTE 6 Parsing and searching will then take place in the next generation.
```

## Annex I

## (informative)

## Use case of WTX (waiting time extension) procedure and

## application waiting time procedure

**I.1 Example in case of block waiting time shorter than maximum application
waiting time**

#### Figure I.1 illustrates an example of WTX (waiting time extension) procedure for T = 1 protocol defined

#### in ISO/IEC 7816-3 and application waiting time procedure defined in 12.2.4. In case of this example, the

#### block waiting time used for WTX is shorter than the maximum application waiting time used for waiting

#### time management. The application waiting time management information is stored in EF .ATR/ INFO.


#### Figure I.1 — Example of WTX procedure and waiting time management (1 of 2)


#### Figure I.1 — Example of WTX procedure and waiting time management (2 of 2)

#### In Figure I.1, command APDU #1 and #2 are sent from IFD to ICC. Command APDU #1 is processed

#### successfully. Command APDU #2 processing is not completed within the maximum application waiting

#### time defined in the application waiting time management information. Then the application on IFD

#### decides to deactivate and/or to reject ICC. The following is detailed sequence in Figure I.1:

#### 1) IFD activates ICC, then MF in ICC is selected and ICC responds ATR.

#### 2) Both IFD and ICC activate their own protocol.

#### 3) IFD starts the application on IFD.

#### 4) The application on IFD reads EF .ATR/ INFO including application waiting time management

#### information.

#### 5) The application on IFD selects the application in ICC, then ICC responds.

#### 6) The application on IFD sends command APDU #1, then ICC starts the command processing.

#### 7) Before exceeding the block waiting time, ICC requests WTX to IFD.

#### 8) IFD accepts WTX, then responds.

#### 9) ICC continues the command processing.

#### 10) ICC sends response APDU #1 before exceeding the maximum application waiting time.

#### 11) The application on IFD sends command APDU #2, then ICC starts the command processing.

#### 12) Before exceeding the block waiting time, ICC requests WTX to IFD.

#### 13) IFD accepts WTX, then responds.


#### 14) ICC continues the command processing.

#### 15) ICC does not complete the command processing within the maximum application waiting time.

#### 16) IFD decides to deactivate and/or to reject ICC.


## Bibliography

#### [1] EN 419212 (all parts), Application Interface for Secure Elements for Electronic Identification,

#### Authentication and Trusted Services

#### [2] ISO 3166-1, Codes for the representation of names of countries and their subdivisions — Part 1:

#### Country codes

#### [3] ISO/IEC 7812-1, Identification cards — Identification of issuers — Part 1: Numbering system

#### [4] ISO/IEC 7816 (all parts), Identification cards — Integrated circuit cards

#### [5] ISO/IEC/TR 9577, Information technology — Protocol identification in the network layer

#### [6] ISO/IEC 9796 (all parts), Information technology — Security techniques — Digital signature

#### schemes giving message recovery

#### [7] ISO/IEC 9797 (all parts), Information technology — Security techniques — Message Authentication

#### Codes (MACs)

#### [8] ISO/IEC 9798 (all parts), IT Security techniques — Entity authentication

#### [9] ISO/IEC 10116, Information technology — Security techniques — Modes of operation for an n-bit

#### block cipher

#### [10] ISO/IEC 10118 (all parts), IT Security techniques — Hash-functions

#### [11] ISO/IEC 10536 (all parts), Identification cards — Contactless integrated circuit(s) cards — Close-

#### coupled cards

#### [12] ISO/IEC 10646, Information technology — Universal Coded Character Set (UCS)

#### [13] ISO/IEC 11770 (all parts), IT Security techniques — Key management

#### [14] ISO/IEC 14443 (all parts), Cards and security devices for personal identification — Contactless

#### proximity objects

#### [15] ISO/IEC 14888 (all parts), IT Security techniques — Digital signatures with appendix

#### [16] ISO/IEC 15693 (all parts), Cards and security devices for personal identification — Contactless

#### vicinity objects

#### [17] ISO/IEC 18013-3, Information technology — Personal identification — ISO-compliant driving

#### licence — Part 3: Access control, authentication and integrity validation

#### [18] ISO/IEC 18033 (all parts), IT Security techniques — Encryption algorithms

#### [19] ISO/IEC 18092, Information technology — Telecommunications and information exchange between

#### systems — Near Field Communication — Interface and Protocol (NFCIP-1)

#### [20] ISO/IEC 18328 (all parts), Identification cards — ICC-managed devices

#### [21] ISO/IEC 24727 (all parts), Identification cards — Integrated circuit card programming interfaces

#### [22] ISO/IEC 29192-4, Information technology — Security techniques — Lightweight cryptography —

#### Part 4: Mechanisms using asymmetric techniques

#### [23] IETF RFC 1738, Uniform Resource Locators (URL)

#### [24] IETF RFC 2396, Uniform Resource Locators (URL): Generic Syntax



### ICS 35.240.15

Price based on 176 pages


